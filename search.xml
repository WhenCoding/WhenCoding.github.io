<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache HttpClient超时的原因及解决方案</title>
    <url>/p/9233.html</url>
    <content><![CDATA[<p>几种超时情况分析</p>
<span id="more"></span>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>超时错误通常发生在使用Apache HttpClient库进行HTTP请求的时候，它表示连接管理器无法为请求提供一个可用的连接。这个错误可能是由以下原因引起的：</p>
<ul>
<li>服务器响应时间过慢，导致连接管理器占用了大量的请求线程而没有得到释放。</li>
<li>连接池设置不合理，例如连接数过少或者连接超时时间设置太短等。</li>
<li>网络问题，例如DNS解析失败、网络异常等。</li>
</ul>
<p>如果遇到这个问题，可以尝试以下几种解决方案：</p>
<ol>
<li>调整连接池的配置，将最大连接数、每个路由的最大连接数以及连接空闲超时时间等参数调整为合适的值。</li>
<li>增加请求超时时间，使得系统能够有更多的时间等待连接管理器为请求分配连接。</li>
<li>检查网络环境，确保网络正常运行，并且DNS能够正常解析地址。</li>
<li>在复杂的系统中，使用异步非阻塞的HTTP客户端，能够有效地避免此类问题的出现。</li>
</ol>
<h2 id="Connection-lease-request-time-out"><a href="#Connection-lease-request-time-out" class="headerlink" title="Connection lease request time out"></a>Connection lease request time out</h2><p>根据实际情况，调整<code>httpClient</code>连接池的配置，具体有如下参数：<br><code>ConnectTimeout</code>：连接建立时间，即三次握手完成时间(单位是ms),超时则抛出<code>ConnectionTimeOutException</code><br><code>SocketTimeout</code>：连接建立后，数据传输过程中数据包之间间隔的最大时间(单位是ms),超时则抛出<code>SocketTimeOutException</code><br><code>ConnectionRequestTimeout</code>：<code>httpclient</code>使用连接池来管理连接，这个时间就是从连接池获取连接的超时时间(单位是ms),超时则抛出<code>ConnectionPoolTimeoutException</code>；<br><code>maxConnTotal</code>：是同时间正在使用的最多的连接数<br><code>maxConnPerRoute</code>是针对一个域名同时间正在使用的最多的连接数<br>因此，如果是需要频繁调用同一个域名，那么即使<code>maxConnTotal</code>设置再大，还是受限制于<code>maxConnPerRoute</code></p>
<h3 id="配置举例"><a href="#配置举例" class="headerlink" title="配置举例"></a>配置举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HttpClient client;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="type">RequestConfig</span> <span class="variable">requestConfig</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">           .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">           .setConnectionRequestTimeout(<span class="number">1000</span>)</span><br><span class="line">           .setSocketTimeout(<span class="number">5000</span>).build();</span><br><span class="line">   client = HttpClientBuilder.create().setDefaultRequestConfig(requestConfig)</span><br><span class="line">           .setMaxConnTotal(<span class="number">200</span>)</span><br><span class="line">           .setMaxConnPerRoute(<span class="number">50</span>)</span><br><span class="line">           .build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>根据报错提示，追溯源码，该报错是因为从连接池获取连接时，当前时间大于我们设置获取连接池的时间1秒，所以就抛出异常。所以，我们将连接池的连接数调大，同时适当调大连接池连接时间，即可解决问题。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>HttpClient</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT太太太太太香了</title>
    <url>/p/62899.html</url>
    <content><![CDATA[<p>💡 我感觉以后再也不用某度了</p>
<span id="more"></span>
<h3 id="实际开发中一些让人眼前一亮的回答"><a href="#实际开发中一些让人眼前一亮的回答" class="headerlink" title="实际开发中一些让人眼前一亮的回答"></a>实际开发中一些让人眼前一亮的回答</h3><h4 id="要将一个分支的某几次提交记录合并到另一个分支，可以使用-git-cherry-pick-命令"><a href="#要将一个分支的某几次提交记录合并到另一个分支，可以使用-git-cherry-pick-命令" class="headerlink" title="要将一个分支的某几次提交记录合并到另一个分支，可以使用 git cherry-pick 命令"></a>要将一个分支的某几次提交记录合并到另一个分支，可以使用 git cherry-pick 命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commit-hash-1&gt; &lt;commit-hash-2&gt; ...</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;commit-hash-1&gt;</code>, <code>&lt;commit-hash-2&gt;</code> 等是你要合并的提交记录的哈希值。例如，如果你想将分支 <code>feature-branch</code> 上的提交记录 <code>abc123</code> 和 <code>def456</code> 合并到 <code>master</code> 分支上，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git cherry-pick abc123 def456</span><br></pre></td></tr></table></figure>

<p>这将在 <code>master</code> 分支上创建两个新的提交记录，这些提交记录与 <code>feature-branch</code> 上的提交记录相同。请注意，如果这些提交记录与 <code>master</code> 分支上的其他提交记录有冲突，你需要解决这些冲突并手动提交合并结果。</p>
<p>另外，如果你想将整个分支合并到另一个分支上，可以使用 <code>git merge</code> 命令。例如，如果你想将 <code>feature-branch</code> 分支合并到 <code>master</code> 分支上，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge feature-branch</span><br></pre></td></tr></table></figure>

<p>这将在 <code>master</code> 分支上创建一个新的合并提交记录，将 <code>feature-branch</code> 分支的所有更改合并到 <code>master</code> 分支上。</p>
<h4 id="linux用命令行解析输出用括号括起来的参数日志，只需要第三个"><a href="#linux用命令行解析输出用括号括起来的参数日志，只需要第三个" class="headerlink" title="linux用命令行解析输出用括号括起来的参数日志，只需要第三个"></a>linux用命令行解析输出用括号括起来的参数日志，只需要第三个</h4><p>假设日志文件的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2022-01-01 12:00:00] INFO: This is a log message.</span><br><span class="line">[2022-01-01 12:01:00] ERROR: Something went wrong.</span><br><span class="line">[2022-01-01 12:02:00] DEBUG: Debugging information.</span><br></pre></td></tr></table></figure>

<p>可以使用以下命令来获取括号中的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F&#x27;[][]&#x27; &#x27;&#123;print $2&#125;&#x27; logfile.txt</span><br></pre></td></tr></table></figure>

<p>这个命令使用方括号作为字段分隔符，然后打印第二个字段。由于方括号在awk中有特殊含义，因此需要使用反斜杠来转义它们。输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-01-01 12:00:00</span><br><span class="line">2022-01-01 12:01:00</span><br><span class="line">2022-01-01 12:02:00</span><br></pre></td></tr></table></figure>
<p>这些是日志中括号中的时间戳。如果你想获取括号中的其他内容，只需更改打印的字段编号即可。</p>
<h4 id="帮我用-java8-写一个处理list中某个字段相同值的统计，并从大到小排序"><a href="#帮我用-java8-写一个处理list中某个字段相同值的统计，并从大到小排序" class="headerlink" title="帮我用 java8 写一个处理list中某个字段相同值的统计，并从大到小排序"></a>帮我用 java8 写一个处理list中某个字段相同值的统计，并从大到小排序</h4><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230328113643.jpg"
                     
                >

<p>如果你想加入我的ChatGPT群，请关注微信公众号：程序员小明，回复<strong>ChatGPT</strong>拉你进群。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置upstream实现负载均衡</title>
    <url>/p/bf32.html</url>
    <content><![CDATA[<blockquote>
<p>今天小明试了一把运维的活，通过配置nginx upstream模块，实现访问不同的域名地址指向不同端口（不用对外报漏应用程序的端口号）。具体操作如下：<br>Nginx能够配置代理多台服务器。当一台服务器宕机之后。仍能保持系统可用。详细配置步骤如下：</p>
</blockquote>
<ul>
<li>在http节点下，加入upstream节点。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream direct_server &#123; </span><br><span class="line">      server 10.0.6.108:7080; # 可以指向本地服务器或者远程服务器</span><br><span class="line">      server 10.0.0.85:8980;  # 配置多个可以实现负载均衡</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将server节点下的location节点中的proxy_pass配置为：http:// + upstream名称，即“<a class="link"   href="http://direct_server”/" >http://direct_server”<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.mynamecoder.com; # 根据你的访问域名设置</span><br><span class="line">    location / &#123; </span><br><span class="line">            root  html; </span><br><span class="line">            index  index.html index.htm; </span><br><span class="line">            proxy_pass http://direct_server; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如今负载均衡初步完毕了。upstream依照轮询（默认）方式进行负载，每一个请求按时间顺序逐一分配到不同的后端服务器。假设后端服务器down掉。能自己主动剔除。尽管这样的方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。适用于图片服务器集群和纯静态页面服务器集群。</p>
<p>除此之外，upstream还有其他的分配策略，分别例如以下：</p>
<ul>
<li>weight（权重）<br>指定轮询几率，weight和訪问比率成正比，用于后端服务器性能不均的情况。例如以下所看到的。10.0.0.88的訪问比率要比10.0.0.77的訪问比率高一倍。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream direct_server&#123; </span><br><span class="line">      server 10.0.0.77 weight=5; </span><br><span class="line">      server 10.0.0.88 weight=10; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ip_hash（访问ip）</li>
</ul>
<p>每一个请求按访问ip的hash结果分配。这样每一个訪客固定訪问一个后端服务器，能够解决session的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream favresin&#123; </span><br><span class="line">      ip_hash; </span><br><span class="line">      server 10.0.0.10:8080; </span><br><span class="line">      server 10.0.0.11:8080; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fair（第三方）按后端服务器的响应时间来分配请求。响应时间短的优先分配。</li>
</ul>
<p>与weight分配策略相似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream favresin&#123;      </span><br><span class="line">      server 10.0.0.10:8080; </span><br><span class="line">      server 10.0.0.11:8080; </span><br><span class="line">      fair; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>url_hash（第三方）</li>
</ul>
<p>按訪问url的hash结果来分配请求，使每一个url定向到同一个后端服务器。后端服务器为缓存时比較有效。</p>
<p>注意：在upstream中加入hash语句。server语句中不能写入weight等其他的參数，hash_method是使用的hash算法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream resinserver&#123; </span><br><span class="line">      server 10.0.0.10:7777; </span><br><span class="line">      server 10.0.0.11:8888; </span><br><span class="line">      hash $request_uri; </span><br><span class="line">      hash_method crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为每一个设备设置状态值"><a href="#为每一个设备设置状态值" class="headerlink" title="为每一个设备设置状态值"></a>为每一个设备设置状态值</h2><p>这些状态值的含义分别例如以下：</p>
<ul>
<li><p>down 表示单前的server临时不參与负载.</p>
</li>
<li><p>weight 默觉得1.weight越大，负载的权重就越大。</p>
</li>
<li><p>max_fails ：同意请求失败的次数默觉得1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</p>
</li>
<li><p>fail_timeout : max_fails次失败后。暂停的时间。</p>
</li>
<li><p>backup： 其他全部的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream bakend&#123; #定义负载均衡设备的Ip及设备状态 </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 10.0.0.11:9090 down; </span><br><span class="line">    server 10.0.0.11:8080 weight=2; </span><br><span class="line">    server 10.0.0.11:6060; </span><br><span class="line">    server 10.0.0.11:7070 backup; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是小明配置负载均衡时遇到的一点小总结，和大家一块分享一下，希望可以帮助到大家。</p>
<h2 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="关注公众号"
                ></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的bug总结，快来看一下你有没有遇到</title>
    <url>/p/b1fe.html</url>
    <content><![CDATA[<h2 id="接口请求-Status-blocked-other"><a href="#接口请求-Status-blocked-other" class="headerlink" title="接口请求:Status(blocked:other)"></a>接口请求:Status(blocked:other)</h2><p>有一次在前端请求后台提供的接口时，突然发现自己的浏览器不能请求</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="http://img.mynamecoder.com/FrHqA_C7J80ifxtGHoPjlF1emCU3"
                     
                ></p>
<p>倒腾了很久，才发现是被浏览器插件（如我使用的是AdBlock插件）当作广告拦截了，当你在一个广告业务的公司工作，尤其要注意一哈。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ol>
<li>停用你的广告拦截器</li>
<li>在当前网站停用广告拦截插件（比如AdBlock）</li>
</ol>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
  </entry>
  <entry>
    <title>这就是CDN回源原理和CDN多级缓存啊！</title>
    <url>/p/ead7.html</url>
    <content><![CDATA[<blockquote>
<p>小明对项目中的cdn缓存一直不是太明白……</p>
</blockquote>
<h2 id="CDN回源"><a href="#CDN回源" class="headerlink" title="CDN回源"></a>CDN回源</h2><h3 id="回源原理"><a href="#回源原理" class="headerlink" title="回源原理"></a>回源原理</h3><ul>
<li><p>回源是指浏览器在发送请求报文时，响应该请求报文的是源站点的服务器，而不是各节点上的缓存服务器（比如nginx开启缓存），那么这个过程相对于通过各节点上的缓存服务器来响应的话就称作为回源。回源的请求或流量太多的话，有可能会让源站点的服务器承载着过大的访问压力，进而影响服务的正常访问。</p>
</li>
<li><p>回源域名一般是cdn领域的专业术语，通常情况下，是直接用ip进行回源的，但是如果客户源站有多个ip，并且ip地址会经常变化，对于cdn厂商来说，为了避免经常更改配置（回源ip），会采用回源域名方式进行回源，这样即使源站的ip变化了，也不影响原有的配置。</p>
</li>
<li><p>常规的CDN都是回源的。即：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么CDN节点不会主动去源站拿的。</p>
</li>
<li><p>源站内容有更新的时候，源站可以主动把内容推送到CDN节点。参考阿里云url预热<a class="link"   href="https://help.aliyun.com/knowledge_detail/40106.html?spm=a2c4e.11153987.0.0.419f6ec5UvPSJ1" >https://help.aliyun.com/knowledge_detail/40106.html?spm=a2c4e.11153987.0.0.419f6ec5UvPSJ1<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>CDN本来是给我们的网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。</p>
</li>
</ul>
<h2 id="CDN回源率计算方法"><a href="#CDN回源率计算方法" class="headerlink" title="CDN回源率计算方法"></a>CDN回源率计算方法</h2><p>回源比分为回源请求数比例及回源流量比例两种：</p>
<h3 id="回源请求数比"><a href="#回源请求数比" class="headerlink" title="回源请求数比"></a>回源请求数比</h3><p>统计数据来自所有边缘节点上的请求记录，其中，对于没有缓存或缓存过期（可缓存）的请求以及不可缓存的请求，均计入回源请求中，其他直接命中缓存的，则为命中请求。</p>
<h3 id="回源流量比"><a href="#回源流量比" class="headerlink" title="回源流量比"></a>回源流量比</h3><p>回源流量是回源请求文件大小产生的流量和请求本身产生的流量   回源流量比=回源流量/回源流量+用户请求访问的流量</p>
<h2 id="CDN常见多级缓存"><a href="#CDN常见多级缓存" class="headerlink" title="CDN常见多级缓存"></a>CDN常见多级缓存</h2><h3 id="CDN概念"><a href="#CDN概念" class="headerlink" title="CDN概念"></a>CDN概念</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h3 id="CDN工作方法"><a href="#CDN工作方法" class="headerlink" title="CDN工作方法"></a>CDN工作方法</h3><p>客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求（back to the source request）,来拉取最新的数据。CDN的典型拓扑图如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/x1SX6SH/cdn.png"
                      alt="CDN的典型拓扑图"
                ></p>
<h3 id="CDN层级划分："><a href="#CDN层级划分：" class="headerlink" title="CDN层级划分："></a>CDN层级划分：</h3><ul>
<li><p>CDN系统中，直接面向用户，负责给用户提供内容服务的的Cache设备都部署在整个 CDN网络的边缘位置，所以将这一层称为边缘层。</p>
</li>
<li><p>CDN系统中，中心层负责全局的管理和控制，同时也保存了最多的内容Cache。在边缘层设备未能命中Cache时，需要向中心层设备请求；而中心层未能命中时，则需要向源站请求。不同的CDN系统设计存在差异，中心层可能具备用户服务的能力，也可能只会向下一层提供服务。</p>
</li>
<li><p>如果CDN系统比较庞大，边缘层向中心层请求内容太多，会造成中心层负载压力太大。此时，需要在中心层和边缘层之间部署一个区域层，负责一个区域的管理和控制，也可以提供一些内容Cache供边缘层访问。</p>
</li>
</ul>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求。类似浏览器缓存，CDN边缘节点也存在着一套缓存机制。</p>
<h3 id="CDN缓存的缺点"><a href="#CDN缓存的缺点" class="headerlink" title="CDN缓存的缺点"></a>CDN缓存的缺点</h3><p>CDN的分流作用不仅减少了用户的访问延时，也减少的源站的负载。但其缺点也很明显：当网站更新时，如果CDN节点上数据没有及时更新，即便用户再浏览器使用Ctrl +F5的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。</p>
<h3 id="CDN缓存策略"><a href="#CDN缓存策略" class="headerlink" title="CDN缓存策略"></a>CDN缓存策略</h3><ul>
<li><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的Cache-control: max-age的字段来设置CDN边缘节点数据缓存时间。</p>
</li>
<li><p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p>
</li>
<li><p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
</li>
<li><p>CDN缓存时间会对“回源率”产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p>
</li>
</ul>
<h3 id="CDN缓存刷新"><a href="#CDN缓存刷新" class="headerlink" title="CDN缓存刷新"></a>CDN缓存刷新</h3><p>CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><p><a class="link"   href="https://blog.csdn.net/mountains2001/article/details/52766431" >https://blog.csdn.net/mountains2001/article/details/52766431<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://blog.csdn.net/wangxin1982314/article/details/51050206/" >https://blog.csdn.net/wangxin1982314/article/details/51050206/<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://blog.csdn.net/songchunmin_/article/details/69942991" >https://blog.csdn.net/songchunmin_/article/details/69942991<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.jianshu.com/p/7b749b49201a" >https://www.jianshu.com/p/7b749b49201a<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h2 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title>这年头，谁的好友列表还没有躺一个ChatGPT啊？</title>
    <url>/p/5013.html</url>
    <content><![CDATA[<p>🔥 你要是说这个，我可不困了</p>
<span id="more"></span>

<p>大家好，我最近开始使用一款非常有趣的AI机器人，它叫做ChatGPT。ChatGPT是一款独特的聊天机器人，它可以进行智能对话，回答你的问题，还可以学习你的语言习惯，使得对话更加流畅和自然。</p>
<p>ChatGPT的应用非常广泛，它能够应用在语言学习、客户服务、人机交互等多个领域。无论你是学生、工程师、普通用户，都可以从中获得帮助。</p>
<p>于是，我将chatGPT的能力赋予了我的聊天机器人~大家可以观看一下效果</p>
<iframe src="//player.bilibili.com/player.html?aid=311143188&bvid=BV1TP411f7X8&cid=1059111407&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width = "100%" height=500> </iframe>

<p>如果你也对ChatGPT感兴趣，欢迎加入我的群聊，我们可以一起探索这个聊天机器人的奥秘。</p>
<p>在这个群聊中，我们可以分享我们的经验和想法，互相帮助和支持。</p>
<p>ChatGPT是一个优秀的AI机器人，值得一试，我相信你一定会喜欢上它。如果你想加入我的ChatGPT群，请关注微信公众号：程序员小明，回复<strong>ChatGPT</strong>拉你进群。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                ></p>
<blockquote>
<p><font color=red>以上文案出自ChatGPT</font></p>
</blockquote>
]]></content>
      <tags>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>Docx文档如何实现的自动编号？</title>
    <url>/p/46554.html</url>
    <content><![CDATA[<p>📃 不得不佩服优秀软件的规范</p>
<span id="more"></span>
<p>上次讲到<a href="https://mynamecoder.com/p/8425.html">使用Freemarker生成word文档</a>，这种方案对不常变更的需求是非常不错的。但是，哪有产品需求不变更的？<br>今天就遇到了一个坑，标题的编号问题。<br>虽然我们可以动态替换文本，但是要是想借用docx自己的文档规范生成，岂不是一劳永逸？</p>
<h3 id="序号定义"><a href="#序号定义" class="headerlink" title="序号定义"></a>序号定义</h3><p>像往常一样，我们把一个docx文档解压，可以得到目录结构，而序号的定义就存在<code>numbering.xml</code>中，包括从几开始、序号的样式：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230427171426.png"
                      weight=300 height=300
                ></p>
<p>有两种类型，<code>abstractNum</code>和<code>num</code>，其中每个<code>numId</code>对应一个<code>abstractNumId</code>，每个<code>abstractNumId</code>对应一组格式，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- abstractNum --&gt;</span><br><span class="line">&lt;!-- 对应一组格式 --&gt;</span><br><span class="line">&lt;w:abstractNum w:abstractNumId=&quot;12&quot;&gt;</span><br><span class="line">    &lt;w:nsid w:val=&quot;7A70A8F6&quot;/&gt;</span><br><span class="line">    &lt;w:multiLevelType w:val=&quot;singleLevel&quot;/&gt;</span><br><span class="line">    &lt;w:tmpl w:val=&quot;7A70A8F6&quot;/&gt;</span><br><span class="line">    &lt;!-- 对应这一组格式中的一种格式 --&gt;</span><br><span class="line">    &lt;w:lvl w:ilvl=&quot;0&quot; w:tentative=&quot;0&quot;&gt;</span><br><span class="line">        &lt;!-- 表示这种格式从几开始 --&gt;</span><br><span class="line">        &lt;w:start w:val=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;!-- 表示这种格式是什么类型的 --&gt;</span><br><span class="line">        &lt;w:numFmt w:val=&quot;chineseCounting&quot;/&gt;</span><br><span class="line">        &lt;w:suff w:val=&quot;nothing&quot;/&gt;</span><br><span class="line">        &lt;!-- 表示这种格式的样式 --&gt;</span><br><span class="line">        &lt;w:lvlText w:val=&quot;（%1）&quot;/&gt;</span><br><span class="line">        &lt;w:lvlJc w:val=&quot;left&quot;/&gt;</span><br><span class="line">        &lt;w:rPr&gt;</span><br><span class="line">            &lt;w:rFonts w:hint=&quot;eastAsia&quot;/&gt;</span><br><span class="line">        &lt;/w:rPr&gt;</span><br><span class="line">    &lt;/w:lvl&gt;</span><br><span class="line">&lt;/w:abstractNum&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- num --&gt;</span><br><span class="line">&lt;w:num w:numId=&quot;1&quot;&gt;</span><br><span class="line">    &lt;w:abstractNumId w:val=&quot;12&quot;/&gt;</span><br><span class="line">&lt;/w:num&gt;</span><br></pre></td></tr></table></figure>


<h3 id="序号使用"><a href="#序号使用" class="headerlink" title="序号使用"></a>序号使用</h3><p>主文档<code>document.xml</code>引用序号格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;w:numPr&gt;</span><br><span class="line">    &lt;!-- 用来确定是同个abstractNumId的不同格式 --&gt;</span><br><span class="line">    &lt;w:ilvl w:val=&quot;0&quot;/&gt;</span><br><span class="line">    &lt;!-- 其中 `numId`就是引用`numbering.xml`中的定义 --&gt;</span><br><span class="line">    &lt;w:numId w:val=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/w:numPr&gt;</span><br></pre></td></tr></table></figure>
<p>每个numId对应一个abstractNumId，自动编号用两次就会自上而下生成“一、…… 二、……”。此时，这两段标题的numId是一样的。不需要自动编号的段落的numId为0，且没有对应的abstractNumId。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>带编号的段落在document.xml生成一个numId和ilvl，每个numId对应一个abstractNumId，每个abstractNumId有一组格式序列，每个ilvl对应改组格式序列的一种格式。每个格式有start确定起始编号，numFmt确定格式类型，lvlText确定格式样式。通过numFmt和lvlText的组合确定自动编号的最终的样式</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Freemarker</tag>
        <tag>Docx</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Github表情大全</title>
    <url>/p/22086.html</url>
    <content><![CDATA[<p>🎁 为你的README.md增添色彩，拿走不谢。</p>
<span id="more"></span>
<h2 id="Mac用户使用Fn-E进行搜索使用更丝滑"><a href="#Mac用户使用Fn-E进行搜索使用更丝滑" class="headerlink" title="Mac用户使用Fn+E进行搜索使用更丝滑"></a>Mac用户使用Fn+E进行搜索使用更丝滑</h2><h2 id="People"><a href="#People" class="headerlink" title="People"></a>People</h2><p>😄 😆 😊 😃 ☺️ 😏 😍 😘 😚 😳 😌 😆 😁 😉 😜 😝 😀 😗 😙 😛 😴 😟 😦 😧 😮 😬 😕 😯 😑 😒 😅 😓 😥 😩 😔 😞 😖 😨 😰 😣 😢 😭 😂 😲 😱 😫 😠 😡 😤 😪 😋 😷 😎 😵 👿 😈 😐 😶 😇 👽 💛 💙 💜 ❤️ 💚 💔 💓 💗 💕 💞 💘 💖 ✨ ⭐ 🌟 💫 💥 💥 💢 ❗ ❓ ❕ ❔ 💤 💨 💦 🎶 🎵 🔥 💩 💩 💩 👍 👍 👎 👎 👌 👊 👊 ✊ ✌️ 👋 ✋ ✋ 👐 ☝️ 👇 👈 👉 🙌 🙏 👆 👏 💪 🤘 🖕 🏃 🏃 👫 👪 👬 👭 💃 👯 🙆‍♀️ 🙅 💁 🙋 👰‍♀️ 🙎 🙍 🙇 💑 💆 💇 💅 👦 👧 👩 👨 👶 👵 👴 👱 👲 👳‍♂️ 👷 👮 👼 👸 😺 😸 😻 😽 😼 🙀 😿 😹 😾 👹 👺 🙈 🙉 🙊 💂‍♂️ 💀 🐾 👄 💋 💧 👂 👀 👃 👅 💌 👤 👥 💬 💭</p>
<h2 id="Nature"><a href="#Nature" class="headerlink" title="Nature"></a>Nature</h2><p>☀️ ☔ ☁️ ❄️ ⛄ ⚡ 🌀 🌁 🌊 🐱 🐶 🐭 🐹 🐰 🐺 🐸 🐯 🐨 🐻 🐷 🐽 🐮 🐗 🐵 🐒 🐴 🐎 🐫 🐑 🐘 🐼 🐍 🐦 🐤 🐥 🐣 🐔 🐧 🐢 🐛 🐝 🐜 🪲 🐌 🐙 🐠 🐟 🐳 🐋 🐬 🐄 🐏 🐀 🐃 🐅 🐇 🐉 🐐 🐓 🐕 🐖 🐁 🐂 🐲 🐡 🐊 🐪 🐆 🐈 🐩 🐾 💐 🌸 🌷 🍀 🌹 🌻 🌺 🍁 🍃 🍂 🌿 🍄 🌵 🌴 🌲 🌳 🌰 🌱 🌼 🌾 🐚 🌐 🌞 🌝 🌚 🌑 🌒 🌓 🌔 🌕 🌖 🌗 🌘 🌜 🌛 🌙 🌍 🌎 🌏 🌋 🌌 ⛅</p>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p>🎍 💝 🎎 🎒 🎓 🎏 🎆 🎇 🎐 🎑 🎃 👻 🎅 🎄 🎁 🔔 🔕 🎋 🎉 🎊 🎈 🔮 💿 📀 💾 📷 📹 🎥 💻 📺 📱 ☎️ ☎️ 📞 📟 📠 💽 📼 🔉 🔈 🔇 📢 📣 ⌛ ⏳ ⏰ ⌚ 📻 📡 ➿ 🔍 🔎 🔓 🔒 🔏 🔐 🔑 💡 🔦 🔆 🔅 🔌 🔋 📲 📧 📫 📮 🛀 🛁 🚿 🚽 🔧 🔩 🔨 💺 💰 💴 💵 💷 💶 💳 💸 📧 📥 📤 ✉️ 📨 📯 📪 📬 📭 📦 🚪 🚬 💣 🔫 🔪 💊 💉 📄 📃 📑 📊 📈 📉 📜 📋 📆 📅 📇 📁 📂 ✂️ 📌 📎 ✒️ ✏️ 📏 📐 📕 📗 📘 📙 📓 📔 📒 📚 🔖 📛 🔬 🔭 📰 🏈 🏀 ⚽ ⚾ 🎾 🎱 🎱 🏉 🎳 ⛳ 🚵 🚴 🏇 🏂 🏊 🏄 🎿 ♠️ ♥️ ♣️ ♦️ 💎 💍 🏆 🎼 🎹 🎻 👾 🎮 🃏 🎴 🎲 🎯 🀄 🎬 📝 📝 📖 🎨 🎤 🎧 🎺 🎷 🎸 👞 👡 👠 💄 👢 👕 👕 👔 👚 👗 🎽 👖 👘 👙 🎀 🎩 👑 👒 👞 🌂 💼 👜 👝 👛 👓 🎣 ☕ 🍵 🍶 🍼 🍺 🍻 🍸 🍹 🍷 🍴 🍕 🍔 🍟 🍗 🍖 🍝 🍛 🍤 🍱 🍣 🍥 🍙 🍘 🍚 🍜 🍲 🍢 🍡 🥚 🍞 🍩 🍮 🍦 🍨 🍧 🎂 🍰 🍪 🍫 🍬 🍭 🍯 🍎 🍏 🍊 🍋 🍒 🍇 🍉 🍓 🍑 🍈 🍌 🍐 🍍 🍠 🍆 🍅 🌽</p>
<h2 id="Places"><a href="#Places" class="headerlink" title="Places"></a>Places</h2><p>🏠 🏡 🏫 🏢 🏣 🏥 🏦 🏪 🏩 🏨 💒 ⛪ 🏬 🏤 🌇 🌆 🏯 🏰 ⛺ 🏭 🗼 🗾 🗻 🌄 🌅 🌠 🗽 🌉 🎠 🌈 🎡 ⛲ 🎢 🚢 🚤 ⛵ ⛵ 🚣 ⚓ 🚀 ✈️ 🚁 🚂 🚊 🚞 🚲 🚡 🚟 🚠 🚜 🚙 🚘 🚗 🚗 🚕 🚖 🚛 🚌 🚍 🚨 🚓 🚔 🚒 🚑 🚐 🚚 🚋 🚉 🚆 🚅 🚄 🚈 🚝 🚃 🚎 🎫 ⛽ 🚦 🚥 ⚠️ 🚧 🔰 🏧 🎰 🚏 💈 ♨️ 🏁 🎌 🏮 🗿 🎪 🎭 📍 🚩 🇯🇵 🇰🇷 🇨🇳 🇺🇸 🇫🇷 🇪🇸 🇮🇹 🇷🇺 🇬🇧 🇬🇧 🇩🇪</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟 🔢 0️⃣ #️⃣ 🔣 ◀️ ⬇️ ▶️ ⬅️ 🔠 🔡 🔤 ↙️ ↘️ ➡️ ⬆️ ↖️ ↗️ ⏬ ⏫ 🔽 ⤵️ ⤴️ ↩️ ↪️ ↔️ ↕️ 🔼 🔃 🔄 ⏪ ⏩ ℹ️ 🆗 🔀 🔁 🔂 🆕 🔝 🆙 🆒 🆓 🆖 🎦 🈁 📶 🈹 🈴 🈺 🈯 🈷️ 🈶 🈵 🈚 🈸 🈳 🈲 🈂️ 🚻 🚹 🚺 🚼 🚭 🅿️ ♿ 🚇 🛄 🉑 🚾 🚰 🚮 ㊙️ ㊗️ Ⓜ️ 🛂 🛅 🛃 🉐 🆑 🆘 🆔 🚫 🔞 📵 🚯 🚱 🚳 🚷 🚸 ⛔ ✳️ ❇️ ✴️ 💟 🆚 📳 📴 💹 💱 ♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎ 🔯 ❎ 🅰️ 🅱️ 🆎 🅾️ 💠 ♻️ 🔚 🔙 🔛 🔜 🕐 🕜 🕙 🕥 🕚 🕦 🕛 🕧 🕑 🕝 🕒 🕞 🕓 🕟 🕔 🕠 🕕 🕡 🕖 🕢 🕗 🕣 🕘 🕤 💲 ©️ ®️ ™️ ❌ ❗ ‼️ ⁉️ ⭕ ✖️ ➕ ➖ ➗ 💮 💯 ✔️ ☑️ 🔘 🔗 ➰ 〰️ 〽️ 🔱 ▪️ ▫️ ◾ ◽ ◼️ ◻️ ⬛ ⬜ ✅ 🔲 🔳 ⚫ ⚪ 🔴 🔵 🔷 🔶 🔹 🔸 🔺 🔻</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>还没有自己的网站？ICP备案了解一下！</title>
    <url>/p/54c3.html</url>
    <content><![CDATA[<blockquote>
<p>小明近期计划发誓要搭建属于自己的网站!</p>
</blockquote>
<h2 id="关于ICP-Internet-Content-Provider-即网络内容提供商"><a href="#关于ICP-Internet-Content-Provider-即网络内容提供商" class="headerlink" title="关于ICP(Internet Content Provider)即网络内容提供商"></a>关于ICP(Internet Content Provider)即网络内容提供商</h2><p>ICP可以理解为经过国家主管部门批准的正式企业或部门，向用户提供互联网业务和服务的运营商,比如：阿里云、腾讯云、华为等众多服务商……那ICP备案就是域名的备案，域名就是网站访问的链接地址。举个例子，百度的访问地址：<a class="link"   href="http://www.baidu.com./" >www.baidu.com。<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="那我们为什么要通过ICP备案呢？"><a href="#那我们为什么要通过ICP备案呢？" class="headerlink" title="那我们为什么要通过ICP备案呢？"></a>那我们为什么要通过ICP备案呢？</h2><p>根据工信部《互联网信息服务管理办法》，<strong>网站在未完成备案之前，不能指向大陆境内服务器开通访问</strong>。当今庞大的互联网世界里，需要一个良好的环境，那么国家就需要对所有企业和个人建立的网站进行统一登记和管理，就像我们每个人出生后，父母都要为我们上户口一样，我们企业或个人，在购买域名建立一个网站时，都需要完成相应的登记才行。没有登记的就是不合法的，也就是没有备案的网站，都是不允许面向用户，不许提供服务上线的。</p>
<h2 id="准备备案所需基本资料"><a href="#准备备案所需基本资料" class="headerlink" title="准备备案所需基本资料"></a>准备备案所需基本资料</h2><ul>
<li>购买/拥有一个域名 </li>
<li>购买/拥有一个轻量级云服务器（3个月以上）,<strong><a class="link"   href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=1qsydng8" >阿里云服务器购买链接<i class="fas fa-external-link-alt"></i></a></strong></li>
<li>准备备案材料,<strong><a class="link"   href="https://help.aliyun.com/knowledge_detail/36890.html" >详细介绍<i class="fas fa-external-link-alt"></i></a></strong></li>
</ul>
<h2 id="备案流程"><a href="#备案流程" class="headerlink" title="备案流程"></a>备案流程</h2><p>以上准备工作好了以后，<a class="link"   href="https://beian.aliyun.com/" >访问<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://beian.aliyun.com/" >https://beian.aliyun.com/<i class="fas fa-external-link-alt"></i></a> 开始备案流程<br><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/4TFLJY1/2019-05-09-4-10-32.png"
                      alt="备案流程图"
                >，上传资料后等待阿里客服审核资料</p>
<p>1个工作日左右，阿里客服MM会电话与你联系，确认信息，后边的流程根据提示做即可！</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>系统运维</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins自动化部署入门（一）</title>
    <url>/p/db00.html</url>
    <content><![CDATA[<h1 id="开始使用-Jenkins"><a href="#开始使用-Jenkins" class="headerlink" title="开始使用 Jenkins"></a>开始使用 Jenkins</h1><blockquote>
<p>这一段时间，技术总监为了减少测试环境每次提交新增接口都要部署项目的时间，搞了一个jenkins持续集成github、docker，这样只要每次push代码都会自动部署，确实节省了部署的时间（不加班指日可待）。</p>
</blockquote>
<p>今天主要给大家介绍使用 Jenkins 的基本知识，顺便提一嘴jdk环境和docker如何像5G飞一般的速度安装。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>第一次使用 Jenkins，您需要：</p>
<ul>
<li><p>机器要求：</p>
<ul>
<li>256 MB 内存，建议大于 512 MB</li>
<li>10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）<br>ps: 小明使用的是linux内核centos7版本服务器,1G内存1核50G硬盘的腾讯云服务器，最近腾讯云搞活动99元一年，实在太便宜了没忍住搞了一台，后台做的和阿里云如出一辙，不愧为腾讯，大家有需要的可以点击链接了解一下，<a class="link"   href="http://sina.lt/gget%E3%80%82" >http://sina.lt/gget。<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li><p>需要安装以下软件：</p>
<ul>
<li>Java 8 ( JRE 或者 JDK 都可以<a class="link"   href="https://blog.mynamecoder.com/2019/06/13/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85jdk8/" >点击查看linux如何快速安装jdk<i class="fas fa-external-link-alt"></i></a>)</li>
<li>Docker （<a class="link"   href="https://blog.mynamecoder.com/2019/06/14/linux-centos%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker/" >查看centos版本如何安装docker<i class="fas fa-external-link-alt"></i></a>）</li>
</ul>
</li>
</ul>
<h1 id="下载并运行-Jenkins"><a href="#下载并运行-Jenkins" class="headerlink" title="下载并运行 Jenkins"></a>下载并运行 Jenkins</h1><ol>
<li>下载 Jenkins(linux 中执行<code>wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war</code>).</li>
<li>打开终端进入到下载目录.</li>
<li>运行命令 java -jar jenkins.war –httpPort=8080.</li>
<li>打开浏览器进入链接 <a class="link"   href="http://localhost:8080/" >http://localhost:8080<i class="fas fa-external-link-alt"></i></a>.</li>
<li>稍等片刻，输入控制台输出的密码，按照推荐的配置完成安装.</li>
</ol>
<p>安装完成后，您可以开始使用 Jenkins！</p>
<h1 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>牢记maven的scope属性</title>
    <url>/p/2bdc.html</url>
    <content><![CDATA[<blockquote>
<p>小明今天带大家回顾一下maven依赖的作用域</p>
</blockquote>
<p>在POM4中，<code>&lt;dependency&gt;</code>引入了<code>&lt;scope&gt;</code>，它主要管理依赖的部署。目前<code>&lt;scope&gt;</code>可以使用5个值： </p>
<ul>
<li>compile，缺省值，适用于所有阶段，会随着项目一起发布。 </li>
<li>provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 </li>
<li>runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 </li>
<li>test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 </li>
<li>system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</li>
</ul>
<p>依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围：</p>
<h2 id="compile-（编译范围）"><a href="#compile-（编译范围）" class="headerlink" title="compile （编译范围）"></a>compile （编译范围）</h2><p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。</p>
<h2 id="provided-（已提供范围）"><a href="#provided-（已提供范围）" class="headerlink" title="provided （已提供范围）"></a>provided （已提供范围）</h2><p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。</p>
<h2 id="runtime-（运行时范围）"><a href="#runtime-（运行时范围）" class="headerlink" title="runtime （运行时范围）"></a>runtime （运行时范围）</h2><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC<br>驱动实现。</p>
<h2 id="test-（测试范围）"><a href="#test-（测试范围）" class="headerlink" title="test （测试范围）"></a>test （测试范围）</h2><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p>
<h2 id="system-（系统范围）"><a href="#system-（系统范围）" class="headerlink" title="system （系统范围）"></a>system （系统范围）</h2><p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis常用总结</title>
    <url>/p/1b5.html</url>
    <content><![CDATA[<h1 id="foreach之前对list进行判空"><a href="#foreach之前对list进行判空" class="headerlink" title="foreach之前对list进行判空"></a>foreach之前对list进行判空</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;if test=&quot;list != null and list.size() &gt; 0&quot;&gt;</span><br><span class="line">  _claimreview.id in</span><br><span class="line">  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;  </span><br><span class="line">    #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>

<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>9 个你应该知道的支付系统开源项目</title>
    <url>/p/d6d4.html</url>
    <content><![CDATA[<blockquote>
<p>小明最近新开发项目，需求有支付功能，那如何避免从零开始，快速集成呢？现在给大家搜集了9个star数比较高的开源项目，能节省不少时间呢！</p>
</blockquote>
<h2 id="项目名称"><a href="#项目名称" class="headerlink" title="项目名称"></a>项目名称</h2><p>龙果支付系统 roncoo-pay</p>
<h3 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h3><p>龙果支付系统核心目标是汇聚所有主流支付渠道，打造一款轻量、便捷、易用，且集支付、资金对账、资金清结算于一体的支付系统，满足互联网业务系统的收款和业务资金管理需求。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li>具备支付系统通用的支付、对账、清算、资金账户管理、支付订单管理等功能;</li>
<li>目前已接通“支付宝即时到账”和“微信扫码支付”通道;</li>
<li>支持直连和间连两种支付模式，任君选择;</li>
<li>通过支付网关，业务系统可以轻松实现统一支付接入;</li>
<li>搭配运营后台，支付数据的监控和管理可以兼得;</li>
<li>配套完善的系统使用文档，可轻松嵌入任何需要支付的场景;<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3></li>
</ul>
<p><a class="link"   href="https://gitee.com/roncoocom/roncoo-pay" >https://gitee.com/roncoocom/roncoo-pay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称：聚合支付系统-XxPay"><a href="#项目名称：聚合支付系统-XxPay" class="headerlink" title="项目名称：聚合支付系统 XxPay"></a>项目名称：聚合支付系统 XxPay</h2><h3 id="项目简介-1"><a href="#项目简介-1" class="headerlink" title="项目简介"></a>项目简介</h3><p>XxPay 聚合支付使用 Java 开发，包括spring-cloud、dubbo、spring-boot三个架构版本，已接入微信、支付宝等主流支付渠道，可直接用于生产环境。目前已经接入支付渠道：微信(公众号支付、扫码支付、APP支付、H5支付)、支付宝(电脑网站支付、手机网站支付、APP支付、当面付)。</p>
<h3 id="项目地址-1"><a href="#项目地址-1" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/jmdhappy/xxpay-master" >https://gitee.com/jmdhappy/xxpay-master<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="项目名称-1"><a href="#项目名称-1" class="headerlink" title="项目名称"></a>项目名称</h3><p>常用支付接口 IJPay（目前小明使用的就是这个哦）</p>
<h3 id="项目简介-2"><a href="#项目简介-2" class="headerlink" title="项目简介"></a>项目简介</h3><p>IJPay 封装了微信支付、支付宝支付、银联支付常用的支付方式以及各种常用的接口。不依赖任何第三方 mvc 框架，仅仅作为 工具 使用简单快速完成支付模块的开发，可轻松嵌入到任何系统里。demo有springBoot版本的。</p>
<h3 id="项目地址-2"><a href="#项目地址-2" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/javen205/IJPay" >https://gitee.com/javen205/IJPay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-2"><a href="#项目名称-2" class="headerlink" title="项目名称"></a>项目名称</h2><p>基于 Java 的支付开发工具包</p>
<h3 id="项目简介-3"><a href="#项目简介-3" class="headerlink" title="项目简介"></a>项目简介</h3><p>优雅的轻量级支付模块，集成微信支付、支付宝、银联、友店、富友、跨境支付等。付与业务完全剥离，简单几行代码即可实现支付，简单快速完成支付模块的开发，可轻松嵌入到任何系统里。目前仅是一个开发工具包(即SDK)，只提供简单 Web 实现，建议使用 maven 或 gradle 引用本项目即可使用本 SDK 提供的各种支付相关的功能。</p>
<h3 id="项目地址-3"><a href="#项目地址-3" class="headerlink" title="项目地址"></a>项目地址</h3><p> <a class="link"   href="https://gitee.com/egzosn/pay-java-parent" >https://gitee.com/egzosn/pay-java-parent<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称：轻量级支付系统-Fastpay"><a href="#项目名称：轻量级支付系统-Fastpay" class="headerlink" title="项目名称：轻量级支付系统 Fastpay"></a>项目名称：轻量级支付系统 Fastpay</h2><h3 id="项目简介-4"><a href="#项目简介-4" class="headerlink" title="项目简介"></a>项目简介</h3><p>Fastpay 的目标是打造一款开源的、轻量级的、微服务化的、可共私有云部署的、可定制化的集成聚合支付和资金清结算于一体的统一支付系统，满足互联网企业业务系统的收款和资金处理等需求。在支付系统上实施微服务架构，使用最流行的Spring Cloud做服务化。</p>
<h3 id="项目特点"><a href="#项目特点" class="headerlink" title="项目特点"></a>项目特点</h3><ul>
<li><p>设计天生可伸缩的数据存储，直接使用分库分表。</p>
</li>
<li><p>使用缓存进行加速交易过程，提高用户体验。</p>
</li>
<li><p>将回调通知、入账等异步化，提高用户响应能力。</p>
</li>
<li><p>使用分布式定时任务系统将任务调度与交易隔离。</p>
</li>
<li><p>用当前最先进的单元化架构实现可水平伸缩。</p>
</li>
</ul>
<h3 id="项目地址-4"><a href="#项目地址-4" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/robertleepeak/fastpay" >https://gitee.com/robertleepeak/fastpay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-3"><a href="#项目名称-3" class="headerlink" title="项目名称"></a>项目名称</h2><p>支付 SDK 扩展包 easyPay</p>
<h3 id="项目简介-5"><a href="#项目简介-5" class="headerlink" title="项目简介"></a>项目简介</h3><p>本项目根据支付宝、微信最新 API 开发而成，高度抽象的类，免去各种拼 json 与 xml 的痛苦;符合 PSR 标准，你可以各种方便的与你的框架集成;文件结构清晰易理解，可以随心所欲添加本项目中没有的支付网关;方法使用更优雅，不必再去研究那些奇怪的的方法名或者类名是做啥用的。</p>
<h3 id="项目地址-5"><a href="#项目地址-5" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/yansongda/pay" >https://gitee.com/yansongda/pay<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="项目名称-4"><a href="#项目名称-4" class="headerlink" title="项目名称"></a>项目名称</h3><p>互联网金融支付系统 aaden-pay</p>
<h3 id="项目简介-6"><a href="#项目简介-6" class="headerlink" title="项目简介"></a>项目简介</h3><p>基于互联网金融理财环境下产生的支付系统，特点为：</p>
<ul>
<li><p>同卡进出，用户先实名绑定银行卡，后交易，不支持手机扫码交易。</p>
</li>
<li><p>提供统一的支付框架，只需少量代码就可快速接入新渠道，提供一个稳定的支付解决方法，节约 程序员 时间。</p>
</li>
</ul>
<h3 id="项目地址-6"><a href="#项目地址-6" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/aaden/aaden-pay" >https://gitee.com/aaden/aaden-pay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-5"><a href="#项目名称-5" class="headerlink" title="项目名称"></a>项目名称</h2><p>基于 PHP 的支付 SDK</p>
<h3 id="项目简介-7"><a href="#项目简介-7" class="headerlink" title="项目简介"></a>项目简介</h3><p>Payment 是一个 PHP 版本的支付聚合第三方 SDK，集成了微信支付、支付宝支付、招商一网通支付。提供统一的调用接口，方便快速接入各种支付、查询、退款、转账能力。</p>
<h3 id="项目地址-7"><a href="#项目地址-7" class="headerlink" title="项目地址"></a>项目地址</h3><p> <a class="link"   href="https://gitee.com/helei112g/payment" >https://gitee.com/helei112g/payment<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-6"><a href="#项目名称-6" class="headerlink" title="项目名称"></a>项目名称</h2><p>基于 .NET Core 的支付 SDK 集</p>
<h3 id="项目简介-8"><a href="#项目简介-8" class="headerlink" title="项目简介"></a>项目简介</h3><p>本项目是基于 .NET Core / ASP.NET Core 开发的跨平台支付 SDK 集，简化了 API 调用及相关通知的处理流程。</p>
<h3 id="项目特点-1"><a href="#项目特点-1" class="headerlink" title="项目特点"></a>项目特点</h3><p>目前支持：支付宝(Alipay)、微信支付(WeChatPay)、QQ钱包(QPay)、京东支付(JDPay)、连连支付(LianLianPay)、银联支付(UnionPay)。</p>
<h3 id="项目地址-8"><a href="#项目地址-8" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/Essensoft/Payment" >https://gitee.com/Essensoft/Payment<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium复用已打开浏览器</title>
    <url>/p/42390.html</url>
    <content><![CDATA[<p>复用浏览器，可以避免重新登录等环节。</p>
<span id="more"></span>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>chromedriver，可以看这篇文章<a href="https://mynamecoder.com/p/57219.html">安装chromedriver</a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2></li>
</ul>
<ol>
<li>将浏览器启动方式添加到环境变量。便于我们在终端任意位置启动浏览器<br>mac中Chrome浏览器目录通常为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/Google\ Chrome.app/Contents/MacOS</span><br></pre></td></tr></table></figure>
我们将其添加到环境变量当中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
追加<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/Applications/Google\ Chrome.app/Contents/MacOS:$PATH</span><br></pre></td></tr></table></figure>
用<code>env</code>命令可以查看是否添加成功，在终端中执行以下命名时配置生效：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>关闭所有chrome浏览器的进程后，终端中输入浏览器名称，可打开浏览器则配置成功</p>
<p>注意：<br>windows中浏览器名称为：chrome<br>mac中浏览器名称为：Google\ Chrome<br>2. 终端中使用命令行，打开浏览器debug模式</p>
<p>关闭所有chrome浏览器的进程后，终端输入debug命令：</p>
<p>命令格式：浏览器名称 <code>--remote-debugging-port=端口号</code><br>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows：chrome --remote-debugging-port=9222</span><br><span class="line">mac：Google\ Chrome --remote-debugging-port=9222</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在代码中添加options设置，复用已打开的浏览器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options = Options()</span><br><span class="line">options.debugger_address = &#x27;localhost:9222&#x27;</span><br><span class="line">driver = webdriver.Chrome(options=options)</span><br><span class="line"># 跳转到百度，试验是否复用成功</span><br><span class="line">driver.get(&#x27;https://www.baidu.com/&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年终总结</title>
    <url>/p/8569.html</url>
    <content><![CDATA[<p>没猜错的话，今天是2022年搬砖的第一天！</p>
<span id="more"></span>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>已是年终，各大小平台都在忙着给自己的用户推送一年来用户使用自己产品的痕迹，从产品的角度来讲，这是一种提升用户粘性的行为，通过用户主动分享一年的战果还可以达到产品裂变的目的。那，2021的你有写年终工作总结嘛？</p>
<h2 id="咖位增加了"><a href="#咖位增加了" class="headerlink" title="咖位增加了"></a>咖位增加了</h2><p>身高<strong>180+cm</strong>的我（对的，是这样），不知何时已经比去年多了10斤，我想很大原因是自己在家做饭吃饭的次数增加了，肯定不是要奔三的标志吧……不过，这一年在健身方面还是花费了不少，主要是来自两方面，一方面是花费了时间，一方面是花费了金钱。报了一个私教，基本上每周都会去一次，学会了游泳，又在家附近的体育馆办了一张游泳健身卡。还记得上完最后一节游泳课时，教练说：建议你在家附近办个游泳卡，勤加练习。她大抵是不想再看到我的泳姿了。2022年计划考一个深水证，据说这样就可以下沉到更深的领域了。</p>
<h2 id="升职了"><a href="#升职了" class="headerlink" title="升职了"></a>升职了</h2><p>但没加薪，我问领导，领导说：升职了，加薪还远吗？😊</p>
<h2 id="想成家了"><a href="#想成家了" class="headerlink" title="想成家了"></a>想成家了</h2><p>没有该结婚的年龄，只有该结婚的感情，身边结婚的朋友也越来越多了，真的没有任何来自家里的压力。</p>
<h2 id="游戏上线的次数减少了"><a href="#游戏上线的次数减少了" class="headerlink" title="游戏上线的次数减少了"></a>游戏上线的次数减少了</h2><p>身边一起玩游戏的小伙伴，大都不在了（都不玩的意思）。</p>
<h2 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h2><p>球打的比去年少了，吉他又吃灰了一年，为了读书特意换了最新款的kindle，连吃泡面都没有用上，希望2022能够有所改观（大家多督促我一下）。</p>
<h2 id="自媒体"><a href="#自媒体" class="headerlink" title="自媒体"></a>自媒体</h2><p>在这里给大家说一句抱歉，希望有用，因为2021年公众号原创也没怎么更新，但关注的人倒是增加了14%，我想2022年我努努力，还可以继续收获更多意趣相投的小伙伴。另外，今年小明可能会进军视频号乃至元宇宙，大家拭目以待！我也爱你们！</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>工作永远是为了更好的生活，而不是为了更好地工作，以后也会多和大家聊一些轻松的话题。2022愿望有点多，希望祖国繁荣昌盛，父母身体健康，生活幸福美满，事业蒸蒸日上！<br>最后，替新闻联播问你一句：你想用什么方式打开2022呢？</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>「规范」如何优雅地代码分层？</title>
    <url>/p/46081.html</url>
    <content><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a><strong>1、背景</strong></h2><p>说起应用分层，大部分人都会认为这个不是很简单嘛 就controller，service, mapper三层。看起来简单，很多人其实并没有把他们职责划分开，在很多代码中，controller做的逻辑比service还多,service往往当成透传了，这其实是很多人开发代码都没有注意到的地方，反正功能也能用，至于放哪无所谓呗。这样往往造成后面代码无法复用，层级关系混乱，对后续代码的维护非常麻烦。</p>
<span id="more"></span>
<p>的确在这些人眼中分层只是一个形式，前辈们的代码这么写的，其他项目代码这么写的，那么我也这么跟着写。</p>
<p>但是在真正的团队开发中每个人的习惯都不同，写出来的代码必然带着自己的标签，有的人习惯controller写大量的业务逻辑，有的人习惯在service中之间调用远程服务，这样就导致了每个人的开发代码风格完全不同，后续其他人修改的时候，一看，我靠这个人写的代码和我平常的习惯完全不同，修改的时候到底是按着自己以前的习惯改，还是跟着前辈们走，这又是个艰难的选择，选择一旦有偏差，你的后辈又维护你的代码的时候，恐怕就要骂人了。</p>
<p>所以一个好的应用分层需要具备以下几点:</p>
<ul>
<li>方便后续代码进行维护扩展；</li>
<li>分层的效果需要让整个团队都接受；</li>
<li>各个层职责边界清晰。</li>
</ul>
<h2 id="2、应用分层模型"><a href="#2、应用分层模型" class="headerlink" title="2、应用分层模型"></a>2、应用分层模型</h2><p>在项目开发中，一个良好的工程架构是必须的。工程架构就像一个骨架，写代码就是在这个骨架上增添血肉，这个骨架会影响到整体的模块划分，功能划分，即会影响到代码的解耦和聚合，将会很大程度上决定一个项目写得好不好。</p>
<p>这里要分享的是我个人在开发时所采取的工程架构，以及相关的思想。不同的人对于工程架构的理解会不同，实际上也很难分出哪种好，哪种坏，只要符合自己的设计思想，并且能够有效的进行开发，那就是好的一种架构方式。</p>
<h3 id="2-1、分层"><a href="#2-1、分层" class="headerlink" title="2.1、分层"></a>2.1、分层</h3><p>我整体上的思想为《阿里巴巴 Java 开发手册》中所描述的分层模型。如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200411234541.png"
                     
                >应用分层图</p>
<blockquote>
<p>在这里插一嘴哈，在这里我使用的流程图工具是<strong>ProcessOn</strong>，是一款在线画图工具，非常适合画各种示意图，体验极佳，如果大家想尝试一下，可以使用我的<a class="link"   href="https://www.processon.com/i/5a967fdce4b01965e7301910" >邀请链接<i class="fas fa-external-link-alt"></i></a>注册使用～</p>
</blockquote>
<p>接下来将自底向上的讲解我对各层的理解和设计，还有我自己所增加的层。</p>
<h3 id="2-2、通用工具层"><a href="#2-2、通用工具层" class="headerlink" title="2.2、通用工具层"></a>2.2、通用工具层</h3><p>通用工具层其实为对业务无关的，通用的工具类，例如日期处理的工作累，一些数据格式的序列化与反序列化工具。类似于 apache commons 包和 guava 包。</p>
<h3 id="2-3、分层领域模型"><a href="#2-3、分层领域模型" class="headerlink" title="2.3、分层领域模型"></a>2.3、分层领域模型</h3><p>领域模型，也就是我们之前常见的各种数据实体，用 DDD 的术语来说，这种在分层模型中的领域模型称为贫血领域模型。<br>贫血领域模型只作为数据载体，只有 getter/setter 方法，而不包含业务方法。</p>
<p>对于分层领域模型，会进一步进行划分规约，主要也是参考自《阿里巴巴 Java 开发手册》具体如下：</p>
<ul>
<li><strong>DO(Data Object)</strong> : 数据对象，对数据源数据的映射，如数据库表，ElasticSearch 索引的数据结构。所在包一般命名为 data 。</li>
<li><strong>DTO(Data Transfer Object)</strong> : 数据传输对象，业务层向外传输的对象。如果在某个业务中需要多次查询获取不同的数据对象，最后将会把这多个数据对象组合成一个 DTO 并对外传输。所在包命名为 dto 。</li>
<li><strong>BO(Business Object)</strong> : 业务对象，由 Service 层输出的封装业务逻辑的对象。即对象除了数据外，还会包含一定的业务逻辑，也可以说是充血领域模型。但是我一般不会使用。</li>
<li><strong>AO(Application Object)</strong> : 应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。比较少用。</li>
<li><strong>VO(View Object)</strong> : 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。现在的项目多数为前后端分离，后端只需要返回 JSON ，那么可以理解为 JSON 即是需要渲染成的“模板”。我一般会将这类对象命名为 xxxResponse ，所在包命名为 response 。</li>
<li><strong>Query</strong> : 数据查询对象，数据查询对象，各层接收上层的查询请求。其实一般用于 Controller 接受传过来的参数，可以将其都命名为 xxxQuery ，而我个人习惯将放在 request body 的参数（即 @RequestBody）包装为 xxxRequest ，而如果使用表单传输过来的参数（即 @RequestParam）包装为 xxxForm ，并分别放在包 request 和包 form 下。</li>
</ul>
<p>其实贫血领域模型只是作为数据的载体，在一开始我觉得没必要进行具体的分类，基本上都是往一个包内丢，但是当项目规模上来后，各种各样的数据实体开始增加，慢慢的变得混乱。对数据对象的分类是为了更好的定义每个数据的作用以及在后续能够快速的定位到对应的数据对象。</p>
<h3 id="2-4、Helper"><a href="#2-4、Helper" class="headerlink" title="2.4、Helper"></a>2.4、Helper</h3><p>开发中会遇到一些很基础的，通用的业务逻辑，例如我们可能会根据每个用户的信息生成一个唯一的 account id 。又或者说有一个用户排名的需求，我们将从用户的相关信息中计算出一个分数，从而根据这个分数进行排名。那么这时候我们可能会将这些逻辑写在 User 数据对象或是其他相应对应的数据对象下。<br>而我个人来说，不希望数据对象包含业务逻辑，所以我会将这些通用的业务逻辑都抽出来，放到 Manager 中进行统一管理。如会将生成 account id 的逻辑放在 AccountIdGenerator 中，将计算排名分数的逻辑放在 RankCalculator 中。<br>我将这些类都归为 Helper ，用于提供底层的业务计算逻辑。而为什么不放在通用工具层中呢？因为这些 Helper 其实都是依赖于特定的领域，即特定的业务。而通用工具类则是业务无关的，任何系统，只要有需要都可以引用。</p>
<h3 id="2-5、DAO"><a href="#2-5、DAO" class="headerlink" title="2.5、DAO"></a>2.5、DAO</h3><p>DAO 就不用过多解释了，数据访问对象，用于对数据库的访问。但是我个人不会将 DAO 只局限于数据库，对于不同的数据源的交互，如 HBase ，ElasticSearch ，本地缓存甚至 Redis 我都会定义相对应的 DAO 进行访问。<br>这样的定义，其实是想将数据 CURD 的逻辑和业务逻辑进行分离，将获 CRUD 封装在 DAO 中，业务逻辑即放在业务层中。</p>
<p>之前接手了一个项目，项目将 Redis 视为中间件，将相关的逻辑都封装在 xxxRedisService 中，包括 CRUD 和一些业务逻辑。随着项目的发展，一些其实可以归类到一起的业务，变得有些放在了 RedisService 中，一些放在了业务层的 Service 中，可想而知十分混乱，还导致了一些 BUG 的出现。</p>
<h3 id="2-6、Service-和-Manager"><a href="#2-6、Service-和-Manager" class="headerlink" title="2.6、Service 和 Manager"></a>2.6、Service 和 Manager</h3><p>Service 的作用不用多说明，为具体业务逻辑的封装层。</p>
<p>具体要说明的是 Manager ，《阿里巴巴 Java 开发手册》中定义如下:</p>
<ol>
<li>对第三方平台封装的层，预处理返回结果及转化异常信息</li>
<li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理</li>
<li>与 DAO 层交互，对多个 DAO 的组合复用</li>
</ol>
<p>可以将 Manager 理解为对通用逻辑的封装，避免 Service 与 Service 进行相互调用，以及对通用逻辑的管理。</p>
<p>在开发中，我们经常会遇到 AService 中的某个业务可以提供给 BService 调用，从而让 BService 调用 AService 的方法，认为是 Service 之间具有共同的业务。其实 Service 之间没有共同的业务，而是<strong>具备通用的逻辑</strong>，这时应该将其抽离出来放在 Manager 中。无论何种工程架构都好，我都不赞同 Service 与 Service 之间的相互调用。</p>
<p>在实际开发中，我会对 Manager 进行更细一点的划分。大致将其分为用于项务类，所封装的是由 Service 下沉的通用业务。<br>而另一种则是一些偏向于工具、计算的类，例如某个业务使用了策略模式，所编写的策略类则属于这一类。<br>我会将业务类的用 @Service 注释，而偏工具类的则用 @Component 注释。这样做的原因还是避免业务之间的相互调用，相互耦合。</p>
<p>这里可能会想，为什么不将 Helper 的逻辑也放在 Manager 层中？原因在于 Helper 的逻辑比 Manager 更加基础，有可能在 DAO 中都会调用 Helper 的相关逻辑，如果放在 Manager 中，就会出现底层依赖上层的问题。</p>
<h3 id="2-7、接口层"><a href="#2-7、接口层" class="headerlink" title="2.7、接口层"></a>2.7、接口层</h3><p>最后的一层，则是暴露给外部调用的层。可以是 Spring 体系中的 Controller ，也可以是 gRPC 。<br>这一层将组织、调用我们所定义的 Service ，进行业务处理。</p>
<h2 id="3、分层模型的优点以及缺点"><a href="#3、分层模型的优点以及缺点" class="headerlink" title="3、分层模型的优点以及缺点"></a>3、分层模型的优点以及缺点</h2><p>无论什么工程架构，都会有其优点以及缺点，在选择工程架构时，其实就是对优点缺点的衡量。</p>
<h3 id="3-1、优点"><a href="#3-1、优点" class="headerlink" title="3.1、优点"></a>3.1、优点</h3><p>其实无论什么架构，特别是对业务工程来说，最希望架构带来的是解耦以及内聚。<br>通过分层，在一定程度上对项目内的各个模块进行了解耦内聚，依赖关系十分明确，再怎么写，只要符合规约，总是上层依赖于下层。而且分层的规约十分简单，在多人协作的情况下大部分情况都可以很好的遵守规约。</p>
<h3 id="3-2、缺点"><a href="#3-2、缺点" class="headerlink" title="3.2、缺点"></a>3.2、缺点</h3><p>简单是一个优点，也是一个缺点。分层虽然在一定程度上进行了解耦，但是粒度十分粗，只要不出现下层依赖上层的情况，都可以认为是符合规约的，在这种情况下，很容易导致代码的分散、功能的碎片化，明明是同一类业务功能的代码，却分散在多个类，多个层次之间。在项目不断迭代时变得巨大时，慢慢就会变得混乱，然后就是一轮重构。<br>归根到底就是太松懈了，导致开发人员很容易就是在项目中随便找个地方写，还很容易导致由大量的复制粘贴所产生重复代码。</p>
<p>在学校开设的软件工程课中，设计一个系统，首先是组织架构的了解，然后从中抽出数据流，然后再在数据流中抽出业务流，进行根据业务流进行开发。而采用分层模型的化，往往在数据流中就可以开始开发，采用分层模型的话，每个业务其实可以简单的抽象成数据在各层之间的流动。<br>这可以说是一个优点，简化了业务的理解，实现快速的开发，我在比较紧的排期下也由这么做过，扫一眼业务，构思好数据流的流动后就动手了。但这也是一个很严重的缺点，我见过不少功能性 BUG ，就是由于对业务的不充分理解所导致的，而且由于没有对业务流程充分理解后就开发，后续的扩展和修复，看起来就是不断的修修补补。</p>
<p>上面，我除了《阿里巴巴 Java 开发手册》所写的内容外，还添加了不少细节，其实所想要做的就是尽量减少这种功能碎片化的问题。</p>
<h2 id="4、与充血领域模型的对比"><a href="#4、与充血领域模型的对比" class="headerlink" title="4、与充血领域模型的对比"></a>4、与充血领域模型的对比</h2><p>既然是说工程架构，就不得不提 DDD 这一个概念。</p>
<p>为什么我说的是“与充血领域模型的对比”而不是“与 DDD 的对比”呢？是因为 DDD 是比分层模型更加高层的一种概念，它是一个产品服务，整个团队开发的一种指导思想，而不是一种工程代码上的规约。</p>
<p>DDD 可以分为两大方向，一个是战略层面上的，即之前提到的是一种开发的指导思想，定义、划分服务的领域，规定统一语言提高沟通效率等，这也是可以用于使用分层领域模型的项目开发中的。如果要与分层模型对比的话，其实是 DDD 的战术层面，即充血领域模型。</p>
<p>充血领域模型其实是回归于面向对象的思想。在目前的分层模型中，哪怕是用 Java 这种面向对象的语言去写，其实总体上还是一种过程式的编程，在 DDD 中称为事务脚本。</p>
<p>充血领域模型是重领域，轻 Service 的。以之前生成 account id 以及排名的例子，在充血领域模型中，User 类将会有 generateAccountId 方法和 ranking 方法来完成这一逻辑。<br>完全的面向对象，就可以充分的发挥面向对象的特性。面向对象的特性在书上为：<em>继承、多态，封装</em>。前两者能够实现归一化，使模块泛化通用，封装即会使模块划分明确，能够很好的实现解耦和内聚。比起分层模型，使用充血领域模型可以很好的解决上面提到的代码分散，碎片化的问题。</p>
<p>充血领域模型的优点是面向对象的优点，但是面向对象的缺点也成为这种模型的缺点。首先，万物皆可抽象在我看来就是伪命题，因为现实世界中总有事务是难以进行抽象的，或者抽象起来不优雅，总是有一种硬是抽象的感觉。<br>在知乎中有一个很好的回答，描述了面向对象的弊端</p>
<p>相信很多人在初接触 DDD 时，都会去搜索充血领域模型实践的例子。其实在学校学习 Java Web 开发时，书本中写道的 MVC 结构其实在一定程度上也是充血领域模型，Model 除了是数据的载体外，还包含业务逻辑，通过 Controller 对 Model 的选择以及调用完成业务。假如用这种结构开发，当项目庞大后，我觉得首先遇到的问题应该就是依赖问题，复杂的业务必然牵扯到各方各面，自然也就有复杂的依赖关系产生，甚至会有为了完成业务而产生很“脏”的实现，这是难以避免的。</p>
<p>我个人觉得充血领域模型目前还是只适合于个人，很小的团队中使用，例如 2 到 3 个人的团队，因为抽象本身就是一个非常复杂的过程，随着需求迭代，之前的抽象还不一定正确，如果在较为多人的多人协作中，各种奇奇怪怪的写法都会出现，必然也会有随便找个“地”写的情况出现，这种情况比在分层模型中更为致命。</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>还是那句话，工程架构无分好坏，只有适合与不适合，问题的来与在于业务的复杂，计算机始终在某些方面难以映射到现实世界。所以我个人建议好好的理解好自己目前所用到的工程架构，尽量做到扬长避短。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>两种开发模式的区别和思考</title>
    <url>/p/12597.html</url>
    <content><![CDATA[<p>💻 你使用的是哪个模式</p>
<span id="more"></span>
<h2 id="瀑布开发模式"><a href="#瀑布开发模式" class="headerlink" title="瀑布开发模式"></a>瀑布开发模式</h2><h3 id="显著的特点"><a href="#显著的特点" class="headerlink" title="显著的特点"></a>显著的特点</h3><p>1.严格把软件项目的开发分隔成各个开发阶段：需求分析，要件定义，基本设计，详细设计，编码，单体测试，结合测试，系统测试等。<br>使用里程碑的方式，严格定义了各开发阶段的输入和输出。如果达不到要求的输出，下一阶段的工作就不展开。</p>
<p>2.重视和强调过程文档，在开发的中后期才会看到软件原型，早起只能通过文档来了解系统的模样。<br>在这种情况下，文档的重要性仿佛已经超过了代码的重要性。</p>
<p>3.瀑布模型把每个开发阶段都定义为黑盒，希望每个阶段的人员只关心自己阶段的工作，不需要关注其他阶段的工作。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>可以让开发人员能够更专注于本职工作，提高阶段效率。</p>
<h3 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h3><p>a.由于各阶段的开发人员只能接触到自己工作范围内的东西，所以对客户需求的理解程度高低不等，开发人员更像是定义为流水线上的工人。<br>b.对于客户需求变更，编码人员会比设计人员更容易产生很强的抵触情绪。<br>c.在每个开发阶段都会有一些信息刻意的不让其他开发阶段的人员知道（本意是为了提到效率，但实际上有时候产生的是互相的理解偏差）。</p>
<p>4.瀑布模型产生的管理文档(计划书，进度表)等，能让不太了解该项目的人也能看懂项目的进度情况（只有能看懂百分比就行），很适合向领导汇报用。所以管理人员比较喜欢瀑布模型，但是开发人员不喜欢，因为它束缚了开发人员的创造性。</p>
<p>5.既然叫做瀑布，就意味着不应该走回头路。否则如果出现返工，付出的代价会很大。软件生命周期前期造成的Bug的影响比后期的大的多。代价比较大的主要原因还是每个开发阶段的步子过大，每一次调整都可能伤筋动骨。</p>
<p>6.更适合需求相对稳定的大型项目。</p>
<h2 id="敏捷开发模式"><a href="#敏捷开发模式" class="headerlink" title="敏捷开发模式"></a>敏捷开发模式</h2><p>核心是快速迭代，拥抱变化。因为最终目标是让客户满意，所以能够主动接受需求变更，这就使设计出来的软件有灵活性，可扩展性。</p>
<blockquote>
<p>宣言：个体和交互胜过过程和工具，可以工作的软件胜过面面俱到的文档，客户合作胜过合同谈判，响应变化胜过遵循计划</p>
</blockquote>
<p>敏捷开发模式有以下显著的特点：</p>
<p>1.story细化。<br>2.简单设计，避免过度设计。<br>3.重复迭代。<br>4.减少不必要的文档。<br>5.客户最关心的功能最先完成。<br>6.要求客户有时间对每次迭代的成果进行确认，提出改进意见。<br>7.showcase。<br>8.沟通是非常重要的，所有的开发人员对项目活动的理解应该是一致的。加强团队之间和客户之间的沟通。<br>9.测试驱动开发（TDD）<br>10.需要更强的个人和团队能力。<br>11.敏捷的管理是团队的自我管理和项目经理的服务式管理。<br>12.敏捷开发不能在一开始就给出项目完整的成本计划。<br>13.在有技术问题还没有解决的情况下不适合展开迭代。<br>14.敏捷实践：晨会，deadline，负责人制等等。</p>
<h2 id="瀑布-敏捷开发模式："><a href="#瀑布-敏捷开发模式：" class="headerlink" title="瀑布+敏捷开发模式："></a>瀑布+敏捷开发模式：</h2><p>核心是减小瀑布模型的粒度，采用敏捷开发的优秀实践方式，提高开发的沟通效率，提供项目的全景视图。</p>
<p>敏捷开发，首先把客户最关注的软件原型先做出来，交付或者上线，在实际场景中去修改弥补需求中的不足，快速修改，再次发布版本。再次上线或者交付。通过一些敏捷实践方式，细化story，可以提供更小的迭代。如此循环，直到用户（客户）满意。适用于需求不明确的项目、创新性的项目或者需要抢占市场的项目。</p>
<p>瀑布式开发，要求明确的需求，大家按照需求一步步做好规划，在项目运作过程中严格产出各种文档，按着流程一步步走下去。这种模式一般适用于需求比较明确、to B端项目</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>但总的来说，在现在管理项目过程中，并没有严格的按照完全的敏捷或者完全的瀑布模式，都是各自掺杂了其他的方式。在实际项目过程中，过于强调模式并没有意义，重要的是能不能预防问题的发生，在问题发生之后能不能用最小的成本解决，模式更多起一个参考作用</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>面试</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>「实用」使用阿里云的镜像仓库存储自己的镜像</title>
    <url>/p/2702.html</url>
    <content><![CDATA[<p>一个免费版的镜像仓库值得你拥有。</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近有在搭建自己喜欢的小玩意，而且为了方便维护迁移，因此需要一个好的平台托管，知名的是DockerHub，但是今天，咱们眼光放在国内——我使用的阿里云容器Hub。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>其实阿里云的官方文档说的很清楚了，我在这里给大家做一些介绍和总结。</p>
<p>阿里云这个仓库，个人版是完全免费的，但是有一定的数量限制，如下图所示，但是目前来看，是完全能够满足我们开发者自身需求。当然如果你有更大的需求，可以升级为企业版。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211217104347.png"
                      alt="仓库概览"
                ><br>我们在配置仓库、命名空间后就可以正常使用啦。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>登录阿里云Docker Registry</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=[你的名字] registry.cn-shanghai.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>
<p>您可以在访问凭证页面修改凭证密码。</p>
<ol start="2">
<li>从Registry中拉取镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker pull registry.cn-shanghai.aliyuncs.com/[命名空间]/[仓库名称]:[镜像版本号]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将镜像推送到Registry</li>
</ol>
<p>将现有的容器创建一个新镜像，首先还是登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker login --username=[你的名字] registry.cn-shanghai.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>然后将现有容器提交为一个新的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker commit [containerId] [镜像名:镜像版本号]</span><br></pre></td></tr></table></figure>

<p>查看镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>

<p>可以看到镜像已经制作成功，为了上传至远程仓库，我们给该镜像打一个tag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/[命名空间]/[仓库名称]:[镜像版本号]</span><br></pre></td></tr></table></figure>
<p>推送到远端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker push registry.cn-shanghai.aliyuncs.com/[命名空间]/[仓库名称]:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<ol start="4">
<li>选择合适的镜像仓库地址</li>
</ol>
<p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p>
<p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-shanghai.aliyuncs.com 作为Registry的域名登录。<strong>注意</strong>：登录的时候就需要使用这个域名，不然，push的时候会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">denied: requested access to the resource is denied</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>示例<br>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">registry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB</span><br><span class="line">$ docker tag 37bb9c63c8b2 registry-vpc.cn-shanghai.aliyuncs.com/acs/agent:0.7-dfb6816</span><br></pre></td></tr></table></figure>

<p>使用 “docker push” 命令将该镜像推送至远程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker push registry-vpc.cn-shanghai.aliyuncs.com/acs/agent:0.7-dfb6816</span><br></pre></td></tr></table></figure>

<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>阿里云服务作为业内首选，目前有大量活动值得参与，作为推广大使，<a class="link"   href="https://www.aliyun.com/minisite/goods?userCode=1qsydng8" >点我<i class="fas fa-external-link-alt"></i></a>享受优惠！<br>当然更多优惠还得关注微信公众号：程序员小明！！！<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于谷歌浏览器占用的端口号</title>
    <url>/p/5676.html</url>
    <content><![CDATA[<p>🌎 今天用chrome打开页面的发现一个错误:<br>ERR_UNSAFE_PORT<br>字面意思是error:不安全端口。</p>
<span id="more"></span>
<p>一、什么是默认非安全端口?<br>   每个浏览器出于安全问题,都会禁止一些网络浏览以外的端口。因为不清楚这个机制,我用node开启的6000服务根本无法访问,调试了半天代码,用别的浏览器发现打开了！深究得知浏览器禁用端口这一说。<br>二、浏览器默认限制端口有哪些?<br>Chrome谷歌浏览器:6000、6665-6669…（详细末尾贴上）<br>FireFox火狐浏览器:非80端口<br>三、解决办法?</p>
<ol>
<li><p>更换服务启动端口:<br>推荐使用这种，免去了配置的麻烦。</p>
</li>
<li><p>Chrome:<br>右键单击Chrome快捷方式 ➡ 目标 ➡ 在后面添加参数：–explicitly-allowed-ports=xxx （xxx为目标端口号）</p>
</li>
</ol>
<p>例如：…\chrome.exe –explicitly-allowed-ports=6666</p>
<ol start="3">
<li>Firefox:<br>打开新标签页，地址栏输入about:config打开浏览器配置页面，搜索首选项network.security.ports.banned.override，如果没有则添加（首选项类型为字符串），将其值设为6666。再次尝试访问受限站点成功。<br>如果需要设置多个端口，则把首选项值设为6666,6667的格式即可。</li>
</ol>
<p>四、附:Chrome默认非安全端口<br>设置端口的时候应该尽量避免这些端口,如果逼不得已需要使用这些端口调试再去配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, // tcpmux </span><br><span class="line">7, // echo </span><br><span class="line">9, // discard </span><br><span class="line">11, // systat </span><br><span class="line">13, // daytime </span><br><span class="line">15, // netstat </span><br><span class="line">17, // qotd </span><br><span class="line">19, // chargen </span><br><span class="line">20, // ftp data </span><br><span class="line">21, // ftp access </span><br><span class="line">22, // ssh </span><br><span class="line">23, // telnet </span><br><span class="line">25, // smtp </span><br><span class="line">37, // time </span><br><span class="line">42, // name </span><br><span class="line">43, // nicname </span><br><span class="line">53, // domain </span><br><span class="line">77, // priv-rjs </span><br><span class="line">79, // finger </span><br><span class="line">87, // ttylink </span><br><span class="line">95, // supdup </span><br><span class="line">101, // hostriame </span><br><span class="line">102, // iso-tsap </span><br><span class="line">103, // gppitnp </span><br><span class="line">104, // acr-nema </span><br><span class="line">109, // pop2 </span><br><span class="line">110, // pop3 </span><br><span class="line">111, // sunrpc </span><br><span class="line">113, // auth </span><br><span class="line">115, // sftp </span><br><span class="line">117, // uucp-path </span><br><span class="line">119, // nntp </span><br><span class="line">123, // NTP </span><br><span class="line">135, // loc-srv /epmap </span><br><span class="line">139, // netbios </span><br><span class="line">143, // imap2 </span><br><span class="line">179, // BGP </span><br><span class="line">389, // ldap </span><br><span class="line">465, // smtp+ssl </span><br><span class="line">512, // print / exec </span><br><span class="line">513, // login </span><br><span class="line">514, // shell </span><br><span class="line">515, // printer </span><br><span class="line">526, // tempo </span><br><span class="line">530, // courier </span><br><span class="line">531, // chat </span><br><span class="line">532, // netnews </span><br><span class="line">540, // uucp </span><br><span class="line">556, // remotefs </span><br><span class="line">563, // nntp+ssl </span><br><span class="line">587, // stmp? </span><br><span class="line">601, // ?? </span><br><span class="line">636, // ldap+ssl </span><br><span class="line">993, // ldap+ssl </span><br><span class="line">995, // pop3+ssl </span><br><span class="line">2049, // nfs </span><br><span class="line">3659, // apple-sasl / PasswordServer </span><br><span class="line">4045, // lockd </span><br><span class="line">6000, // X11 </span><br><span class="line">6665, // Alternate IRC [Apple addition] </span><br><span class="line">6666, // Alternate IRC [Apple addition] </span><br><span class="line">6667, // Standard IRC [Apple addition] </span><br><span class="line">6668, // Alternate IRC [Apple addition] </span><br><span class="line">6669, // Alternate IRC [Apple addition]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>日常开发</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表中间件</title>
    <url>/p/54119.html</url>
    <content><![CDATA[<p>📊 更加灵活的分表分库</p>
<span id="more"></span>
<h2 id="MyCAT"><a href="#MyCAT" class="headerlink" title="MyCAT"></a>MyCAT</h2><p>MyCAT是一个<strong>Java语言编写</strong>的开源分布式数据库系统，是基于MySQL协议的服务端程序，具有高性能、高可扩展性、易用性和丰富的功能特性。MyCAT主要解决了大型Web应用或互联网应用架构中数据库性能不足、并发性能差、容灾性能差等问题。MyCAT支持数据读写分离、无缝支持MySQL协议、支持分表分库、集群管理以及自动化运维等多种功能，并且可以兼容各种ORM框架（如Hibernate、MyBatis等）。</p>
<p>MyCAT的优点有：</p>
<ul>
<li>数据库读写分离；</li>
<li>横向扩展分片能力，实现分布式部署；</li>
<li>支持SQL语句转化，减轻SQL重构压力；</li>
<li>具备完整的切换透明度的集群管理体系；</li>
<li>支持多协议(mysql/oracle)；</li>
<li>免费开源，降低企业运维成本。</li>
</ul>
<p>MyCAT的应用场景主要包括互联网大型Web应用、移动互联网应用、金融领域、物流配送、政务信息系统等需要高并发、高可靠性、高性能等的数据应用系统。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MyCAT</tag>
        <tag>Sharding-JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>动态控制多层for循环嵌套</title>
    <url>/p/5bd3.html</url>
    <content><![CDATA[<blockquote>
<p><a class="link"   href="https://blog.csdn.net/fukaiit/article/details/82730537" >参考链接<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>有些场景我们解多元一次方程时，如果方程组不够，就需要通过枚举求解，比如<code>2x+3y+4z=10</code>,需要3层for循环求解，但如果元数未知，枚举时则需要动态控制for循环的深度，我们可以通过递归解决这个问题，大概思路如下</p>
<ul>
<li>首先通过二维数组枚举所有可能的值</li>
<li>递归遍历二维数组控制for循环的层数</li>
<li>递归到最后一层时判断控制是否满足方程的条件，打印输出<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1>根据红包的总额，红包的总份数及每个红包的金额种类，得到每个红包金额对应的份数<h1 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h1>github: <a class="link"   href="https://github.com/WhenCoding/calcRedPackage" >https://github.com/WhenCoding/calcRedPackage<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>『原神』电脑壁纸4K高清无水印</title>
    <url>/p/59172.html</url>
    <content><![CDATA[<p>📷 想给网页整个大气的背景图，找到几张原神的壁纸，感觉还不错，喜欢❤️就拿走吧~</p>
<span id="more"></span>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-2.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-3.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-4.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-5.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-6.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-7.jpeg"
                     
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-9.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-10.jpeg"
                     
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-12.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-13.jpeg"
                     
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="/images/bg-14.jpeg"
                     
                ></p>
<h2 id="更多壁纸"><a href="#更多壁纸" class="headerlink" title="更多壁纸"></a>更多壁纸</h2><p>关注微信公众号“程序员小明”，回复“原神”获取<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/WechatIMG48.jpeg"
                      alt="公众号"
                ></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>自己感觉好用的工具列表</title>
    <url>/p/30756.html</url>
    <content><![CDATA[<p>🔧 一句老话，工欲善其事，必先利其器</p>
<span id="more"></span>

<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>推荐使用开源的draw.io</p>
<h2 id="Visual-Code-Studio"><a href="#Visual-Code-Studio" class="headerlink" title="Visual Code Studio"></a>Visual Code Studio</h2><p>作为一个优秀的、免费的、跨平台代码编辑器，在实际使用过程中给我的感觉是轻快简洁（idea真的是太重了），尤其是对于一些性能受限的设备来说实在是太友好了，我已经准备转战使用它了，我内存8G的mac又能战斗好几年了。<br>作为一个Java开发者，平时需要用到很多数据库管理工具，强烈推荐安装这个插件，省去其他软件，给电脑来个瘦身吧！</p>
<h3 id="插件安装的位置"><a href="#插件安装的位置" class="headerlink" title="插件安装的位置"></a>插件安装的位置</h3><p>Mac下vscode插件存放位置：<code>/Users/（你的用户名）/.vscode/extensions</code></p>
<h3 id="Database-Client"><a href="#Database-Client" class="headerlink" title="Database Client"></a>Database Client</h3><p>支持MySQL/MariaDB, PostgreSQL, SQLite, Redis and ElasticSearch.<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230715225055.png"
                      
                ><br>最喜欢的是随便打开一个sql文件，都可以识别执行，这解决了我一直无法集中管理sql语句的痛点，建议大家快去体验一下吧！<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230719144244.png"
                      
                ></p>
<blockquote>
<p>tips:这个插件超过三个数据库链接需要付费，一年￥68（该项目之前是开源的），现在可以支持作者也可以选择<strong>找我</strong>，暗号：vscode database client</p>
</blockquote>
<h3 id="其他好用的插件也可以安装"><a href="#其他好用的插件也可以安装" class="headerlink" title="其他好用的插件也可以安装"></a>其他好用的插件也可以安装</h3><p>比如Python开发、Java开发等等，直接根据关键词在插件中心搜索，下载量最高的，官方推荐的用起来就很香！</p>
<h2 id="清理工具"><a href="#清理工具" class="headerlink" title="清理工具"></a>清理工具</h2><p>App Cleaner Uninstaller</p>
<blockquote>
<p>一个Mac下优秀的卸载工具<br>支持正版，学习交流可以<a class="link"   href="https://taoyezi.lanzoub.com/appcleanH3" >点击<i class="fas fa-external-link-alt"></i></a>获取。</p>
</blockquote>
<h2 id="解压和压缩"><a href="#解压和压缩" class="headerlink" title="解压和压缩"></a>解压和压缩</h2><p><a class="link"   href="https://maczip.cn/?locale=zh-CN" >MacZip<i class="fas fa-external-link-alt"></i></a><br>MacZip在使用上类似于WinRAR。您可以直接打开压缩文件查看预览并编辑其中的文件。可以解压部分或全部内容，删除部分内容或者一键删除清理DS_Store 和Thumbs.db等系统生成的缓存文件。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230424111638.png"
                     
                ></p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>工具</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Freemarker生成Word文件</title>
    <url>/p/8425.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一天，产品经理递给我了一份word报告，我定睛一看</p>
<p>这个文档有大大小小的标题层级，还有排版好的段落、各种一目了然的饼图、走势图，当然还少不了颜色循环交替的报表。精致程度不亚于小明同学的学习报告。</p>
<span id="more"></span>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/webp.png"
                     
                ></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>鲁迅：身为一名Java程序员，任何时候都不要忘记站在巨人的肩膀上。</p>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200907151347.png"
                     
                ><br>通过某歌搜索关键词：<strong>java+word+导出</strong>，我立马得出了很多成熟的方案，通过横向、纵向比较，再结合本次报告样式比较多、用户可灵活选择不同模块导出的特点，最终，我决定使用<strong>Freemarker</strong> 动态替换模版数据来导出word文档。至于导出文档的最终格式，有两种选择：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200903160210.png"
                     
                ></p>
<p>那到底使用<strong>doc</strong>还是<strong>docx</strong>格式的文档？<br>每当人生当中每次面临选择我都很慎重。最终我选择使用<strong>docx</strong>格式（原因文末会讲），但是为了让大家有更多的选择，满足更多的业务场景，借此机会，小明会给大家分别介绍使用<strong>freemarker</strong>导出两种格式的word文档方式。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p> FreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构生成动态网页。但是，它是一个通用的模板引擎，不依赖于servlets或HTTP或HTML，因此它通常还用于生成源代码，配置文件或电子邮件。</p>
</blockquote>
<p>此时，我们用它动态生成xml文件，进而导出word文档。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200903154144.png"
                     
                ><br>整体流程如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200903152139.png"
                     
                ></p>
<h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><ul>
<li>WPS<blockquote>
<p> 由金山软件股份有限公司发布，用于办公软件最常用的文字编辑、表格、演示稿等功能。</p>
</blockquote>
</li>
</ul>
<p>对，就是这个国产的办公软件。我也是第一次发现在导出文档这件事上，它如多年好友般友好。（word解析后的xml文件阅读性很强，一般人我不告诉他）</p>
<ul>
<li>开发工具（IDEA、Visual Studio Code等）<br>你喜欢的，顺手的，就是最好的。<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="集成Freemarker模版引擎"><a href="#集成Freemarker模版引擎" class="headerlink" title="集成Freemarker模版引擎"></a>集成Freemarker模版引擎</h3>本次项目使用的框架依旧是Springboot，这个框架在集成各个组件表现都很便捷，不再赘述，这次集成Freemarker也不例外。</li>
<li>首先我们在项目中增添依赖<code>spring-boot-starter-freemarker</code><br>pom.xml文件如下所示：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>按照默认约定，我们可以在resources下创建一个templates文件夹（查看FreeMarkerProperties源码可以发现默认目录就是这个），用于存放模版文档。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200903164916.png"
                     
                ></li>
<li>application.yml增加配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">template-loader-path:</span> <span class="string">classpath:/templates</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment"># 开发环境缓存关闭</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">xml</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>
<h3 id="生成doc格式的文档"><a href="#生成doc格式的文档" class="headerlink" title="生成doc格式的文档"></a>生成doc格式的文档</h3>这里先拿使用freemarker导出doc格式的word文档举例。</li>
<li>首先将docxTemplate.docx（调整好样式的模版文档）另存为WORD 2003 XML文档(*.xml)<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200903162724.png"
                     
                ><br>此处命名为docTemplete.xml，使用编辑工具首次打开时，会发现这个文档里面是压缩的xml，因此我们首先需要格式化一下。<blockquote>
<p> 注意：如果你使用的是<strong>Visual Studio Code</strong>开发工具，一定要检查你所使用的xml格式化插件，是否会优化你的xml标签 。比如：<code>&lt;w:rPr&gt;</code>会变成<code>&lt;rPr&gt;</code>。使用<strong>Visual Studio Code</strong>的同学，oh my god ! 小明在这里推荐大家使用这个插件：XML Language Support by Red Hat</p>
</blockquote>
</li>
<li>现在，我们就使用freemarker语法编辑docTemplete.xml，比如使用占位符<code>$&#123;&#125;</code>替换当前文档中的文本，以达到动态生成文本的目的，直接上代码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Configuration getConfiguration()&#123;</span><br><span class="line">        //创建配置实例</span><br><span class="line">        Configuration configuration = new Configuration(Configuration.VERSION_2_3_28);</span><br><span class="line">        //设置编码</span><br><span class="line">        configuration.setDefaultEncoding(&quot;utf-8&quot;);</span><br><span class="line">        configuration.setClassForTemplateLoading(WordUtil.class, &quot;/templates&quot;);</span><br><span class="line">        return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成doc文件</span><br><span class="line">     *</span><br><span class="line">     * @param ftlFileName 模板ftl文件的名称</span><br><span class="line">     * @param params      动态传入的数据参数</span><br><span class="line">     * @param outFilePath 生成的最终doc文件的保存完整路径</span><br><span class="line">     */</span><br><span class="line">    public void ftlToDoc(String ftlFileName, Map params, String outFilePath) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            /** 加载模板文件 **/</span><br><span class="line">            Template template = configuration.getTemplate(ftlFileName);</span><br><span class="line">            /** 指定输出word文件的路径 **/</span><br><span class="line">            File docFile = new File(outFilePath);</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(docFile);</span><br><span class="line">            Writer bufferedWriter = new BufferedWriter(new OutputStreamWriter(fos, &quot;utf-8&quot;), 10240);</span><br><span class="line">            template.process(params, bufferedWriter);</span><br><span class="line">            if (bufferedWriter != null) &#123;</span><br><span class="line">                bufferedWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (TemplateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成docx格式的文档"><a href="#生成docx格式的文档" class="headerlink" title="生成docx格式的文档"></a>生成docx格式的文档</h3></li>
<li>*高能预警！** 在成功使用Freemarker动态导出doc格式的文档之后，相信大家和我的心情一样非常激动。但以上操作只是一个小铺垫，接下来我们来看看如何实现docx格式的文档导出，小明相信一定会让各位看官大跌眼镜！不，大开眼界！<br>首先，告诉大家一个秘密：<strong>docx格式的文档其实是一个ZIP格式的压缩文件哦！</strong> 什么？你不信？验证如下：</li>
<li>windows的小伙伴<br>将docx文档修改为ZIP格式（修改.docx后缀名为.zip），然后通过解压工具解压。</li>
<li>MacOS的小伙伴<br>直接使用<code>unzip</code>命令解压word文档，解压过后我们会发现该文档其实还有自己的<strong>目录结构</strong>！<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200907100322.png"
                      alt="震惊！"
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200907101744.png"
                     
                ><br>当然，这么多文件我们不必一一知悉，只需关注小明红线标注的文件和目录即可：</li>
<li>document.xml文件用于存放核心数据，文字，表格，图片引用等</li>
<li>media目录用于存放所有文档的图片</li>
<li>_rels目录下的document.xml.rels里存放的是配置信息，比如图片引用关系，即在document.xml中引用id对应media中的哪个图片。</li>
<li>获取zip里的document.xml文档以及_rels文件夹下的document.xml.rels文档</li>
<li>显而易见，如果我们要想根据数据动态导出不同的word文档，只需要：通过freemarker将本次数据填充到document.xml中，并将图片配置信息填充至document.xml.rels文档里，再用文件流把本次图片写入到media目录下替换已经存在的图片，最后把填充过内容的document.xml、document.xml.rels以及media用流的方式写入zip即可输出docx文档！上代码。<blockquote>
<p> 好吧，限于篇幅，代码见文末 Github地址</p>
</blockquote>
<h2 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h2>当然，大家在第一次尝试去干某一件事时，都不一定是一蹴而就的。就比如在导出word时，就可能会遇到以下问题。​</li>
</ul>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><strong>问题</strong>：有些文本数据中难免含有特殊字符，如：<code>&lt; &gt; @ ! $ &amp;</code> 等等。</p>
<p><strong>解决方案</strong>：这些特殊字符如果不进行转义，就会引起word打不开的现象，比如表格中的超链接的<code>&amp;</code>符号，就需要替换为<code>&amp;amp;</code>，如果你的文档用office打开时提示文件损坏，九成是因为特殊符号引起的，我们可以打开documet.xml定位报错位置；当然还有终极方案，我们可以利用Freemarker的语法直接在模板中使用<code>&lt;![CDATA[  ]]&gt; </code> 处理。比如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;w:t&gt;&lt;![CDATA[ $&#123;article.title&#125; ]]&gt;&lt;/w:t&gt;</span><br></pre></td></tr></table></figure>
<h3 id="图片变形"><a href="#图片变形" class="headerlink" title="图片变形"></a>图片变形</h3><p><strong>问题</strong>：因为echarts生成的图表是响应式的，不同的屏幕大小、分辨率，会造成每次前端传过来的图片宽高比例不一致，如果还直接将图片按照之前的比例放进文档，会造成生成后文档中的图片变形。</p>
<p><strong>思路</strong>：首先将文档中的图片设置为原图，然后锁定宽高比，将图片调整到合适大小，解压文档从<code>document.xml</code>，得到此时word中该图片宽高对应的值，如下所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200913163808.png"
                     
                ></p>
<p>要想保证不同像素比例的宽高在文档中不变形，我们需要固定<code>cy</code>的值，然后根据固定比例动态求得当前像素比例图片在word中代表的宽<code>cx</code>的值。计算方法如下所示：<br>公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a/b = x/y</span><br></pre></td></tr></table></figure>

<h3 id="解决适配问题"><a href="#解决适配问题" class="headerlink" title="解决适配问题"></a>解决适配问题</h3><p>生成的文档发现安卓手机用微信打开不能正常展示，但是用wps打开另存就可以正常打开！所以，我想是否可以通过poi解析后然后输出解决？验证后，答案是可以的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 读取原始Word文档</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;/Users/xin/Desktop/test/20230424110753.docx&quot;);</span><br><span class="line">    XWPFDocument document = new XWPFDocument(fis);</span><br><span class="line">    fis.close();</span><br><span class="line"></span><br><span class="line">    // 将文档另存为docx格式</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;/Users/xin/Desktop/test/20230424110753-new.docx&quot;);</span><br><span class="line">    document.write(fos);</span><br><span class="line">    fos.close();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;文档转换成功！&quot;);</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">    System.out.println(&quot;文档转换失败：&quot; + ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="常用的语法"><a href="#常用的语法" class="headerlink" title="常用的语法"></a>常用的语法</h3><h4 id="字符串是否为空"><a href="#字符串是否为空" class="headerlink" title="字符串是否为空"></a>字符串是否为空</h4><p>freemarker中显示某对象使用${name}.??但如果name为null，freemarker就会报错。<br>如果需要判断对象是否为空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#if name??&gt;</span><br><span class="line">      不为空</span><br><span class="line">      &lt;#else&gt;</span><br><span class="line">          为空</span><br><span class="line">  &lt;/#if&gt;</span><br></pre></td></tr></table></figure>
<p>当然也可以通过设置默认值来避免对象为空的错误(<strong>力荐</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;name!&#x27;&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>name</code>为空，就以默认值（”!”后的字符）显示。<br><code>$&#123;user.name&#125;</code>即name为user的属性，<code>user</code>、<code>name</code>都有可能为空，那么可以写成<code>$&#123;(user.name)!&#39;&#39;&#125;</code>,如果<code>user</code>或者<code>name</code>为null，都显示为空。</p>
<h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#if showModules?seq_contains(&quot;1&quot;) &gt; hello &lt;/#if&gt;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否为true"><a href="#判断是否为true" class="headerlink" title="判断是否为true"></a>判断是否为true</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建议使用其他类型</span><br></pre></td></tr></table></figure>
<h4 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空"></a>判断集合是否为空</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#if hotWordList ?? &amp;&amp; (hotWordList?size &gt; 0) &gt;不为空&lt;/#if&gt;</span><br></pre></td></tr></table></figure>
<h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#list firstMedia as fm&gt;$&#123;fm.mediaName&#125;&lt;/#list&gt;</span><br></pre></td></tr></table></figure>
<h4 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#if fm?item_parity = &quot;odd&quot; &gt;</span><br><span class="line">奇数</span><br><span class="line">    &lt;#else&gt;</span><br><span class="line">        偶数</span><br><span class="line">&lt;/#if&gt;</span><br></pre></td></tr></table></figure>

<h4 id="判断数值"><a href="#判断数值" class="headerlink" title="判断数值"></a>判断数值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#if rw.readNum != 0&gt;</span><br><span class="line">    &lt;span&gt;#&#123;rw.readNum&#125;&lt;/span&gt;</span><br><span class="line">    &lt;#else &gt;</span><br><span class="line">        &lt;div class=&quot;td&quot;&gt;</span><br><span class="line">            &lt;i class=&quot;iconfont icon-fair&quot;&gt;&lt;/i&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/#if&gt;</span><br></pre></td></tr></table></figure>

<h4 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$&#123;&quot;111.11&quot;?number&#125;</span><br><span class="line">结果为111.11  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，a表示图片在word中宽的数值，b代表图片在word中高的数值，x表示前端传过来图片的宽（单位：像素），y表示前端传过来图片的高（单位：像素）。因此，已知b、x、y,根据公式，我们即可求出a；</p>
<h2 id="我就是文末"><a href="#我就是文末" class="headerlink" title="我就是文末"></a>我就是文末</h2><p>当然，还有用一些其他注意事项：</p>
<ul>
<li>如果word中的模块比较多的话，使用Freemarker语法要仔细一点；</li>
<li>为什么小明最终选择导出docx格式的文档呢？（还不是因为产品经理的需求嘛）因为doc格式的文档，小明尝试导出后，发现该文档并不是一个合法的doc文档，体现在：不能在手机上（微信、钉钉）正常预览，office提示以xml形式打开等。因此在导出doc文档时，通过Freemaker填充document.xml后得到的并不是一个合法的word文档，查了相关资料，还需要借助第三方工具进行签名，而签名还需要在windows系统下才能完成，但是我们平时用的生产环境都是Linux……因此，考虑再三，再三权衡，最终选择导出docx格式的文档。这种方式再适合不过，而且还能保证在当前主流APP上都能正常预览。</li>
<li>敲黑板！导出docx文档最重要的一个思想是将本次数据写入覆盖模版文件（在商业中，相当于借壳上市），重新输出一个zip格式压缩的文件，这个文件就是我们最终想要的文档。</li>
</ul>
<p>以上，就是小明word导出的前前后后，如果你也曾经遇到过或者现在正好遇到word文档导出开发的问题，欢迎一起讨论交流。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>我上传了工具类，包含doc、docx 的导出，以及导出word文档时特殊符号转义，还有图片Base64转换成文件输出的方法。<br>GitHub地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming/blob/master/src/main/java/com/xm/coder/util/WordUtil.java" >https://github.com/WhenCoding/coder-xiaoming/blob/master/src/main/java/com/xm/coder/util/WordUtil.java<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Freemarker</tag>
        <tag>Docx</tag>
      </tags>
  </entry>
  <entry>
    <title>将博客搬至CSDN</title>
    <url>/p/14580.html</url>
    <content><![CDATA[<p>为了更好分享，同意将本站内容将博客搬至CSDN。<br>CSDN地址：<a class="link"   href="https://blog.csdn.net/x851288986" >https://blog.csdn.net/x851288986<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>用正则截取两个符号之间的内容</title>
    <url>/p/44073.html</url>
    <content><![CDATA[<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/Xnip2022-08-26_15-12-51.jpg"
                     
                ></p>
<!-- ![](https://img.mynamecoder.com/20220830200208.png) -->
<p>前两天从网上采集到一条短视频数据（刷短视频），发现六公主连排5部刘亦菲主演的电影！甚是震惊，太有牌面了，看了一下日子是8月25号，嗷，原来当天是刘亦菲的生日。巧了，正好也是我家柴犬旺财的3岁生日😀。</p>
<span id="more"></span>


<p>言归正传，我们看到这条数据的</p>
<p><strong>标题</strong>：#刘亦菲35岁生日获央视独宠# 神仙姐姐生日快乐！</p>
<p>为了分析数据，我们需要获取数据中所提到的话题<code>#刘亦菲35岁生日获央视独宠#</code>。提问：你能想到几种实现方式呢？欢迎评论区留言。</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>想必细心看标题的朋友一定会猜到本文的主人公——<strong>正则</strong>，这玩意优点是写起来快，但缺点也显而易见，性能差，跟批处理一个德性，反人类的难记，长时间不用，每次都要重新学习，日常开发中也就偶尔写工具用一下。因此，我们只需要把常用的正则理解透就可以了，不要有心理包袱，看完本文，大部分的正则使用场景就可以活学活用。</p>
<h3 id="场景一：匹配两个-之间的字符串"><a href="#场景一：匹配两个-之间的字符串" class="headerlink" title="场景一：匹配两个#之间的字符串"></a>场景一：匹配两个<code>#</code>之间的字符串</h3><p>现在我们把需求转换成实现思路，想要获取上述数据中的话题，其实就是匹配两个<code>#</code>之间的文本内容，show code：</p>
<p><strong>正则表达式</strong>：<code>#.*?#</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;#刘亦菲35岁生日获央视独宠# 神仙姐姐生日快乐！&quot;</span>;</span><br><span class="line">    <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(#.*?#)&quot;</span>);</span><br><span class="line">    <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(title);</span><br><span class="line">    <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> m.group(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;话题:&quot;</span> + group);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">话题:#刘亦菲35岁生日获央视独宠#</span><br></pre></td></tr></table></figure>

<p>可以看出，输出的结果就是该条数据的话题，给大家分析一下这个正则表达式：<br><code>.</code>表示任意字符，<code>?</code>平时表示匹配0个或者多个，此时它表示<strong>不贪婪</strong>，那什么是<strong>贪婪</strong>呢？<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220829155600_dark.png"
                     
                ></p>
<p>说到<strong>贪婪</strong>，那就不得不提这两个限定符：<code>*</code> 和 <code>+</code> ，它们两个就是<strong>贪婪</strong>的！<code>*</code>表示匹配0个或者多个，<code>+</code>表示匹配至少一个，可以发现它们的共性：都会尽可能匹配更多。但，只要紧跟在它们的后面加上一个 <code>?</code> ，让他们扪心自问，就可以实现<strong>非贪婪</strong>，即最小匹配。比如，我们在标题上再加一个<code>#</code>，此时标题变为<code>#刘亦菲35岁生日获央视独宠## 神仙姐姐生日快乐！</code>，然后正则表达式我们不使用<code>?</code>，此时，运行代码后输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">话题:#刘亦菲35岁生日获央视独宠##</span><br></pre></td></tr></table></figure>
<p>比较两次的执行结果，我们会发现输出结果多了一<code>#</code>，这样就很贪婪，违背了我们的初衷，这就是<code>?</code>的妙用。</p>
<h3 id="场景二：只匹配-开头的字符串"><a href="#场景二：只匹配-开头的字符串" class="headerlink" title="场景二：只匹配#开头的字符串"></a>场景二：只匹配<code>#</code>开头的字符串</h3><p>我们知道不同平台的话题格式是不一样的，比如抖音，它的话题形式就与微博不同，只是<code>#</code>开头，并没有成对的<code>#</code>与其呼应：</p>
<p><strong>标题</strong>：#刘亦菲35岁生日获央视独宠 神仙姐姐生日快乐！</p>
<p>如果是这种形式的话题，爱动脑筋的朋友就会发现无非就是将后面的<code>#</code>变为一个空格或者多个空格呗。没错，我们可以使用</p>
<p><strong>正则表达式</strong>：<code>#.*?\\s+</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;#刘亦菲35岁生日获央视独宠  神仙姐姐生日快乐！&quot;</span>;</span><br><span class="line">    <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(#.*?\\s+)&quot;</span>);</span><br><span class="line">    <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(title);</span><br><span class="line">    <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> m.group(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;话题:&quot;</span> + group);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">话题:#刘亦菲35岁生日获央视独宠 </span><br></pre></td></tr></table></figure>

<p><strong>Tips</strong>：<code>\s</code> 表示匹配所有空白符，它不仅仅可以匹配空格，还可以匹配换行等空白字符，如果再加上<code>+</code>，组合起来就表示甭管几个空白字符，统统all in。</p>
<p>不过，不要高兴得太早，心细的小明还发现话题可能会存在文末的情况：</p>
<p><strong>标题</strong>：神仙姐姐生日快乐！#刘亦菲35岁生日获央视独宠</p>
<p>此时是没有空白字符结束的，上面的正则就不满足这种情况。那如何是好？小明当时就想到了两个方案：</p>
<ul>
<li>方案一：不管话题在不在文末，我们在匹配之前全部给标题追加一个空白字符，这样就可以人为干预，巧妙地避开了这种情况，曲线救国，便于正则匹配</li>
<li>方案二：使用正则表达式<code>#.*?$</code></li>
</ul>
<p><strong>Tips</strong>：方案二中的<code>$</code> 是用来匹配输入字符串的结尾位置，组合起来就表示匹配<code>#</code>开头，一直到句末的话题。</p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>前面两种场景我们虽然获取到了两个<code>#</code>之间或者<code>#</code>开头的内容，实现了需求，但是匹配的结果还是会带上<code>#</code>，贪婪的小明不满足现状（产品强制要求），可不可以不带呢？<br>当然可以了！小明又想到了两个方案：</p>
<ul>
<li>方案一：得到匹配的话题后，再二次文本处理去掉<code>#</code></li>
<li>方案二：使用正则表达式<code>?&lt;=</code>和<code>?=</code>一步到位，直接去除<code>#</code></li>
</ul>
<p><strong>使用方法</strong></p>
<ul>
<li><code>(?&lt;=exp2)exp1</code>：表示匹配 <code>exp2</code> 后面的 <code>exp1</code></li>
<li><code>exp1(?=exp2)</code>：表示匹配 <code>exp2</code> 前面的 <code>exp1</code><br>那结合以上我们实际使用的所有场景，最终这个理想的正则表达式就正式出炉（好热）：<code>((?&lt;=#).*?(?=#|\s+))</code><br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/lyf.gif"
                      alt="（好热）"
                ><br>反应慢的朋友，可以慢点理解，我们先运行试一下（不自信）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String title = &quot;#刘亦菲# #神仙姐姐 #生日快乐# #刘亦菲35岁生日获央视独宠&quot;;</span><br><span class="line">    Pattern p = Pattern.compile(&quot;((?&lt;=#).*?(?=#|\\s+|$))&quot;);</span><br><span class="line">    Matcher m = p.matcher(title);</span><br><span class="line">    while (m.find()) &#123;</span><br><span class="line">        String group = m.group(0);</span><br><span class="line">        System.out.println(&quot;话题:&quot; + group);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">话题:刘亦菲</span><br><span class="line">话题:</span><br><span class="line">话题:神仙姐姐</span><br><span class="line">话题:生日快乐</span><br><span class="line">话题:</span><br><span class="line">话题:刘亦菲35岁生日获央视独宠</span><br></pre></td></tr></table></figure>

<p><strong>Tips</strong>：正则表达式中的<code>|</code>表示或，即多项之间的一个选择，就像今天你看完本文，感觉不错的话，<br>必须做出(<strong>关注|点赞|星标</strong>)其中的一个选择！<br>从代码的输出结果我们可以看出，目前的正则是经得住实际考验的。但是唯一美中不足的是，会有空字符串的情况出现（产品不同意）。<br>这该如何是好？<br>目前小明的解决方案是，拿到匹配结果时，过滤掉空字符串。能解决问题的办法就是好办法。不过，肯定有更完美的表达式可以实现这个需求，此处抛砖引玉，期待你在评论区分享！</p>
<h3 id="常用的正则表达式分享"><a href="#常用的正则表达式分享" class="headerlink" title="常用的正则表达式分享"></a>常用的正则表达式分享</h3><ul>
<li>微信号（并不能帮你要到男神|女神的微信号）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z][a-zA-Z\d_-]&#123;5,19&#125;$</span><br></pre></td></tr></table></figure>
<p>未完待续……</p>
]]></content>
  </entry>
  <entry>
    <title>常见技术用语英文缩写</title>
    <url>/p/51810.html</url>
    <content><![CDATA[<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220927114343.png"
                     
                ></p>
<blockquote>
<p>日常开发中经常会遇到一些英文简写表达专业术语，特别整理了一些全称，方便理解记忆。</p>
</blockquote>
<span id="more"></span>
<h2 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h2><p>堆内存的初始大小，初始内存采用的也就是最小内存，全称：memory size(m表示memory，s表示size)</p>
<h2 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h2><p>堆内存的最大大小，全称：memory max size，为了对齐，使用<code>-Xmx</code></p>
<h2 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h2><p>堆内新生代的大小，全称：memory new size，为了对齐，使用<code>-Xmn</code>。（通过这个值也可以得到老生代的大小：<code>-Xmx</code>减去<code>-Xmn</code>）</p>
<h2 id="DSM"><a href="#DSM" class="headerlink" title="DSM"></a>DSM</h2><p>DSM 是“Desktop Server Manager”的缩写，意思是“桌面服务器管理器”，比如Synology（群晖），最近刚入手了群晖☺️</p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<p>之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F  #-F相当于内置变量FS, 指定分割字符，缺省是空格</span><br><span class="line">awk -F, &#x27;&#123;print $1,$2&#125;&#x27;   log.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="FQDN"><a href="#FQDN" class="headerlink" title="FQDN"></a>FQDN</h2><p>FQDN：(Fully Qualified Domain Name)全限定域名：同时带有主机名和域名的名称。（通过符号“.”）<br>从全限定域名中包含的信息可以看出主机在域名树中的位置。DNS解析流程：首先查找本机HOSTS表，有的直接使用表中定义，没有查找网络连接中设置的DNS 服务器由他来解析。</p>
<h2 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h2><p>无线访问接入点(WirelessAccessPoint)<br>无线AP（Access Point）：即无线接入点，它用于无线网络的无线交换机，也是无线网络的核心。无线AP是移动计算机用户进入有线网络的接入点，主要用于宽带家庭、大楼内部以及园区内部，可以覆盖几十米至上百米。无线AP（又称会话点或存取桥接器）是一个包含很广的名称，它不仅包含单纯性无线接入点（无线AP），同样也是无线路由器（含无线网关、无线网桥）等类设备的统称。 [1] </p>
]]></content>
  </entry>
  <entry>
    <title>开发随记</title>
    <url>/p/7e8c.html</url>
    <content><![CDATA[<p>📒 记录每日开发过程中的一些碎片，持续更新</p>
<span id="more"></span>


<h2 id="pip-查看包信息"><a href="#pip-查看包信息" class="headerlink" title="pip 查看包信息"></a>pip 查看包信息</h2><p>命令显示已安装包的信息（包名与版本号）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再用命令显示该安装的包的相关信息，其中包括它的安装路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip show package_name</span><br></pre></td></tr></table></figure>
<p>实际上包通常被安装在python安装目录下的lib\site-packages目录下</p>
<h2 id="Mac微信聊天记录所在目录"><a href="#Mac微信聊天记录所在目录" class="headerlink" title="Mac微信聊天记录所在目录"></a>Mac微信聊天记录所在目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat</span><br></pre></td></tr></table></figure>


<h2 id="Mac日历与iPhone日历不无法同步问题"><a href="#Mac日历与iPhone日历不无法同步问题" class="headerlink" title="Mac日历与iPhone日历不无法同步问题"></a>Mac日历与iPhone日历不无法同步问题</h2><ul>
<li>升级一下系统为最新</li>
</ul>
<ul>
<li>~/Library/Preferences 目录下，删除 com.apple.iCal.plist ；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/Library/Preferences </span><br><span class="line">rm -rf com.apple.iCal.plist </span><br></pre></td></tr></table></figure>

<ul>
<li><p>打开日历 App，账户-退出icloud账户，关闭日历程序</p>
</li>
<li><p>重新登录，提示同步本地日历到云端</p>
</li>
</ul>
<h2 id="MacOS-字体-font-文件的-存放路径"><a href="#MacOS-字体-font-文件的-存放路径" class="headerlink" title="MacOS: 字体(font)文件的 存放路径"></a>MacOS: 字体(font)文件的 存放路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/System/Library/Fonts</span><br></pre></td></tr></table></figure>


<h2 id="mybatis输出最终sql"><a href="#mybatis输出最终sql" class="headerlink" title="mybatis输出最终sql"></a>mybatis输出最终sql</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimpleExecutor</span><br></pre></td></tr></table></figure>
<p>可以通过debug形式获取变量的值</p>
<h2 id="修改Linux环境变量"><a href="#修改Linux环境变量" class="headerlink" title="修改Linux环境变量"></a>修改Linux环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 最后面追加</span><br><span class="line">vi /etc/profile</span><br><span class="line"># 立即生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、重启Jenkies</span><br><span class="line">http://localhost:8080/restart</span><br><span class="line"></span><br><span class="line">2、重新加载配置信息</span><br><span class="line"> http://localhost:8080/reload</span><br></pre></td></tr></table></figure>

<h2 id="openresty工作流程"><a href="#openresty工作流程" class="headerlink" title="openresty工作流程"></a>openresty工作流程</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230223233907.png"
                     
                ></p>
<h2 id="NullPointerException异常在Java中没有堆栈"><a href="#NullPointerException异常在Java中没有堆栈" class="headerlink" title="NullPointerException异常在Java中没有堆栈"></a>NullPointerException异常在Java中没有堆栈</h2><p>使用的HotSpot JVM，为了达到更好的性能，执行了很多优化，默认空指针异常堆栈跟踪不打印。因此，要获得堆栈追溯，需要通过选项<code>-XX:-OmitStackTraceInFastThrow</code>设置启动参数。</p>
<h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><p>lua脚本变量命名千万不要带“-”，尤其是在openresty引用该脚本的场景下注意日志错误，忘不掉那个午休被惊醒的场景。</p>
<h2 id="数据库连接工具"><a href="#数据库连接工具" class="headerlink" title="数据库连接工具"></a>数据库连接工具</h2><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><strong>Mac</strong></h4><p>Sequel Pro、Navicat（好用且破费）、DBeaver</p>
<h4 id="win"><a href="#win" class="headerlink" title="win"></a><strong>win</strong></h4><p> HeidiSQL</p>
<h2 id="hosts文件所在目录"><a href="#hosts文件所在目录" class="headerlink" title="hosts文件所在目录"></a>hosts文件所在目录</h2><h4 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a><strong>Mac</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/hosts</span><br></pre></td></tr></table></figure>



<h4 id="win-1"><a href="#win-1" class="headerlink" title="win"></a>win</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\Windows\System32\divers\etc\hosts</span><br></pre></td></tr></table></figure>



<h2 id="Tomcat存放目录"><a href="#Tomcat存放目录" class="headerlink" title="Tomcat存放目录"></a>Tomcat存放目录</h2><h4 id="Mac-2"><a href="#Mac-2" class="headerlink" title="Mac"></a>Mac</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Library</span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>自定义</p>
<h2 id="redis查看工具Redis-client"><a href="#redis查看工具Redis-client" class="headerlink" title="redis查看工具Redis client"></a>redis查看工具Redis client</h2><h4 id="Mac-3"><a href="#Mac-3" class="headerlink" title="Mac"></a>Mac</h4><p>Redis Desktop Manager</p>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT IGNORE 忽略导致错误的行，如果有则不插入也不报错，并将其余行插入到表中。</span><br></pre></td></tr></table></figure>

<h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 域名/ip</span><br></pre></td></tr></table></figure>

<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>获取列表长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LLen key</span><br></pre></td></tr></table></figure>

<p>获取前10个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LRANGE key 0 10</span><br></pre></td></tr></table></figure>



<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="Spring-Boot-启动加载数据-CommandLineRunner"><a href="#Spring-Boot-启动加载数据-CommandLineRunner" class="headerlink" title="Spring Boot 启动加载数据 CommandLineRunner"></a>Spring Boot 启动加载数据 CommandLineRunner</h3><p><a class="link"   href="https://blog.csdn.net/catoop/article/details/50501710" >https://blog.csdn.net/catoop/article/details/50501710<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="springboot中-scheduled开关机制"><a href="#springboot中-scheduled开关机制" class="headerlink" title="springboot中@scheduled开关机制"></a>springboot中@scheduled开关机制</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;scheduling&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">public class SchedulingConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheduling.enabled=true</span><br></pre></td></tr></table></figure>



<h2 id="idea-打开cpu监控如何关闭"><a href="#idea-打开cpu监控如何关闭" class="headerlink" title="idea 打开cpu监控如何关闭"></a>idea 打开cpu监控如何关闭</h2><p>view-&gt;tool windows-&gt;coverage-&gt;关闭application</p>
<h2 id="mac查看图片如何来回切换"><a href="#mac查看图片如何来回切换" class="headerlink" title="mac查看图片如何来回切换"></a>mac查看图片如何来回切换</h2><p>按住空格，通过方向键切换</p>
<h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f ./catalina.out | grep &#x27;舆情秘书&#x27; -A 10</span><br></pre></td></tr></table></figure>

<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① grep -E &quot;word1|word2|word3&quot; file.txt</span><br><span class="line">满足任意条件（word1、word2和word3之一）将匹配。</span><br><span class="line">② grep word1 file.txt | grep word2 |grep word3</span><br><span class="line">必须同时满足三个条件（word1、word2和word3）才匹配。</span><br></pre></td></tr></table></figure>



<h2 id="idea自动导入包"><a href="#idea自动导入包" class="headerlink" title="idea自动导入包"></a>idea自动导入包</h2><p>Preference（快捷键：command+,）-&gt;maven-&gt;import maven projects automaticallly</p>
<h2 id="idea忽略-iml"><a href="#idea忽略-iml" class="headerlink" title="idea忽略*.iml"></a>idea忽略*.iml</h2><ol>
<li><code>Editor-&gt;File Types=&gt;Ignore files and folders增加*.iml;</code></li>
<li><code>在lgnore files and folesrs中输入.idea;注意要&quot;;&quot;结尾。你就可以隐藏.idea文件夹了</code></li>
</ol>
<h2 id="idea查看properties中文变成unicode码如何解决"><a href="#idea查看properties中文变成unicode码如何解决" class="headerlink" title="idea查看properties中文变成unicode码如何解决"></a>idea查看properties中文变成unicode码如何解决</h2><p>Preference（快捷键：command+,）-&gt;搜索File Encoding-&gt;Transparent native-to-ascii conversion勾选框，勾选之后点击确认。</p>
<h2 id="idea-好用的插件"><a href="#idea-好用的插件" class="headerlink" title="idea 好用的插件"></a>idea 好用的插件</h2><h3 id="Free-Mybatis-plugin"><a href="#Free-Mybatis-plugin" class="headerlink" title="Free Mybatis plugin"></a>Free Mybatis plugin</h3><p>A idea plugin for mybatis free-idea-mybatis is an enchange plugin for idea to supoort mybatis</p>
<h3 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h3><p>生成一个方法逻辑的时序图，深度可以自定义，能够很方便地分析代码逻辑，很实用，尤其是当你刚开始接手别人的代码时……</p>
<h2 id="清除ios输入法预测的记录"><a href="#清除ios输入法预测的记录" class="headerlink" title="清除ios输入法预测的记录"></a>清除ios输入法预测的记录</h2><p>设置》通用》还原》还原键盘词典。</p>
<h2 id="redis-查看当前发布订阅命令"><a href="#redis-查看当前发布订阅命令" class="headerlink" title="redis 查看当前发布订阅命令"></a>redis 查看当前发布订阅命令</h2><p>pubsub channels</p>
<h2 id="imovie"><a href="#imovie" class="headerlink" title="imovie"></a>imovie</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>文件-&gt;分享-&gt;文件-&gt;选择视频或者音频</p>
<h2 id="Mac-4"><a href="#Mac-4" class="headerlink" title="Mac"></a>Mac</h2><h3 id="移动（剪切）"><a href="#移动（剪切）" class="headerlink" title="移动（剪切）"></a>移动（剪切）</h3><ul>
<li>command+c</li>
<li>command+option+v</li>
</ul>
<h3 id="Visual-Studio-Code-Dock没有图标"><a href="#Visual-Studio-Code-Dock没有图标" class="headerlink" title="Visual Studio Code Dock没有图标"></a>Visual Studio Code Dock没有图标</h3><p>最近发现使用Visual Studio Code在Dock上居然找不到图标（bug）。<br>打开<code>terminal</code>命令行工具，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>

<p>回车，这样Dock就可以自动重启，vs code的图标在Dock中也恢复正常显示。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>统计log中关键词出现的次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#x27;192.168.185.112&#x27; | wc | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &quot;userid=69129&amp;KK_TYPE=01&quot; http://192.168.185.63:8080/SubjectTree/getTree.do</span><br></pre></td></tr></table></figure>

<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#x27;192.168.185.112&#x27; | wc -l</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#x27;192.168.185.112&#x27; | wc | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init 0</span><br></pre></td></tr></table></figure>

<h3 id="用户组控制目录权限"><a href="#用户组控制目录权限" class="headerlink" title="用户组控制目录权限"></a>用户组控制目录权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown tomcat:tomcat yqms_error.log</span><br></pre></td></tr></table></figure>

<h3 id="SSH下用vim打开文件，文件显示不全"><a href="#SSH下用vim打开文件，文件显示不全" class="headerlink" title="SSH下用vim打开文件，文件显示不全"></a>SSH下用vim打开文件，文件显示不全</h3><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stty rows 200 columns 250</span><br></pre></td></tr></table></figure>

<h3 id="vim显示行号"><a href="#vim显示行号" class="headerlink" title="vim显示行号"></a>vim显示行号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set number</span><br></pre></td></tr></table></figure>

<h3 id="配置ssh免登录"><a href="#配置ssh免登录" class="headerlink" title="配置ssh免登录"></a>配置ssh免登录</h3><p>首先确认当前用户本地是否存在公钥私钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果存在跳过这一步，如果不存在使用<code>ssh-keygen</code>即可生成公钥私钥对（一直回车，我们不需要使用密码保护私钥对）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>我们发现当前用户目录下生成以下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authorized_keys</span><br><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br><span class="line">known_hosts</span><br></pre></td></tr></table></figure>

<p>至此，我们使用<code>ssh-copy-id</code>将公钥复制到远程机器中，即可通过ssh免密访问服务器、scp免密上传文件，类似的应用场景还有github代码管理也有用到，确实非常方便。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -p 端口号 -i ~/.ssh/id_rsa.pub 用户名@ip地址</span><br></pre></td></tr></table></figure>

<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h4 id="根据关键词筛选日志"><a href="#根据关键词筛选日志" class="headerlink" title="根据关键词筛选日志"></a>根据关键词筛选日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f -n 100 log | grep 关键词</span><br></pre></td></tr></table></figure>

<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看端口号占用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>

<p>查看端口被哪个进程使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp|grep 8080</span><br></pre></td></tr></table></figure>

<p>在一次启动jar包的服务中，通过以上方法如果找不到端口号占用情况，通过删除nohup文件解决</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><h4 id="根据“java”执行命令的查看进程"><a href="#根据“java”执行命令的查看进程" class="headerlink" title="根据“java”执行命令的查看进程"></a>根据“java”执行命令的查看进程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps ax | grep java</span><br></pre></td></tr></table></figure>

<h4 id="杀死同名全部进程方法"><a href="#杀死同名全部进程方法" class="headerlink" title="杀死同名全部进程方法"></a>杀死同名全部进程方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep phantomjs |grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9</span><br></pre></td></tr></table></figure>

<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>统计当前目录文档数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls | wc -l</span><br></pre></td></tr></table></figure>

<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>统计磁盘使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>



<h2 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h2><ul>
<li><p>jenkins SSH插件如果不指定目录位置，默认目录是<code>/root</code>下，需要注意，目前推荐使用默认，方便统一管理。</p>
</li>
<li><p>当配置SSH插件脚本时，需要注意在目标服务器上执行脚本（ssh exec command）时，使用以下命令才能正常使用脚本，启动应用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>日常开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令</title>
    <url>/p/4635.html</url>
    <content><![CDATA[<h2 id="yum命令使用举例"><a href="#yum命令使用举例" class="headerlink" title="yum命令使用举例"></a>yum命令使用举例</h2><h3 id="yum安装nginx"><a href="#yum安装nginx" class="headerlink" title="yum安装nginx"></a>yum安装nginx</h3><ul>
<li>安装命令：yum install nginx</li>
<li>查看列表：yum list | grep nginx</li>
<li>其他相关命令<ul>
<li>查看版本: nginx -v</li>
<li>查看nginx对应的参数: nginx -V </li>
<li>检验配置文件:/usr/sbin/nginx -t </li>
<li>重启Nginx服务<ul>
<li>/usr/sbin/nginx -s reload</li>
</ul>
</li>
<li>rpm -ql nginx //yum 源安装实际上是在我们的服务器上安装了一个一个的rpm包</li>
</ul>
</li>
<li>根据包路径查找安装目录<ul>
<li><strong>rpm -ql 包名称</strong></li>
</ul>
</li>
</ul>
<h3 id="yum安装tomcat"><a href="#yum安装tomcat" class="headerlink" title="yum安装tomcat"></a>yum安装tomcat</h3><ul>
<li>安装命令：yum install tomcat</li>
<li>启动tomcat: sudo systemctl start tomcat</li>
<li>重启tomcat: sudo systemctl restart tomcat<h2 id="vim命令使用"><a href="#vim命令使用" class="headerlink" title="vim命令使用"></a>vim命令使用</h2></li>
<li>查找<ul>
<li>?关键词:从下往上查找</li>
<li>/关键词：从上往下查找</li>
</ul>
</li>
</ul>
<ul>
<li>nginx <ul>
<li>配置静态文件404问题：<a class="link"   href="https://blog.csdn.net/line_aijava/article/details/71473793" >https://blog.csdn.net/line_aijava/article/details/71473793<i class="fas fa-external-link-alt"></i></a> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /api/v1/upload &#123;</span><br><span class="line">     alias /opt/edu/upload/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="yum-安装maven"><a href="#yum-安装maven" class="headerlink" title="yum 安装maven"></a>yum 安装maven</h3></li>
</ul>
</li>
</ul>
<ul>
<li>两步安装maven<ul>
<li>下载包<br>wget <a class="link"   href="http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo" >http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo<i class="fas fa-external-link-alt"></i></a> -O /etc/yum.repos.d/epel-apache-maven.repo</li>
</ul>
</li>
<li>安装maven<br>yum -y install apache-maven<h4 id="查找maven安装路径"><a href="#查找maven安装路径" class="headerlink" title="查找maven安装路径"></a>查找maven安装路径</h4></li>
</ul>
<h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行。在服务器的配置和管理中，这个工具常被应用，简单明了。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgrep [options] &lt;pattern&gt;</span><br></pre></td></tr></table></figure>
<h3 id="常用举例"><a href="#常用举例" class="headerlink" title="常用举例"></a>常用举例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgrep java // 列出java所有进程</span><br><span class="line">pgrep -c java // 当前当前服务器上java进程数量</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「记录」日常开发当中遇到的一些问题</title>
    <url>/p/1a81.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随手记录了自己在开发中遇到的一些问题及解决方法，有些问题很小，但是却很容易犯错，也不怕被别人笑话，都在这里了。</p>
<h2 id="maven使用阿里镜像有问题"><a href="#maven使用阿里镜像有问题" class="headerlink" title="maven使用阿里镜像有问题"></a>maven使用阿里镜像有问题</h2><p>新建或者覆盖settings.xml，完美解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0</span><br><span class="line">                          https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line">      &lt;/mirrors&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用MacOs更新系统Catalina之后Git出现问题"><a href="#使用MacOs更新系统Catalina之后Git出现问题" class="headerlink" title="使用MacOs更新系统Catalina之后Git出现问题"></a>使用MacOs更新系统Catalina之后Git出现问题</h2><p>（可以说是每次）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<p>这是Xcode命令行工具需要更新，在你的Terminal中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>当出现提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select: note: install requested for command line developer tools</span><br></pre></td></tr></table></figure>

<p>表示Xcode更新成功，可以正常使用，这个问题主要出现在系统大版本更新的时候，因此时刻保证Xcode工具更新即可避免该问题。</p>
<h2 id="在SpringBoot打包成jar后，无法读取自定义文件的解决办法"><a href="#在SpringBoot打包成jar后，无法读取自定义文件的解决办法" class="headerlink" title="在SpringBoot打包成jar后，无法读取自定义文件的解决办法"></a>在SpringBoot打包成jar后，无法读取自定义文件的解决办法</h2><p>前两天在做springcloud框架下的项目的时候，用到有一个框架之外的文件需要进行读取，当时在IDE中编码时通过this.getClass().getResource来获取文件的路径，没有任何的问题，但是在打成jar以后，结果发现不能正常的读取我放在工程里面的文件，但是在jar里面对应的class路径下可以看到该文件，后来将文件直接放到和我一个java文件平级的目录下，问题依然，最后使用了InputStream inputStream=this.getClass().getResourceAsStream(“/config/a.pfx”);来读取，才解决了问题。</p>
<p>tips:切记打成jar后如果需要用到这种框架之外的文件的话要用上面的方法来读取。</p>
<h2 id="运行maven打包SpringBoot的jar包报错：-jar中没有主清单属性"><a href="#运行maven打包SpringBoot的jar包报错：-jar中没有主清单属性" class="headerlink" title="运行maven打包SpringBoot的jar包报错：-jar中没有主清单属性"></a>运行maven打包SpringBoot的jar包报错：-jar中没有主清单属性</h2><p>使用mvn package打jar包，运行java -jar XXX.jar的时候报错：jar中没有主清单属性。pom.xml中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">	&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>再次运行mvn package之后，即可正常运行。</p>
<h2 id="接口请求Status-blocked-other"><a href="#接口请求Status-blocked-other" class="headerlink" title="接口请求Status(blocked:other)"></a>接口请求Status(blocked:other)</h2><p>有一次在前端请求后台提供的接口时，突然发现自己的浏览器不能请求<br><img  
                     lazyload
                     alt="image"
                     data-src="http://img.mynamecoder.com/FrHqA_C7J80ifxtGHoPjlF1emCU3"
                     
                ></p>
<p>倒腾了很久，才发现是被浏览器插件（如我使用的是AdBlock插件）当作广告拦截了，当你在一个广告业务的公司工作，尤其要注意一哈。</p>
<p>解决办法：</p>
<ol>
<li>停用你的广告拦截器</li>
<li>在当前网站停用广告拦截插件（比如AdBlock）</li>
</ol>
<h2 id="for循环中慎用return"><a href="#for循环中慎用return" class="headerlink" title="for循环中慎用return"></a>for循环中慎用return</h2><p>马虎所致，for循环中的元素判断如果不满足条件，应当跳过当前的元素，应该使用continue，而不是return结束判断。</p>
<h2 id="es不同的索引相同字段mapping类型不一致，导致查询时映射问题"><a href="#es不同的索引相同字段mapping类型不一致，导致查询时映射问题" class="headerlink" title="es不同的索引相同字段mapping类型不一致，导致查询时映射问题"></a>es不同的索引相同字段mapping类型不一致，导致查询时映射问题</h2><ul>
<li>方案一：重建索引reindex</li>
<li>方案二：可能索引数量较多，不能一个个都重建，可以缩小查询的索引或者或者根据时间字段查询类型一致的索引</li>
</ul>
<h2 id="python3链接mongodb密码中有特殊字符"><a href="#python3链接mongodb密码中有特殊字符" class="headerlink" title="python3链接mongodb密码中有特殊字符@"></a>python3链接mongodb密码中有特殊字符@</h2><p>This worked for me ….</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(&quot;mongodb://username:12%40password@ip:27017/sample_db&quot;,authSource=&quot;admin&quot;) </span><br><span class="line">db = client[&#x27;sample_db&#x27;]</span><br></pre></td></tr></table></figure>
<p>Remember if you have special characters in your password (e.g. #,@) you will need to encode them (see %40) in the password. <strong>If you do not do authSource=”admin” you will receive authentication errors.</strong> username - your mongodb username, ip - ip address as this assumes database is hosted on a remote server. sample_db is the database that you would like to access.</p>
<h2 id="为什么Navicat统计的行数和表实际行数不一致？"><a href="#为什么Navicat统计的行数和表实际行数不一致？" class="headerlink" title="为什么Navicat统计的行数和表实际行数不一致？"></a>为什么Navicat统计的行数和表实际行数不一致？</h2><p>针对该问题，我专门写了篇文章(<a href="https://mynamecoder.com/p/8868.html">https://mynamecoder.com/p/8868.html</a>)</p>
<h2 id="mysql批量删除大量数据"><a href="#mysql批量删除大量数据" class="headerlink" title="mysql批量删除大量数据"></a>mysql批量删除大量数据</h2><p>假设有一个表(syslogs)有1000万条记录，需要在业务不停止的情况下删除其中statusid=1的所有记录，差不多有600万条， 直接执行 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM syslogs WHERE statusid=1 </span><br></pre></td></tr></table></figure>
<p>会发现删除失败，因为<code>lock wait timeout exceed</code>的错误。因为这条语句所涉及的记录数太多，因此我们通过LIMIT参数分批删除，比如每10000条进行一次删除，那么我们可以利用 MySQL这样的语句来完成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM syslogs WHERE status=1 ORDER BY statusid LIMIT 10000;</span><br></pre></td></tr></table></figure>

<p>然后分多次执行就可以把这些记录成功删除。</p>
<blockquote>
<p>注：执行大批量删除的时候注意要使用上limit。因为如果不用limit，删除大量数据很有可能造成死锁。如果delete的where语句不在索引上，可以先找主键，然后根据主键删除数据库。平时update和delete的时候最好也加上<strong>limit 1</strong>来防止误操作。</p>
</blockquote>
<h2 id="Grep命令出现-Binary-file-standard-input-matches"><a href="#Grep命令出现-Binary-file-standard-input-matches" class="headerlink" title="Grep命令出现 Binary file (standard input) matches"></a>Grep命令出现 Binary file (standard input) matches</h2><p>解决方法  加上-a<br>例如原本为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep hello xxx.log</span><br></pre></td></tr></table></figure>
<p>改为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -a hello xxx.log</span><br></pre></td></tr></table></figure>
<p> -a: 表示把二进制文件当成普通文本，效果和–binary-files=text</p>
<h2 id="Windows、Mac、Linux中Docker开启远程访问API-2375端口-以及各种坑"><a href="#Windows、Mac、Linux中Docker开启远程访问API-2375端口-以及各种坑" class="headerlink" title="Windows、Mac、Linux中Docker开启远程访问API(2375端口)以及各种坑"></a>Windows、Mac、Linux中Docker开启远程访问API(2375端口)以及各种坑</h2><p><a class="link"   href="https://www.xubingtao.cn/2020/04/15/dockerd_remotely/" >参考链接<i class="fas fa-external-link-alt"></i></a>[]</p>
<h2 id="如何使用-SSH-远程控制一台-Windows-服务器"><a href="#如何使用-SSH-远程控制一台-Windows-服务器" class="headerlink" title="如何使用 SSH 远程控制一台 Windows 服务器"></a>如何使用 SSH 远程控制一台 Windows 服务器</h2><p>安装openshell</p>
<h2 id="解决nginx请求过大的问题"><a href="#解决nginx请求过大的问题" class="headerlink" title="解决nginx请求过大的问题"></a>解决nginx请求过大的问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream sent too big header while reading response header from upstream</span><br></pre></td></tr></table></figure>
<p>解决方法如下：<br>在 nginx.conf 的http段，加入下面的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">proxy_buffers  32 32k;</span><br><span class="line"></span><br><span class="line">proxy_busy_buffers_size 128k;</span><br></pre></td></tr></table></figure>

<p>重启后一般就可以解决， 如果还是报502，再在host配置的php段加入下面配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastcgi_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">fastcgi_buffers 4 256k;</span><br><span class="line"></span><br><span class="line">fastcgi_busy_buffers_size 256k;</span><br></pre></td></tr></table></figure>
<p>reload nginx即可 </p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>我是如何用IDEA调试BUG的？</title>
    <url>/p/8644.html</url>
    <content><![CDATA[<blockquote>
<p>最近小明的bug有点多，忙的连王者荣耀都顾不上玩了，导致现在不得不抽点时间研究一下作为当前大多Java程序员开发工具的IDEA DEBUG功能，以提高效率。</p>
</blockquote>
<h3 id="一、条件断点"><a href="#一、条件断点" class="headerlink" title="一、条件断点"></a>一、条件断点</h3><span id="more"></span>

<blockquote>
<p>场景：我们在遍历某个集合，期望程序在满足某些预设条件时停住，比如：沐芳老师在课堂上点名，需要在点到小明的时候暂停确认一下是否有人在帮小明答“到”！</p>
</blockquote>
<p>那沐芳老师可以这样：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200331212416.png"
                     
                ></p>
<p>右击断点旁边的小红点（断点），弹出面板，在<strong>Condition</strong>这里填入暂停条件（返回boolean类型，一定要遵守语法哈），这样调试时，当程序满足条件时就会稳稳地停在<code>&quot;小明&quot;.equals(student)</code>的位置。</p>
<h3 id="二、回到”过去”"><a href="#二、回到”过去”" class="headerlink" title="二、回到”过去”"></a>二、回到”过去”</h3><blockquote>
<p>场景：人非圣贤，孰能无过。在日常开发中，大家都有手残的时候，比如在调试一个业务逻辑比较复杂，有多个方法嵌套时，一不小心手抖，断点过去了，这该怎么办？</p>
</blockquote>
<p>这天，沐芳老师如往常一样在上课前点名，当点到小明的时候，不争气的小明在偷偷看喜欢的妹子，没有注意听，当反应过来时，已经错过了答到！十分懊悔（红颜祸水啊），这时小明就可以借用大雄的机器猫进行时光穿梭：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200329231627.png"
                     
                ></p>
<p>观察上图，我们看到，按照点名顺序，现在沐芳老师点名已经轮到小红，小明已经错过答到，机器猫可以这样帮助小明：点击上图红色框框圈中的<strong>Drop Frame</strong>图标（如果存在多个方法的嵌套调用，可以多点几下），就这样，小明穿越了，没有错过这次的答到：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200329231834.png"
                     
                ></p>
<p><strong>tips</strong>:这个按钮之所以叫做<strong>Drop Frame</strong>，是因为<strong>JVM</strong>内部是以<strong>栈帧</strong>为单位来保存线程的运行状态，<strong>Drop Frame</strong>直译过来就是扔掉当前运行的栈帧，回到上一帧的位置，这样就实现了穿越。</p>
<h3 id="三、多线程调试"><a href="#三、多线程调试" class="headerlink" title="三、多线程调试"></a>三、多线程调试</h3><blockquote>
<p>终于老师点名结束了，现在可以正常上课了。到了同学们最爱的老师提问，同学们抢答的环节。</p>
</blockquote>
<p>As we know 当我们启动多个线程时，哪个线程内的程序先执行，完全靠CPU的心情（爸爸一样的存在），这样就会造成一个问题：无法像单线程那样按照执行顺序debug。现象就是你只管打断点，线程之间不乱跳算我输，程序举例如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200329233500.png"
                     
                ></p>
<p>老师提出问题后，四个同学开始抢答：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200329235936.png"
                     
                ></p>
<p>这么多同学抢答，让坚守岗位30多年的沐芳老师觉得再这样下去课堂可能会有点混乱：但这并难不倒从业30多年的沐芳老师，她按如下图所示：在断点的位置上右击，选择<strong>Thread</strong>，就可以有目的地跟踪某一位同学的抢答情况（一切都在掌握之中）。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200330000443.png"
                     
                ></p>
<h3 id="四、远程调试"><a href="#四、远程调试" class="headerlink" title="四、远程调试"></a>四、远程调试</h3><p>大家能看到这里，小明不得不给大家介绍一个装X的技能：云调试。即本机不用启动项目，只要本机的源代码与远程服务器运行的jar包匹配，就可以在本机直接远程调试服务器上的代码！打开姿势如下：</p>
<h4 id="远程项目启动时，先允许远程调试"><a href="#远程项目启动时，先允许远程调试" class="headerlink" title="远程项目启动时，先允许远程调试"></a>远程项目启动时，先允许远程调试</h4><p>现在大多都是SpringBoot项目，因此我们在远程服务器上运行一个jar包时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -server -Xms512m -Xmx512m -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8080 -jar xiaoming.jar</span><br></pre></td></tr></table></figure>

<p>这里起作用的核心命令就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8080</span><br></pre></td></tr></table></figure>

<blockquote>
<p>远程调试从技术上讲，就是在本机与远程服务之间建立scoket通讯，所以本机要可以访问到远程服务的端口。</p>
</blockquote>
<h4 id="在idea中设置远程调试"><a href="#在idea中设置远程调试" class="headerlink" title="在idea中设置远程调试"></a>在idea中设置远程调试</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200330003106.png"
                     
                ></p>
<p>接下来我们就可以正常调试了，调试方式和本地运行服务调试无差，不信你发起一个请求，并在对应的逻辑代码中打个断点试试？</p>
<h3 id="五、临时执行表达式"><a href="#五、临时执行表达式" class="headerlink" title="五、临时执行表达式"></a>五、临时执行表达式</h3><p>再一个就是调试时，我们还可以临时执行一些表达式，点击红色框框选中的图标，然后输入你想执行的表达式，如下所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200330004714.png"
                     
                ></p>
<p>大家可以看到，小明心灵是多么脆弱，因为无法直面自己的实际年龄，再快要得到真实年龄是，偷偷的减去了7年，所以他实际年龄永远为18岁（手动滑稽）。</p>
<h3 id="六、修改变量的运行值"><a href="#六、修改变量的运行值" class="headerlink" title="六、修改变量的运行值"></a>六、修改变量的运行值</h3><p>当然，如果调试时，想动态修改变量的值，也很容易，在变量上右击，然后选择<strong>Set Value</strong>，比如简单粗暴的更改小明的年龄为18……</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200330005141.png"
                     
                ></p>
<p>以上，这就是小明近期总结的IDEA的DEBUG技巧，希望可以帮助到大家。善用上述调试技巧，相信大家撸起代码来会更加有感觉，主要体现在：今晚可以不用加班！</p>
<p>代码已经提交到Github地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming" >https://github.com/WhenCoding/coder-xiaoming<i class="fas fa-external-link-alt"></i></a><br><em>欢迎大家关注微信公众号“程序员小明”，获取更多精彩！</em></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>「实用」打造自我感觉非常漂亮的Mac终端</title>
    <url>/p/37910.html</url>
    <content><![CDATA[<p>今天我是一个美妆博主😊</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>突然发现自己使用的iterm2终端样式有些朴素，为了让她看起来花枝招展的，我决定给她打扮打扮。毕竟每天面对她的时间比对象还多……</p>
<h2 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211222233426.png"
                     
                ></p>
<p>因为每个人的喜好都不一样，所以放一张大家都喜欢的效果图很难，之前我很喜欢黑色主题，后来，我对浅色反倒情有独钟，现在我的开发工具idea、vscode等都是使用的浅色，据说对自己的眼睛好。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211222234632.png"
                      alt="深色"
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211222234032.png"
                      alt="浅色"
                ><br>本文的亮点就是：只告诉你设置方法，最终妆后效果由你自己的审美决定。那上面的红玫瑰和白玫瑰，你更喜欢哪个呢？评论区为你选择的玫瑰投票。</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>下面给大家详细讲一下深色主题的设置方法。</p>
<h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h3><blockquote>
<p><a class="link"   href="https://ohmyz.sh/" >oh-my-zsh<i class="fas fa-external-link-alt"></i></a>:Unleash your terminal like never before.</p>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/Xnip2021-12-28_10-25-19.jpg"
                      alt="oh-my-zsh-logo"
                ><br>oh-my-zsh 是一款社区驱动的命令行工具，正如它的主页所说，oh-my-zsh是一种生活方式。它基于 zsh 命令行，提供了主题配置，插件机制，内置的便捷操作，给我们一种全新使用命令行的方式。所以，安装oh-my-zsh前提条件：<strong>必须安装 zsh</strong>，好像是一句废话。目前来看macOS系统默认推荐的命令行就是zsh。如果你默认的命令行不是zsh，可以执行以下命令进行更换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<p>zsh准备好之后，我们就可以正式开始安装使用oh-my-zsh啦，下面有两种方式可供参考：</p>
<ul>
<li>方式一（极力推荐）<br>通过命令行下载安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二<br>（如果方式一无法安装，再尝试该方式）<br>1、<a class="link"   href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh" >点击下载<i class="fas fa-external-link-alt"></i></a>该脚本；<br>2、然后执行<code>install.sh</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>

<h3 id="安装美化神器：Powerline"><a href="#安装美化神器：Powerline" class="headerlink" title="安装美化神器：Powerline"></a>安装美化神器：Powerline</h3><p>安装完oh-my-zsh，我们重启终端，此时的终端在输入命令时，已经美色侧漏，为了让她变得更华丽，我们继续化妆。</p>
<blockquote>
<p><a class="link"   href="https://powerline.readthedocs.io/en/latest/overview.html" >Powerline<i class="fas fa-external-link-alt"></i></a>:一款比较酷炫的状态栏工具，可以美化终端和vim界面。</p>
</blockquote>
<p>这款组件由python开发，因此我们需要本地有python及pip环境，安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install powerline-status</span><br></pre></td></tr></table></figure>

<p>（如果你是pip3，可能需要将pip替换为pip3来安装）<br>安装过后，为了字体样式更加<strong>beautiful</strong>，我们需要安装Powerline的<a class="link"   href="https://github.com/powerline/fonts" >字体库<i class="fas fa-external-link-alt"></i></a>，官方提供的安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># clone</span><br><span class="line">git clone https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"># install</span><br><span class="line">cd fonts</span><br><span class="line">./install.sh</span><br><span class="line"># clean-up a bit</span><br><span class="line">cd ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure>

<h3 id="iterm2更换字体"><a href="#iterm2更换字体" class="headerlink" title="iterm2更换字体"></a>iterm2更换字体</h3><p>字体包安装完成后，我们就需要更改iterm2的字体库，因为一些界面样式，使用系统默认自带的字体会发生乱码。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223104510.png"
                      alt="更改iterm2字体"
                ><br>我们搜索<strong>meslo</strong>，选择合适的字体大小（S L M）。同样的，我们使用的其他IDE终端也需要更改，比如mac自带的终端、idea、vscode，否则也会乱码，具体步骤可以查看文末，这里我们着重讲一下Iterm2的配置。</p>
<h3 id="Iterm2更换配色"><a href="#Iterm2更换配色" class="headerlink" title="Iterm2更换配色"></a>Iterm2更换配色</h3><p>如下图所示，总有你喜欢的配色，当然你还可以去官网下载导入<a class="link"   href="https://iterm2colorschemes.com/" >更多配色<i class="fas fa-external-link-alt"></i></a><br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223140927.png"
                      alt="Iterm2更换配色"
                ></p>
<h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>oh-my-zsh内置了很多主题，在目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/themes</span><br></pre></td></tr></table></figure>
<p>我当前使用的自带的是<strong>agnoster</strong>主题，我们可以直接配置。用vim编辑器打开当前用户目录下隐藏文件.zshrc，将<code>ZSH_THEME</code>后面字段改为<strong>agnoster</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223142913.png"
                      alt="更换专题agnoster"
                ><br>重新打开iTerm2即可看到最新妆后效果，当然也可以查看<a class="link"   href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" >更多主题<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="设置语法高亮"><a href="#设置语法高亮" class="headerlink" title="设置语法高亮"></a>设置语法高亮</h2><p>继续化妆，我们可以直接使用homebrew安装<a class="link"   href="https://github.com/zsh-users/zsh-syntax-highlighting" >zsh-syntax-highlighting<i class="fas fa-external-link-alt"></i></a>插件，它可以突出显示命令，有助于在运行命令之前检查命令，特别是捕获语法错误，简直不要太好用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>然后在根目录下.zshrc中插入下面内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line">source ~.zsh</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里如果，我说的是如果，source 的时候有提示问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compinit:503: no such file or directory: /usr/local/share/zsh/site-functions/_brew_cask</span><br></pre></td></tr></table></figure>
<p>原因有可能就是装了brew缓存记录导致的，我们执行 <code>brew cleanup</code> 即可修正。</p>
<h2 id="代码补全插件"><a href="#代码补全插件" class="headerlink" title="代码补全插件"></a>代码补全插件</h2><p>有一些插件能让zsh变得更加酷炫！使用更加方便！比如模糊补全命令，之前我们的命令都是必须前缀命中才会补全，现在不用这么麻烦啦，直接模糊补全！</p>
<ul>
<li>智能补全：zsh-completions</li>
</ul>
<p>在oh-my-zsh存储库中克隆存储库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:=~/.oh-my-zsh/custom&#125;/plugins/zsh-completions</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>你可能在git clone github仓库时，会遇到<strong>SSL_ERROR_SYSCALL</strong>相关错误，但浏览器可以正常访问github，那是因为clone请求需要LibreSSL来进行加密，但是环境没有curl-openssl模块，所以我们可以使用homebrew来安装该模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install curl-openssl</span><br></pre></td></tr></table></figure>

<p>安装成功后即可正常加密请求github仓库资源（如果不行的话来打我）。<br>修改.zshrc文件，找到plugins，更新内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git zsh-completions)</span><br></pre></td></tr></table></figure>

<ul>
<li>历史命令补全：zsh-autosuggestions<br>安装完这个命令，你会惊奇的发现，在敲击一些命令的时候，会自动提示你的历史命令！<br><a class="link"   href="https://github.com/zsh-users/zsh-autosuggestions" >官方文档<i class="fas fa-external-link-alt"></i></a>提供的zsh-autosuggestions安装步骤</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p>Add the plugin to the list of plugins for Oh My Zsh to load (inside ~/.zshrc):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=( </span><br><span class="line">    # other plugins...</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Start a new terminal session.</p>
<p>就不翻译了，大家照着做就可以体验一下智能推荐的历史命令补全，点击方向键<code>-&gt;</code>即可补全，屡试不爽！（不过，我试用过后发现不是很实用，反而会不方便，于是，就在配置中取消了）大家各有所需，可以自由选择。</p>
<h2 id="Iterm2水印"><a href="#Iterm2水印" class="headerlink" title="Iterm2水印"></a>Iterm2水印</h2><p>Iterm2还可以有更多个性化的设置，比如我们可以将远端服务器的连接信息放到profiles里面，然后通过快捷键直接连上远端服务器，这样就不用自己手动写命令，很是方便。但是这样会有一个问题，当有多个远端服务器的时候，我们不知道当前是在哪一个服务器上面。这该如何优雅解决呢？<br>我来告诉你，iterm2支持在终端添加一个自定义的水印来显示当前的位置！设置方式如下图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223171122.png"
                      alt="badge"
                ><br>效果就是右上角有水印可以标注我们现在访问的是哪一个服务器。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223171300.png"
                     
                ></p>
<h2 id="效果图中笑脸😀的配置"><a href="#效果图中笑脸😀的配置" class="headerlink" title="效果图中笑脸😀的配置"></a>效果图中笑脸😀的配置</h2><p>细心的朋友会发现，我的终端左侧有一个笑脸，这是因为，我想告诉大家：我们面对bug要保持微笑、乐观的心态，设置方法如下:<br>我们进入主题目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/themes</span><br></pre></td></tr></table></figure>

<p>编辑当前使用的主题：<strong>agnoster</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim agnoster.zsh-theme</span><br></pre></td></tr></table></figure>

<p>找到<strong>prompt_context</strong>，按照下图增加表情：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223172419.png"
                      alt="表情符号"
                ></p>
<h2 id="字体乱码"><a href="#字体乱码" class="headerlink" title="字体乱码"></a>字体乱码</h2><p>细心的朋友还会发现，自带的终端、idea、vscode会出现字体乱码的现象，解决办法就是通过更换字体包来支持这些特殊符号。</p>
<ul>
<li>自带终端</li>
</ul>
<p>打开terminal的偏好设置修改字体包为<strong>Meslo</strong>：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223172845.png"
                      alt="terminal"
                ><br>正常效果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223173019.png"
                      alt="正常效果"
                ></p>
<ul>
<li>vscode </li>
</ul>
<p>同理，我们也需要修改vscode的字体包为<strong>Meslo</strong><br>打开vscode的设置，然后搜索<code>terminal font</code>修改如下图所示:<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223173347.png"
                      alt="terminal font"
                ></p>
<ul>
<li>idea</li>
</ul>
<p>再同理，我们也需要修改idea的字体包为<strong>Meslo</strong><br>打开idea的设置，然后搜索<code>console font</code> 修改如下图:<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211223173516.png"
                      alt="idea的设置"
                ></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>文中提到的跳转链接总结如下：</p>
<ul>
<li>Powerline：<a class="link"   href="https://powerline.readthedocs.io/en/latest/overview.html" >https://powerline.readthedocs.io/en/latest/overview.html<i class="fas fa-external-link-alt"></i></a></li>
<li>Powerline 字体库：<a class="link"   href="https://github.com/powerline/fonts" >https://github.com/powerline/fonts<i class="fas fa-external-link-alt"></i></a></li>
<li>Iterm2更多配色：<a class="link"   href="https://iterm2colorschemes.com/" >https://iterm2colorschemes.com/<i class="fas fa-external-link-alt"></i></a></li>
<li>oh-my-zsh更多主题：<a class="link"   href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" >https://github.com/ohmyzsh/ohmyzsh/wiki/Themes<i class="fas fa-external-link-alt"></i></a></li>
<li>zsh-syntax-highlighting官方文档：<a class="link"   href="https://github.com/zsh-users/zsh-syntax-highlighting" >https://github.com/zsh-users/zsh-syntax-highlighting<i class="fas fa-external-link-alt"></i></a></li>
<li>zsh-autosuggestions官方文档：<a class="link"   href="https://github.com/zsh-users/zsh-autosuggestions" >https://github.com/zsh-users/zsh-autosuggestions<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>当我们费劲千辛万苦终于搞定终端的样式后，你会发现这一切努力都是值得的！因为她现在不仅像花瓶一样好看，而且变得比以前更加实用！你更加离不开她啦！</p>
<p>请大家持续关注微信公众号：<strong>程序员小明</strong>！！！一个非著名程序员的日常。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ><br>PS:配置过程中有遇到文中没提到的问题，欢迎讨论！</p>
]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>Iterm2</tag>
        <tag>Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>小明收藏的利器</title>
    <url>/p/a8a6.html</url>
    <content><![CDATA[<h2 id="在线工具全览"><a href="#在线工具全览" class="headerlink" title="在线工具全览"></a>在线工具全览</h2><p><a class="link"   href="https://www.toolnb.com/"  title="想要的都有">https://www.toolnb.com/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="免费的图片上传获取链接"><a href="#免费的图片上传获取链接" class="headerlink" title="免费的图片上传获取链接"></a>免费的图片上传获取链接</h2><p><a class="link"   href="https://zh-cn.imgbb.com/"  title="上传与分享您的照片">https://zh-cn.imgbb.com/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="MarkDown样式自由转换"><a href="#MarkDown样式自由转换" class="headerlink" title="MarkDown样式自由转换"></a>MarkDown样式自由转换</h2><ul>
<li>在线使用：<a class="link"   href="http://md.aclickall.com/"  title="力荐">http://md.aclickall.com/<i class="fas fa-external-link-alt"></i></a></li>
<li>在线使用：<a class="link"   href="https://md.rmiao.top/"  title="同上">https://md.rmiao.top/<i class="fas fa-external-link-alt"></i></a></li>
<li>浏览器插件 Markdown here<h2 id="好用的图标"><a href="#好用的图标" class="headerlink" title="好用的图标"></a>好用的图标</h2></li>
<li><a class="link"   href="https://imgchr.com/"  title="支持html、markdown、BBCode等格式！（力荐）">https://imgchr.com/<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.iconfont.cn/"  title="应有尽有哦">https://www.iconfont.cn<i class="fas fa-external-link-alt"></i></a><h2 id="自学python书籍推荐《自学是门手艺》"><a href="#自学python书籍推荐《自学是门手艺》" class="headerlink" title="自学python书籍推荐《自学是门手艺》"></a>自学python书籍推荐《自学是门手艺》</h2>github地址: <a class="link"   href="https://github.com/selfteaching/the-craft-of-selfteaching"  title="自学是门手艺">https://github.com/selfteaching/the-craft-of-selfteaching<i class="fas fa-external-link-alt"></i></a><h2 id="抢票必备"><a href="#抢票必备" class="headerlink" title="抢票必备"></a>抢票必备</h2></li>
<li>windows:<a class="link"   href="https://www.bypass.cn/" >https://www.bypass.cn/<i class="fas fa-external-link-alt"></i></a></li>
<li>mac：这个需要使用python开源项目<a class="link"   href="https://github.com/testerSunshine/12306" >https://github.com/testerSunshine/12306<i class="fas fa-external-link-alt"></i></a><h2 id="缩短你的网址"><a href="#缩短你的网址" class="headerlink" title="缩短你的网址"></a>缩短你的网址</h2></li>
<li>虽然类似的有好多，但是只有微博的更强大：<a class="link"   href="http://dwz.wailian.work/" >http://dwz.wailian.work/<i class="fas fa-external-link-alt"></i></a><h2 id="表格转换"><a href="#表格转换" class="headerlink" title="表格转换"></a>表格转换</h2>支持makdown、IDEA、CSV、JSON、xml、yaml、sql、html、excel、latex、T TEXT相互转换</li>
<li><a class="link"   href="https://tableconvert.com/"  title="真心爽">https://tableconvert.com/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>每次用IDEA打开项目都要你输入SVN账号密码?</title>
    <url>/p/42197.html</url>
    <content><![CDATA[<p>😌 开发就要舒舒服服的</p>
<span id="more"></span>
<p>有一次把brew卸载重新安装了，导致svn也要重新安装，重新安装完以后发现IDEA中每次打开使用svn就要输入一次密码。这样太麻烦了。<br>虽然点了记住密码，但是每次打开项目都要输入密码。这样很浪费时间！根本不能忍！<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240118164646.png"
                      alt="20240118164646"
                ></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p>打开钥匙串访问<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240118164700.png"
                      alt="20240118164700"
                ></p>
</li>
<li><p>搜索svn并鼠标双击条目<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240118164714.png"
                      alt="20240118164714"
                ></p>
</li>
<li><p>访问控制：允许所有应用程序访问此项目<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240118164731.png"
                      alt="20240118164731"
                ></p>
</li>
</ul>
<p>我这里偷懒了，简单粗暴，允许所有应用程序访问此项目。你也可以设置成你想允许访问的程序名单。如下这样：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240118164743.png"
                      alt="20240118164743"
                ></p>
<p>这里的这个svn命令比较难选到，可以做个软链接方便选择，每个人的安装路径可能也会不同。这里就不介绍了。<br>做完这几步我的IDEA已经不需要我在输入密码了。教程结束！</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>日常开发</tag>
      </tags>
  </entry>
  <entry>
    <title>公众号开发入门：查询用户是否已经关注公众号？</title>
    <url>/p/d69c.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> 最近，小明在参与app改版时，有一个业务场景是：用户完成指定的任务，判断当前登录用户是否已经关注指定的官方微信公众号，如果关注会获得相应的奖励，为了弥补语言的匮乏，小明偷偷给大家上张图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/PMmYvfz/image.png"
                      alt="app截图"
                ></p>
<span id="more"></span>
<p>众所周知，我们程序员第一次接收到之前没做过的需求时，第一步肯定离不开搜查资料（我觉得国内的产品，百度就够用），小明也不例外，花了大概五分钟，一切就了然于胸，由此可见，程序员的<strong>搜商</strong>很重要 😂。ok，废话少说，翠花，上菜！。</p>
<h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2><ul>
<li>微信公众平台-开发-基本配置-成为开发者，得到 <code>appId</code> 和 <code>appSecret</code>（注意：<code>appSecret</code>只展示一次，需保存下来，否则需要重置获取），</li>
<li>添加ip白名单，这个是为了提高公众平台开发者接口调用的安全性，避免一旦开发者ID和密码泄露后给帐号造成损失。对调用“获取<code>access_token</code>”接口增加IP白名单校验：只有将IP地址设置为公众号的IP白名单，才能成功调用该接口。</li>
<li>微信认证通过，拥有获取用户基本信息的权限（注意：如果帐号主体为个人，是无法开通微信认证的）；</li>
</ul>
<h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grant_type</td>
<td>是</td>
<td>获取access_token填写client_credential</td>
</tr>
<tr>
<td>appid</td>
<td>是</td>
<td>第三方用户唯一凭证</td>
</tr>
<tr>
<td>secret</td>
<td>是</td>
<td>第三方用户唯一凭证密钥，即appsecret</td>
</tr>
</tbody></table>
<h4 id="返回说明"><a href="#返回说明" class="headerlink" title="返回说明"></a>返回说明</h4><p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>access_token</td>
<td>获取到的凭证</td>
</tr>
<tr>
<td>expires_in</td>
<td>凭证有效时间，单位：秒</td>
</tr>
</tbody></table>
<p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为AppID无效错误）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errcode&quot;:40013,&quot;errmsg&quot;:&quot;invalid appid&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回码说明"><a href="#返回码说明" class="headerlink" title="返回码说明"></a>返回码说明</h4><table>
<thead>
<tr>
<th>返回码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>系统繁忙，此时请开发者稍候再试</td>
</tr>
<tr>
<td>0</td>
<td>请求成功</td>
</tr>
<tr>
<td>40001</td>
<td>AppSecret错误或者AppSecret不属于这个公众号，请开发者确认AppSecret的正确性</td>
</tr>
<tr>
<td>40002</td>
<td>请确保grant_type字段值为client_credential</td>
</tr>
<tr>
<td>40164</td>
<td>调用接口的IP地址不在白名单中，请在接口IP白名单中进行设置。（小程序及小游戏调用不要求IP地址在白名单内。）</td>
</tr>
</tbody></table>
<p>详情查看官方文档-获取access_token： <a class="link"   href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" >https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="获取用户openId或者unionId"><a href="#获取用户openId或者unionId" class="headerlink" title="获取用户openId或者unionId"></a>获取用户openId或者unionId</h3><p>在关注者与公众号产生<strong>消息交互后</strong>，公众号可获得关注者的OpenID（说明：OpenID就是加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。特别需要注意的是，如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号，用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。因此,如果要判断当前登陆app的微信用户是否关注官方微信公众号，我们要使用的是unionId。需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<h3 id="根据前两个步骤获得的信息（access-token和openId或者unionId），调用微信接口获取用户基本信息"><a href="#根据前两个步骤获得的信息（access-token和openId或者unionId），调用微信接口获取用户基本信息" class="headerlink" title="根据前两个步骤获得的信息（access_token和openId或者unionId），调用微信接口获取用户基本信息"></a>根据前两个步骤获得的信息（access_token和openId或者unionId），调用微信接口获取用户基本信息</h3><p>完整的用户基本信息包括昵称、头像、性别、所在城市、语言和关注时间等。<br>接口调用请求说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</span><br></pre></td></tr></table></figure>

<h4 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>access_token</td>
<td>是</td>
<td>调用接口凭证</td>
</tr>
<tr>
<td>openid</td>
<td>是</td>
<td>普通用户的标识，对当前公众号唯一</td>
</tr>
<tr>
<td>lang</td>
<td>否</td>
<td>返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语</td>
</tr>
</tbody></table>
<h4 id="返回说明-1"><a href="#返回说明-1" class="headerlink" title="返回说明"></a>返回说明</h4><p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;subscribe&quot;: 1, //这就是我们想要的值哈，解释如下表格</span><br><span class="line">    &quot;openid&quot;: &quot;o6_bmjrPTlm6_2sgVt7hMZOPfL2M&quot;, </span><br><span class="line">    &quot;nickname&quot;: &quot;Band&quot;, </span><br><span class="line">    &quot;sex&quot;: 1, </span><br><span class="line">    &quot;language&quot;: &quot;zh_CN&quot;, </span><br><span class="line">    &quot;city&quot;: &quot;广州&quot;, </span><br><span class="line">    &quot;province&quot;: &quot;广东&quot;, </span><br><span class="line">    &quot;country&quot;: &quot;中国&quot;, </span><br><span class="line">    &quot;headimgurl&quot;:&quot;http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span><br><span class="line">    &quot;subscribe_time&quot;: 1382694957,</span><br><span class="line">    &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">    &quot;remark&quot;: &quot;&quot;,</span><br><span class="line">    &quot;groupid&quot;: 0,</span><br><span class="line">    &quot;tagid_list&quot;:[128,2],</span><br><span class="line">    &quot;subscribe_scene&quot;: &quot;ADD_SCENE_QR_CODE&quot;,</span><br><span class="line">    &quot;qr_scene&quot;: 98765,</span><br><span class="line">    &quot;qr_scene_str&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>subscribe</td>
<td><strong>用户是否订阅该公众号标识，值为0时，代表此用户没有关注该公众号，拉取不到其余信息。</strong></td>
</tr>
<tr>
<td>openid</td>
<td>用户的标识，对当前公众号唯一</td>
</tr>
<tr>
<td>nickname</td>
<td>用户的昵称</td>
</tr>
<tr>
<td>sex</td>
<td>用户的性别，值为1时是男性，值为2时是女性，值为0时是未知</td>
</tr>
<tr>
<td>city</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>……</td>
<td></td>
</tr>
</tbody></table>
<p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为AppID无效错误）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errcode&quot;:40013,&quot;errmsg&quot;:&quot;invalid appid&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>详情查看官方文档-获取用户基本信息 <a class="link"   href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839" >https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839<i class="fas fa-external-link-alt"></i></a></p>
<p>好了，以上就是今天小明整理给大家的有关公众号开发的文档。欢迎大家多多交流学习。</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>日常开发</category>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>【面试】最容易被问到的N种排序算法！</title>
    <url>/p/7836.html</url>
    <content><![CDATA[<blockquote>
<p>面试官：小明，是吧？你都知道哪些排序算法，哪几种是稳定排序？<br>小明：这个我有总结！</p>
</blockquote>
<h1 id="关于排序稳定性的定义"><a href="#关于排序稳定性的定义" class="headerlink" title="关于排序稳定性的定义"></a>关于排序稳定性的定义</h1><p>通俗地讲就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<h1 id="现实生活中稳定排序如何表现呢？"><a href="#现实生活中稳定排序如何表现呢？" class="headerlink" title="现实生活中稳定排序如何表现呢？"></a>现实生活中稳定排序如何表现呢？</h1><blockquote>
<p>举个例子：<br>某次学校发奖学金，只有排在前三个的有奖，结果一排序把原来在第三位的并列第三名给弄到第四位了，他估计不会乐意😂</p>
</blockquote>
<p>接下来给大家用java代码演绎一下常见的几种排序，前提：有一个数组arr，要求从小到大排序。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>简单选择排序的思想是：从第一个位置开始，逐渐向后，选择后面的无序序列中的最小值放到该位置。很简单，直接上代码吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//选择排序</span><br><span class="line">for(int i = 0; i &lt; arr.length - 1; i++) &#123;// 做第i趟排序</span><br><span class="line">    int k = i;</span><br><span class="line">    for(int j = k + 1; j &lt; arr.length; j++)&#123;// 选最小的记录</span><br><span class="line">        if(arr[j] &lt; arr[k])&#123; </span><br><span class="line">            k = j; //记下目前找到的最小值所在的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span><br><span class="line">    if(i != k)&#123;  //交换a[i]和a[k]</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[k];</span><br><span class="line">        arr[k] = temp;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那选择排序是稳定排序吗？"><a href="#那选择排序是稳定排序吗？" class="headerlink" title="那选择排序是稳定排序吗？"></a>那选择排序是稳定排序吗？</h2><blockquote>
<p>举个例子，假如有序列[5,8,5,2,9]按从小到大排序，第一遍排序,第一个元素“5”会和第四个元素“2”交换，那么原序列中两个“5”的相对前后顺序此时就遭到破坏了，由此可见，选择排序不是一个稳定的排序算法。</p>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序就是相邻的两个元素之间按照要求进行比较交换，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 冒泡排序</span><br><span class="line">for (int i = 0; i &lt; arr.length - 1; i++) &#123; //外层循环n-1</span><br><span class="line">    for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; //内层循环n-i-1</span><br><span class="line">        if (arr[j] &gt; arr[j + 1]) &#123; //从第一个开始，往后两两比较大小，如果前面的比后面的大，交换位置</span><br><span class="line">            int tmp = arr[j];</span><br><span class="line">            arr[j] = arr[j + 1];</span><br><span class="line">            arr[j + 1] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那冒泡排序是稳定排序吗？"><a href="#那冒泡排序是稳定排序吗？" class="headerlink" title="那冒泡排序是稳定排序吗？"></a>那冒泡排序是稳定排序吗？</h2><p>因为发生在相邻的元素之间，所以，如果两个元素相等，我们是不会多此一举把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定</strong>排序算法。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 插入排序</span><br><span class="line">for (int index = 1; index &lt; length; index++) &#123; //外层向右的index，即作为比较对象的数据的index</span><br><span class="line">    int temp = arr[index]; //用作比较的数据</span><br><span class="line">    int leftindex = index - 1;</span><br><span class="line">    while (leftindex &gt;= 0 &amp;&amp; arr[leftindex] &gt; temp) &#123; //当比到最左边或者遇到比temp小的数据时，结束循环</span><br><span class="line">        arr[leftindex + 1] = arr[leftindex];</span><br><span class="line">        leftindex--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[leftindex + 1] = temp;//把temp放到空位上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，左边会产生一个只有一个元素的有序序列，比较是从该有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。</p>
<h2 id="那插入排序是稳定排序吗？"><a href="#那插入排序是稳定排序吗？" class="headerlink" title="那插入排序是稳定排序吗？"></a>那插入排序是稳定排序吗？</h2><p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序有两个方向，左边的i下标一直往右走，当<code>a[i] &lt;= a[center_index]</code>，其中<code>center_index</code>是中枢元素的数组下标，一般取为数组<strong>第0个元素</strong>。而右边的j下标一直往左走，当<code>a[j] &gt; a[center_index]</code>。如果i和j都走不动了，<code>i &lt;= j</code>，交换<code>a[i]</code>和<code>a[j]</code>,重复上面的过程，直到<code>i &gt; j</code>。 交换<code>a[j]</code>和<code>a[center_index]</code>，完成一趟快速排序。在中枢元素和<code>a[j]</code>交换的时候，很有可能把前面的元素的稳定性打乱，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">public static void sort(int[] a, int low, int height) &#123;</span><br><span class="line">        int i = low;</span><br><span class="line">        int j = height;</span><br><span class="line">        if (i &gt; j) &#123;    //放在k之前，防止下标越界</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = a[i];</span><br><span class="line">        while (i &lt; j) &#123;   </span><br><span class="line">            while (i &lt; j &amp;&amp; a[j] &gt; k) &#123;    //找出小的数</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i &lt; j &amp;&amp; a[i] &lt;= k) &#123;  //找出大的数</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;   //交换</span><br><span class="line">                int swap = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = swap;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        //交换K</span><br><span class="line">        k = a[i];</span><br><span class="line">        a[i] = a[low];</span><br><span class="line">        a[low] = k;</span><br><span class="line">        //对左边进行排序,递归算法</span><br><span class="line">        sort(a, low, i - 1);</span><br><span class="line">        //对右边进行排序</span><br><span class="line">        sort(a, i + 1, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="那快速排序是稳定排序吗？"><a href="#那快速排序是稳定排序吗？" class="headerlink" title="那快速排序是稳定排序吗？"></a>那快速排序是稳定排序吗？</h2><blockquote>
<p>比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第五个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
</blockquote>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 归并排序</span><br><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = &#123;11,44,23,67,88,65,34,48,9,12&#125;;</span><br><span class="line">		int[] tmp = new int[arr.length];    //新建一个临时数组存放</span><br><span class="line">		mergeSort(arr,0,arr.length-1,tmp);</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void merge(int[] arr,int low,int mid,int high,int[] tmp)&#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		int j = low,k = mid+1;  //左边序列和右边序列起始索引</span><br><span class="line">		while(j &lt;= mid &amp;&amp; k &lt;= high)&#123;</span><br><span class="line">			if(arr[j] &lt; arr[k])&#123;</span><br><span class="line">				tmp[i++] = arr[j++];</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				tmp[i++] = arr[k++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//若左边序列还有剩余，则将其全部拷贝进tmp[]中</span><br><span class="line">		while(j &lt;= mid)&#123;    </span><br><span class="line">			tmp[i++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		while(k &lt;= high)&#123;</span><br><span class="line">			tmp[i++] = arr[k++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int t=0;t&lt;i;t++)&#123;</span><br><span class="line">			arr[low+t] = tmp[t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public static void mergeSort(int[] arr,int low,int high,int[] tmp)&#123;</span><br><span class="line">		if(low&lt;high)&#123;</span><br><span class="line">			int mid = (low+high)/2;</span><br><span class="line">			mergeSort(arr,low,mid,tmp); //对左边序列进行归并排序</span><br><span class="line">			mergeSort(arr,mid+1,high,tmp);  //对右边序列进行归并排序</span><br><span class="line">			merge(arr,low,mid,high,tmp);    //合并两个有序序列</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那归并排序是稳定排序吗？"><a href="#那归并排序是稳定排序吗？" class="headerlink" title="那归并排序是稳定排序吗？"></a>那归并排序是稳定排序吗？</h2><p>可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是<strong>稳定</strong>的排序算法。</p>
<h1 id="基数排序（又称桶子法）"><a href="#基数排序（又称桶子法）" class="headerlink" title="基数排序（又称桶子法）"></a>基数排序（又称桶子法）</h1><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/21/Vxw1G4.gif"
                      alt="桶子法动画"
                ></p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 基数排序（又称桶子法）</span><br><span class="line">public static void myRadixSort(int[] arr) &#123;</span><br><span class="line">    int max = 0;</span><br><span class="line">//        找到最大的数</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//        获取最大数的位数</span><br><span class="line">    int times = 0;</span><br><span class="line">    while (max &gt; 0) &#123;</span><br><span class="line">        max = max / 10;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">//        创建一个二维的list</span><br><span class="line">    List&lt;ArrayList&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//  创建10个list（每一位有从0到9，一共10个数，每个list数组用来存放每次迭代中，0-9 每个数组中需要装入的数）</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        ArrayList list1 = new ArrayList();</span><br><span class="line">        //在二维数组中把这10个数组加进去，相当于二维数组的行，从0-9的行</span><br><span class="line">        list.add(list1);</span><br><span class="line">    &#125;</span><br><span class="line">//        进行times次分配和收集</span><br><span class="line">    for (int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">//            分配</span><br><span class="line">        for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            int x = arr[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i);</span><br><span class="line">            // list.get(x) 是在返回第0的这个行的list上面的数，然后再 add(arr[j]) 是把当前的这个数添加到末尾去</span><br><span class="line">            list.get(x).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">//            收集        ------------&gt;   把这0-9共10个list里面的数值存到一个数组里面</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            while (list.get(j).size() &gt; 0) &#123;</span><br><span class="line">                // 把list这个二维list中的第j行返回并赋值给list2</span><br><span class="line">                ArrayList&lt;Integer&gt; list2 = list.get(j);</span><br><span class="line">                //  把list2这个数组中的第0个位置的元素，赋值给arr[count]         </span><br><span class="line">                arr[count] = list2.get(0);</span><br><span class="line">                //   把list2这个数组中的第0个位置的元素删除掉，则后面的元素会自动移上来                      </span><br><span class="line">                list2.remove(0);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那基数排序是稳定排序吗？"><a href="#那基数排序是稳定排序吗？" class="headerlink" title="那基数排序是稳定排序吗？"></a>那基数排序是稳定排序吗？</h2><p>由上可得，基数排序基于分别排序，分别收集，所以其是稳定的<strong>排序算法</strong>。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序是按照不同步长对元素进行<strong>插入排序</strong>，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高，所以，希尔排序的时间复杂度会比O(n^2)好一些。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 希尔排序</span><br><span class="line">int incrementNum = arr.length / 2;</span><br><span class="line">while (incrementNum &gt;= 1) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        //进行插入排序</span><br><span class="line">        for (int j = i; j &lt; arr.length - incrementNum; j = j + incrementNum) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + incrementNum]) &#123;</span><br><span class="line">                int temple = arr[j];</span><br><span class="line">                arr[j] = arr[j + incrementNum];</span><br><span class="line">                arr[j + incrementNum] = temple;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置新的增量</span><br><span class="line">    incrementNum = incrementNum / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="那希尔排序是稳定排序吗？"><a href="#那希尔排序是稳定排序吗？" class="headerlink" title="那希尔排序是稳定排序吗？"></a>那希尔排序是稳定排序吗？</h2><p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><a class="link"   href="https://www.cnblogs.com/chengxiao/p/6129630.html" >堆排序<i class="fas fa-external-link-alt"></i></a>的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了,代码举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 堆排序</span><br><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    //1.构建大顶堆</span><br><span class="line">    for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        //从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">    for (int j = arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">        swap(arr, 0, j);//将堆顶元素与末尾元素进行交换</span><br><span class="line">        adjustHeap(arr, 0, j);//重新对堆进行调整</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="line">*</span><br><span class="line">* @param arr</span><br><span class="line">* @param i</span><br><span class="line">* @param length</span><br><span class="line">*/</span><br><span class="line">public static void adjustHeap(int[] arr, int i, int length) &#123;</span><br><span class="line">    int temp = arr[i];//先取出当前元素i</span><br><span class="line">    for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123;//从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">        if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;//如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr[k] &gt; temp) &#123;//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;//将temp值放到最终的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 交换元素</span><br><span class="line">*</span><br><span class="line">* @param arr</span><br><span class="line">* @param a</span><br><span class="line">* @param b</span><br><span class="line">*/</span><br><span class="line">public static void swap(int[] arr, int a, int b) &#123;</span><br><span class="line">    int temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那堆排序是稳定排序吗？"><a href="#那堆排序是稳定排序吗？" class="headerlink" title="那堆排序是稳定排序吗？"></a>那堆排序是稳定排序吗？</h2><p>我们知道堆的结构是节点i的孩子为<code>2 * i</code>和<code>2 * i + 1</code>节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第<code>n / 2</code>开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为<code>n / 2 - 1， n / 2 - 2， ... 1</code>这些个父节点选择元素时，就会破坏稳定性。有可能第<code>n / 2</code>个父节点交换把后面一个元素交换过去了，而第<code>n / 2 - 1</code>个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>不稳定的排序: 选择排序、快速排序、希尔排序、堆排序</li>
<li>稳定排序：冒泡排序、插入排序、归并排序、基数排序</li>
</ul>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的简历到底该怎么写？</title>
    <url>/p/6d2.html</url>
    <content><![CDATA[<blockquote>
<p>小明最近有换工作的打算，那身为程序员的我们，简历到底应该怎么写呢？</p>
</blockquote>
<p>我们知道，HR在筛选简历时主要从公司需求出发，重点不一，不过还是有很多“通用”的套路，为了在30秒内判断出这份简历是否值得跟进，我认为程序员写简历的正确姿势是这样的：</p>
<h1 id="主要风格"><a href="#主要风格" class="headerlink" title="主要风格"></a>主要风格</h1><p>即首次看到简历后的第一感觉。就好比小明多年相亲未遂，鼓起勇气参加“非诚勿扰”的节目，首次登场，台下的妹子看见他的第一眼，一定会有一个整体的Feel，他是fashion的、小清新的还是老道的？有了第一印象感觉之后，台下的妹子才会确定是灭灯还是亮灯（小明的话八成会是全亮的）。下面给大家举个例子：</p>
<p>加分写法：</p>
<ul>
<li><p>逻辑结构清晰，简洁明了。</p>
</li>
<li><p>字体适中，排版顺畅，清晰整齐。</p>
</li>
<li><p>DF格式，兼容性不仅强而且不易乱序。</p>
<p>减分写法：</p>
</li>
<li><p>设计的十分浮夸或者十分简单。（eg.简历做的十分酷炫、又是五颜六色，but半天找不到联系方式，抑或是只有个人基本信息和公司名称)</p>
</li>
<li><p>冗余过度，写了好多页，但是半天打不开的，更甚至加载了半天，打开还乱码！</p>
</li>
</ul>
<h1 id="基本信息（姓名-性别-毕业院校-电话-邮箱-居住地-期望地）"><a href="#基本信息（姓名-性别-毕业院校-电话-邮箱-居住地-期望地）" class="headerlink" title="基本信息（姓名/性别/毕业院校/电话/邮箱/居住地/期望地）"></a>基本信息（姓名/性别/毕业院校/电话/邮箱/居住地/期望地）</h1><p>加分写法:</p>
<ul>
<li>清晰罗列出以上信息，这样HR不仅在接下来的电话沟通或面试中不会再去追问这些内容，而且又进一步建立对你的熟悉度。</li>
<li>增加社交账号，比如QQ或者微信，防患于未然（万一有时候HR电话打不通，这种情况挺多见的）</li>
</ul>
<p>减分写法：</p>
<ul>
<li><p>相当大的基本信息没有写。</p>
</li>
<li><p>只留下一个Github链接或者博客链接，甚至极致简洁的几句描述，HR只能通过你的链接来找你的联系方式，那就难受啦。（ps：除非写的特别nice，不然基本是要放弃你了）</p>
</li>
</ul>
<h1 id="工作经历-amp-项目经历"><a href="#工作经历-amp-项目经历" class="headerlink" title="工作经历&amp;项目经历"></a>工作经历&amp;项目经历</h1><p>加分写法：</p>
<ul>
<li>工作经历项目经历可以参照万能的STAR法则来写。（STAR不清楚的童鞋自觉百度哈）</li>
<li>曾经效力过哪些公司，是否和求职公司匹配？</li>
<li>做过什么行业领域，是否和求职公司匹配？</li>
<li>你最擅长的技术语言，应用了哪些技术栈？（Java,Scala,Pyhton,Ruby, React, Vue, Microservice…）</li>
<li>经历的项目时间复杂度，及在项目中承担什么样的角色(人的变化/技术的变化/环境的变化/不同工作经历相同角色的不同点)</li>
<li>时间节点（空档期）</li>
</ul>
<p>减分写法：</p>
<ul>
<li>HR观摩了半天，不知所云，毫无亮点，没有可以继续聊一聊的话题。</li>
</ul>
<h1 id="先来几个栗子"><a href="#先来几个栗子" class="headerlink" title="先来几个栗子"></a>先来几个栗子</h1><h2 id="栗子1错误打开方式："><a href="#栗子1错误打开方式：" class="headerlink" title="栗子1错误打开方式："></a>栗子1错误打开方式：</h2><ul>
<li>XX（全栈工程师）2013.06 — 至今</li>
<li>参与需求分析及实现方案设计。</li>
<li>产品线上部署及运维。</li>
<li>负责公司配置管理，环境维护等工作</li>
<li>负责公司产品性能测试，及线上数据分析</li>
<li>设计数据库表结构，实现后台功能及web页面展示。</li>
</ul>
<p>点评：太概括不具体，没有逻辑性，甚至不知道采用的技术语言，根本不能了解情况。</p>
<h2 id="栗子2正确打开方式："><a href="#栗子2正确打开方式：" class="headerlink" title="栗子2正确打开方式："></a>栗子2正确打开方式：</h2><p>北京XXX公司 Java工程师 — 2017.2月-2018.4月<br>1、LINK推荐架构数据与缓存层设计开发</p>
<ul>
<li>LINK是一款时尚资讯app,负责推荐页面资讯feed流的展示及用户历史的展示；</li>
<li>负责进行压测监测、缓存处理,对接又进一步改进优化,主用redis缓存；</li>
<li>负责数据层,处理前端逻辑整个开发工作,分布式rpc服务搭建。</li>
</ul>
<p>2、基于JAVA的电商爬虫开发</p>
<ul>
<li>使用java搭建爬虫server平台,进行配置和开发,进行网页改版监测功能开发；</li>
<li>通过频率、ip池、匿名代理等应对一些网站的反爬；</li>
<li>爬取淘宝时尚品牌与其他电商网站商品品牌与详情等。</li>
</ul>
<p>3、同图搜索Solr服务开发</p>
<ul>
<li>基于算法组的同图策略,使用solr做java接口，又实现rpc服务搭建,进行索引构建和solr实现。</li>
<li>点评：非常清晰的告诉简历阅读者自己做了什么事情，负责了什么样的事情，用了什么技术栈，且逻辑连贯。</li>
</ul>
<h1 id="工作期望-amp-个人评价"><a href="#工作期望-amp-个人评价" class="headerlink" title="工作期望&amp;个人评价"></a>工作期望&amp;个人评价</h1><p>加分写法：</p>
<ul>
<li>对自己有一个全方位的一个描述总结，可以让他人更好的解读我们。甚至可以在此处，大笔书写你的优点特长有哪些。</li>
<li>我们可以不写个人评价，但是也一定记得写上工作期望！</li>
</ul>
<p>减分写法：</p>
<ul>
<li>丝毫看不出个性特点，写和没写没什么区别。  再 来几个栗子</li>
</ul>
<h2 id="栗子1-错误打开方式"><a href="#栗子1-错误打开方式" class="headerlink" title="栗子1 错误打开方式"></a>栗子1 错误打开方式</h2><ul>
<li>为人性格,诚实谦虚，勤奋，能吃苦耐劳，有耐心，有团队意识，能和同学和谐相处，能虚心接受别人的建议的人。</li>
<li>责任心强，善于沟通，具有良好的团队合作精神；专业扎实，具有较强的钻研精神和学习能力；性格比较乐观外向，喜欢打羽毛球。</li>
</ul>
<h2 id="栗子2正确打开方式"><a href="#栗子2正确打开方式" class="headerlink" title="栗子2正确打开方式"></a>栗子2正确打开方式</h2><ul>
<li>极客、热爱技术、热爱开源</li>
<li>Ruby on Rails：精通</li>
<li>AWS：掌握</li>
<li>Docker：掌握</li>
<li>Agile/Lean：精通</li>
<li>ReactJS：掌握</li>
</ul>
<h2 id="栗子3正确打开方式"><a href="#栗子3正确打开方式" class="headerlink" title="栗子3正确打开方式"></a>栗子3正确打开方式</h2><ul>
<li><p>我对自己的定位: 主攻前端,同时在其他方面打打辅助。我不希望过于依赖别人,即使没有后端没有设计没有产品经理,我依然想要把这个产品做到完美。毕竟全栈才能最高效地解决问题。</p>
</li>
<li><p>我对工作的态度: 第一,要高效完成自己的本职工作。第二,要在完成的基础上寻找完美。第三,要在完美的基础上,与其他同事 互相交流学习,互相提升。工作是一种生活方式,不是一份养家糊口的差事。</p>
</li>
<li><p>我怎样克服困难: 不用百度是第一原则,在遇到技术问题时我往往会去Google、Stack over flow上寻找答案。但通常很多问题 并不一定已经被人解决,所以熟练地阅读源码、在手册、规范甚至 REPL的环境自己做实验才是最终解决问题的办法。相信事实的结果,自己动手去做。</p>
</li>
<li><p>怎样保持自己的视野:我一直认为软件开发中视野极其重要,除了在 Twitter 上关注业界大牛,Github Trending 也是每周必刷。 另外 Podcast、Hacker News、Reddit 以及TechRadar 也是重要的一手资料。保持开阔视野才能找到更酷的解决方案。</p>
</li>
<li><p>我的优势: 热爱技术、自学能力强,有良好的自我认知。全面的技能树与开阔的视野,良好的心态、情商与沟通能力。</p>
</li>
<li><p>我的劣势: 非科班出身没有科班同学对算法的熟练掌握,但我决定死磕技术,弥补不足。</p>
</li>
</ul>
<h1 id="博客，个人技术栈点等"><a href="#博客，个人技术栈点等" class="headerlink" title="博客，个人技术栈点等"></a>博客，个人技术栈点等</h1><ul>
<li>看到有这项的HR两眼已经放光了，加分加分项，说明你真正的热爱技术，善于学习总结，乐于分享，且有投入自己的业余时间到软件事业中。</li>
<li>我喜欢的书籍:《重构》《卓有成效的程序员》《代码整洁之道》等</li>
<li>我喜欢的社区: 图灵社区，知乎，博客园，Stack Over flow，Google Developer Group等</li>
<li>我的博客链接、个人作品链接如下:<br><a class="link"   href="https://github.com/github" >https://github.com/github<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="http://www.oschina.net/" >http://www.oschina.net/<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/" >https://www.cnblogs.com/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h1 id="简历内容真实性"><a href="#简历内容真实性" class="headerlink" title="简历内容真实性"></a>简历内容真实性</h1><p>老司机提醒你，你简历的任意一个细节将会是后面面试中的呈堂证供。因此在技术方面，我们还是要真真实实下功夫的！</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>订单超时取消的解决方案</title>
    <url>/p/268.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol>
<li><p>为什么需要使用延迟队列？适用于什么场景？<br>   场景一：订单下单之后30分钟后，如果用户没有付钱，则系统自动取消订单。<br>   这样类似的需求是我们经常会遇见的问题。最常用的方法是定期轮训数据库，设置状态。在数据量小的时候并没有什么大的问题，但是数据量一大轮训数据库的方式就会变得特别耗资源。当面对千万级、上亿级数据量时，本身写入的IO就比较高，导致长时间查询或者根本就查不出来。通过使用延迟队列来解决这种问题</p>
</li>
<li><p>使用RabbitMQ来实现延迟任务必须先了解RabbitMQ的两个概念：消息的Time To Live(TTL)和Dead Letter Exchanges（DLX），利用两者的组合来实现延迟队列<br>简述一下：A.消息的TTL就是消息的存活时间，B.DLX是死信路由<br>实现原理：先发送一个消息到队列中，设置存活时间，超时后会转发到死信路由中，客户端消费死信路由中的消息，消息中包装好需要转发的队列名，再根据此队列名发送消息，这样间接中转的方式实现了延迟队列。</p>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="新建SpringBoot项目，添加-amqp-引用"><a href="#新建SpringBoot项目，添加-amqp-引用" class="headerlink" title="新建SpringBoot项目，添加 amqp 引用"></a>新建SpringBoot项目，添加 amqp 引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="在配置文件application-properties中配置好mq的连接地址"><a href="#在配置文件application-properties中配置好mq的连接地址" class="headerlink" title="在配置文件application.properties中配置好mq的连接地址"></a>在配置文件application.properties中配置好mq的连接地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#rabbitmq</span><br><span class="line">spring.rabbitmq.host=127.0.0.1   </span><br><span class="line">spring.rabbitmq.port=5672  </span><br><span class="line">spring.rabbitmq.username=root</span><br><span class="line">spring.rabbitmq.password=root</span><br><span class="line">spring.rabbitmq.virtual-host=ykh_vhosts</span><br></pre></td></tr></table></figure>

<h4 id="创建配置类，使用配置文件中的连接"><a href="#创建配置类，使用配置文件中的连接" class="headerlink" title="创建配置类，使用配置文件中的连接"></a>创建配置类，使用配置文件中的连接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 读取application.properties中的连接配置</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = Logger.getLogger(&quot;RabbitMQConfiguration&quot;);</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.host&#125;&quot;)</span><br><span class="line">    public String host;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.port&#125;&quot;)</span><br><span class="line">    public int port;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.username&#125;&quot;)</span><br><span class="line">    public String username;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.password&#125;&quot;)</span><br><span class="line">    public String password;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.virtual-host&#125;&quot;)</span><br><span class="line">    public String virtualHost;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory connectionFactory() &#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory = new CachingConnectionFactory(host, port);</span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connectionFactory.setVirtualHost(virtualHost);</span><br><span class="line">        connectionFactory.setPublisherConfirms(true);</span><br><span class="line">        logger.info(&quot;Create ConnectionFactory bean ..&quot;);</span><br><span class="line">        return connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">    public RabbitTemplate rabbitTemplate() &#123;</span><br><span class="line">        RabbitTemplate template = new RabbitTemplate(connectionFactory());</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建一个常量类，定义队列名称"><a href="#创建一个常量类，定义队列名称" class="headerlink" title="创建一个常量类，定义队列名称"></a>创建一个常量类，定义队列名称</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Rabbit消息队列相关常量</span><br><span class="line"> */</span><br><span class="line">public final class MQConstant &#123;</span><br><span class="line"></span><br><span class="line">    private MQConstant()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //exchange name</span><br><span class="line">    public static final String DEFAULT_EXCHANGE = &quot;ZyChange&quot;;</span><br><span class="line"></span><br><span class="line">    //TTL QUEUE</span><br><span class="line">    public static final String DEFAULT_DEAD_LETTER_QUEUE_NAME = &quot;zy.dead.letter.queue&quot;;</span><br><span class="line"></span><br><span class="line">    //DLX repeat QUEUE 死信转发队列</span><br><span class="line">    public static final String DEFAULT_REPEAT_TRADE_QUEUE_NAME = &quot;zy.repeat.trade.queue&quot;;</span><br><span class="line"></span><br><span class="line">    //Hello 测试消息队列名称</span><br><span class="line">    public static final String HELLO_QUEUE_NAME = &quot;HELLO&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建一个队列配置类，作用是信道配置，队列配置，队列绑定"><a href="#创建一个队列配置类，作用是信道配置，队列配置，队列绑定" class="headerlink" title="创建一个队列配置类，作用是信道配置，队列配置，队列绑定"></a>创建一个队列配置类，作用是信道配置，队列配置，队列绑定</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 队列配置，所有配置@Bean的队列名称，由系统启动时创建队列，并绑定到Exchane上</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class QueueConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    //信道配置</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange defaultExchange() &#123;</span><br><span class="line">        return new DirectExchange(MQConstant.DEFAULT_EXCHANGE, true, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*********************    业务队列定义与绑定 hello 测试    *****************/</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queue() &#123;</span><br><span class="line">        Queue queue = new Queue(MQConstant.HELLO_QUEUE_NAME,true);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Binding binding() &#123;</span><br><span class="line">        //队列绑定到exchange上，再绑定好路由键</span><br><span class="line">        return BindingBuilder.bind(queue()).to(defaultExchange()).with(MQConstant.HELLO_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    /*********************    业务队列定义与绑定 hello 测试    *****************/</span><br><span class="line"></span><br><span class="line">    //下面是延迟队列的配置</span><br><span class="line">    //转发队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue repeatTradeQueue() &#123;</span><br><span class="line">        Queue queue = new Queue(MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME,true,false,false);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定转发队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding  drepeatTradeBinding() &#123;</span><br><span class="line">        return BindingBuilder.bind(repeatTradeQueue()).to(defaultExchange()).with(MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //死信队列  -- 消息在死信队列上堆积，消息超时时，会把消息转发到转发队列，转发队列根据消息内容再把转发到指定的队列上</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue deadLetterQueue() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(&quot;x-dead-letter-exchange&quot;, MQConstant.DEFAULT_EXCHANGE);</span><br><span class="line">        arguments.put(&quot;x-dead-letter-routing-key&quot;, MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME);</span><br><span class="line">        Queue queue = new Queue(MQConstant.DEFAULT_DEAD_LETTER_QUEUE_NAME,true,false,false,arguments);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定死信队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding  deadLetterBinding() &#123;</span><br><span class="line">        return BindingBuilder.bind(deadLetterQueue()).to(defaultExchange()).with(MQConstant.DEFAULT_DEAD_LETTER_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建消息生成接口和实现"><a href="#创建消息生成接口和实现" class="headerlink" title="创建消息生成接口和实现"></a>创建消息生成接口和实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IMessageService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     */</span><br><span class="line">    public void send(String queueName,String message);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 延迟发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     * @param times 延迟时间 单位毫秒</span><br><span class="line">     */</span><br><span class="line">    public void send(String queueName,String message,long times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消息队列服务接口实现</span><br><span class="line"> */</span><br><span class="line">@Service(&quot;messageService&quot;)</span><br><span class="line">public class MessageService implements IMessageService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void send(String queueName, String message) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(MQConstant.DEFAULT_EXCHANGE,queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 延迟发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     * @param times 延迟时间 单位毫秒</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void send(String queueName, String message, long times) &#123;</span><br><span class="line">        //消息发送到死信队列上，当消息超时时，会发生到转发队列上，转发队列根据下面封装的queueName，把消息转发的指定队列上</span><br><span class="line">        //发送前，把消息进行封装，转发时应转发到指定 queueName 队列上</span><br><span class="line">        DLXMessage dlxMessage = new DLXMessage(MQConstant.DEFAULT_EXCHANGE,queueName,message,times);</span><br><span class="line">        MessagePostProcessor processor = new MessagePostProcessor()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">                message.getMessageProperties().setExpiration(times + &quot;&quot;);</span><br><span class="line">                return message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        rabbitTemplate.convertAndSend(MQConstant.DEFAULT_EXCHANGE,MQConstant.DEFAULT_DEAD_LETTER_QUEUE_NAME, JSON.toJSONString(dlxMessage), processor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死信消息载体"><a href="#死信消息载体" class="headerlink" title="死信消息载体"></a>死信消息载体</h4><p>DLXMessage是一个消息封装对象，很关键，发送延迟队列时，先把消息存在此对象中，在加上目的地队列名称，然后再发到死信队列中，当消息超时时，转发到转发队列，添加对转发队列的监听，消费转发队列，获取需要延迟发送的信息，该信息就是DLXMessage对象，这样就拿到了目的地队列名称，然后再发送一次消息，就完成了延迟队列的发送。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * rabbit 死信消息载体</span><br><span class="line"> */</span><br><span class="line">public class DLXMessage implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 9956432152000L;</span><br><span class="line">    private String exchange;</span><br><span class="line">    private String queueName;</span><br><span class="line">    private String content;</span><br><span class="line">    private long times;</span><br><span class="line"></span><br><span class="line">    public DLXMessage() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DLXMessage(String queueName, String content, long times) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.queueName = queueName;</span><br><span class="line">        this.content = content;</span><br><span class="line">        this.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DLXMessage(String exchange, String queueName, String content, long times) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.exchange = exchange;</span><br><span class="line">        this.queueName = queueName;</span><br><span class="line">        this.content = content;</span><br><span class="line">        this.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static long getSerialVersionUID() &#123;</span><br><span class="line">        return serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getExchange() &#123;</span><br><span class="line">        return exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExchange(String exchange) &#123;</span><br><span class="line">        this.exchange = exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getQueueName() &#123;</span><br><span class="line">        return queueName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQueueName(String queueName) &#123;</span><br><span class="line">        this.queueName = queueName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getTimes() &#123;</span><br><span class="line">        return times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTimes(long times) &#123;</span><br><span class="line">        this.times = times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加消息消费者监听，当有消息时进行消费"><a href="#添加消息消费者监听，当有消息时进行消费" class="headerlink" title="添加消息消费者监听，当有消息时进行消费"></a>添加消息消费者监听，当有消息时进行消费</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//监听hello队列，有消息时进行消费</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = MQConstant.HELLO_QUEUE_NAME)</span><br><span class="line">public class ReceiverMessage &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String content) &#123;</span><br><span class="line">        System.out.println(&quot;接受时间:&quot;+ System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;接受消息:&quot; + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听转发队列，有消息时，把消息转发到目标队列</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME)</span><br><span class="line">public class ReceiverDelayMessage &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IMessageService messageService;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String content) &#123;</span><br><span class="line">        //此时，才把消息发送到指定队列，而实现延迟功能</span><br><span class="line">        DLXMessage message = JSON.parseObject(content, DLXMessage.class);</span><br><span class="line">        messageService.send(message.getQueueName(), message.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-启动项目，会执行发送消息代码"><a href="#测试-启动项目，会执行发送消息代码" class="headerlink" title="测试,启动项目，会执行发送消息代码"></a>测试,启动项目，会执行发送消息代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动启动时执行</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class SysInitLoad implements ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IMessageService messageService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;发送时间:&quot;+ System.currentTimeMillis());</span><br><span class="line">        String message = &quot;测试延迟消息&quot;;</span><br><span class="line">        messageService.send(MQConstant.HELLO_QUEUE_NAME,message,6000);</span><br><span class="line"></span><br><span class="line">        message = &quot;测试普通消息&quot;;</span><br><span class="line">        messageService.send(MQConstant.HELLO_QUEUE_NAME,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通消息马上就接收到了，延迟消息6s后收到。</p>
<p>以上就是订单超时未处理的解决方案，希望能够给予大家帮助。</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次因使用Date引起的线上BUG处理</title>
    <url>/p/6653.html</url>
    <content><![CDATA[<blockquote>
<p>生活中，我们需要掌控自己的时间，减少加班，提高效率；日常开发中，我们需要操作时间API，保证效率、安全、稳定。现在都2020年了，了解如何在JDK8及以后的版本中更好地操控时间就很有必要，尤其是一次线上BUG的发生，让小明更是深有体会。</p>
</blockquote>
<span id="more"></span>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<strong>Java8</strong>以前，每每操控时间，我们经常使用的类库就是<strong>Date</strong>，并且会通过<strong>SimpleDateFormat</strong>类对时间进行格式化。你可知道？<strong>Date</strong>类是一个可变类，<strong>SimpleDateFormat</strong>类也是线程不安全的，因此在多线程的场景下执行格式化操作时，就会发生意想不到的情况。下面我们看一下使用<strong>Date</strong>、<strong>SimpleDateFormat</strong>在多线程下可能发生的问题以及使用<strong>LocalDateTime</strong>、<strong>DateTimeFormatter</strong>的方法和优势。</p>
<h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><p>多线程环境下，使用<strong>Date</strong>、<strong>SimpleDateFormat</strong>时，如果我们将它定义为一个静态变量使用，虽然会避免重复创建实例， 但是会出现个别线程获取时间失败的现象，我们通过代码模拟这个场景：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/java7time.jpeg"
                     
                ></p>
<p>运行<strong>main</strong>方法，查看控制台会发现有个别线程会报<strong>java.lang.NumberFormatException</strong>异常。类似下图所示:</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420005215.png"
                     
                ></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>接下来，我们通过查看源码进一步分析（多图预警），可以看到<strong>SimpleDateFormat</strong>是直接继承的<strong>DateFormat</strong>类：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420011327.png"
                     
                >并重写了**parse()**（字符串转日期）和 **format()**（日期转字符串）方法，因此我们重点从这两个方法来分析。</p>
<p>首先是<strong>SimpleDateFormat</strong>的<strong>parse()**方法，该方法中创建了一个</strong>CalendarBuilder**对象，</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420011757.png"
                     
                ></p>
<p>再往下看，会看到<strong>CalendarBuilder</strong>使用<strong>establish</strong>方法将变量<strong>calendar</strong>设值到其属性中，</p>
<p>![image-20200420012213545](/Users/xin/Library/Application Support/typora-user-images/image-20200420012213545.png) </p>
<p>而<strong>calendar</strong>是父类<strong>DateFormat</strong>类的共享变量，可以被多个线程访问到</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420010713.png"
                     
                ></p>
<p>因此当<strong>SimpleDateFormat</strong>声明为<strong>static</strong>时，线程并不安全，多个线程同时操作访问就会抛出异常。</p>
<p>同样地通过查看<strong>format()**，我们发现</strong>format<strong>方法中有一行<code>calendar.setTime(date)</code>;也是操作的该共享变量</strong>calendar**，线程也是不安全的。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420013251.png"
                     
                ></p>
<p>有趣的是，在<strong>DateFormat</strong>源码注释上作者也已经给出醒目的提示:</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420013620.png"
                     
                ></p>
<p>使用Google翻译过来就是</p>
<blockquote>
<p>日期格式不同步。 建议为每个线程创建单独的格式实例。 如果多个线程同时访问一种格式，则必须在外部同步该格式。</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>小明有一句座右铭，方法总比问题多。我们来看几个小明认为不错的解决方案。</p>
<h5 id="1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。"><a href="#1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。" class="headerlink" title="1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。"></a>1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。</h5><p><strong>点评</strong>：加重了创建对象的负担，频繁地创建和销毁对象，消耗资源，效率较低。</p>
<h5 id="2、通过synchronized解决线程安全问题；"><a href="#2、通过synchronized解决线程安全问题；" class="headerlink" title="2、通过synchronized解决线程安全问题；"></a>2、通过<strong>synchronized</strong>解决线程安全问题；</h5><p><strong>点评</strong>：并发量大的时候会对性能有影响，容易造成线程阻塞。</p>
<h5 id="3、通过ThreadLocal保证线程之间变量不共享"><a href="#3、通过ThreadLocal保证线程之间变量不共享" class="headerlink" title="3、通过ThreadLocal保证线程之间变量不共享"></a>3、通过ThreadLocal保证线程之间变量不共享</h5><p><strong>点评：</strong>ThreadLocal可以确保每个线程都可以得到单独的一个<strong>SimpleDateFormat</strong>的对象，那么自然也就不存在竞争问题了。就是有点大材小用。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420014512.png"
                     
                ></p>
<p>以上就是小明能够提供的所有方案。什么，都不满意？我们来看一下2020年JDK8的解决方案。</p>
<h2 id="使用LocalDateTime"><a href="#使用LocalDateTime" class="headerlink" title="使用LocalDateTime"></a>使用<strong>LocalDateTime</strong></h2><p>在<strong>Java8</strong>以后，我们有了新的选择，使用<strong>LocalDateTime</strong>时间类。首先，<strong>LocalDateTime</strong>本身是线程安全的，其对应的格式化工具类<strong>DateTimeFormatter</strong>也是线程安全的，不存在变量共享，每一个属性字段都用了final关键字修饰，因此每次操作后都是返回的copy对象。并且<strong>LocalDateTime</strong>类本身也有很多操作时间的API来替代传统的<strong>Calendar</strong>类。</p>
<p>基于<strong>Java8</strong>的<strong>DateTimeFormatter</strong>的解决方案，我们对之前的代码进行改造，多线程环境下，运行代码，并未发现任何异常，稳定高效:</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420015556.png"
                     
                ></p>
<p>我们可以看到<strong>在DateTimeFormatter</strong>源码上作者也贴心的加注释说明，该类是不可变的，并且是线程安全的。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420015208.png"
                     
                ></p>
<p>同理，这点我们也可以从<strong>LocalDateTime</strong>的官方源码中看出。</p>
<h2 id="其他骚操作"><a href="#其他骚操作" class="headerlink" title="其他骚操作"></a>其他骚操作</h2><p>为了让大家忘掉之前使用<strong>Calendar</strong>操作时间的笨拙，我们来切实感受一下<strong>LocalDateTime</strong>给实际开发中带来的便利: </p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200420021510.png"
                     
                ></p>
<blockquote>
<p>更多举例说明，请点击文末阅读原文</p>
<p>代码地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming" >https://github.com/WhenCoding/coder-xiaoming<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，小明推荐小伙伴们使用JDK8的<strong>LocalDateTime</strong>系列来取代<strong>Date</strong>系列，这样做不仅能够保证线上项目平稳运行，而且通过其自带的API还能操作时间，还能提高开发效率，今晚可以不加班！</p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>锁升级</title>
    <url>/p/28842.html</url>
    <content><![CDATA[<p>在Java中，锁升级是指在多线程环境下，锁从较低的粒度升级到更高的粒度，以提高并发性能。常见的锁升级方式包括偏向锁、轻量级锁和重量级锁。</p>
<ol>
<li><p>偏向锁：在没有竞争的情况下，将锁记录在线程的锁记录（Thread Local Lock Record）中，以减少不必要的同步开销。当其他线程尝试获取这个锁时，偏向锁会自动升级为轻量级锁。</p>
</li>
<li><p>轻量级锁：当多个线程竞争同一个锁时，锁会升级为轻量级锁。轻量级锁利用CAS（Compare and Swap）操作来实现对锁的获取和释放，避免了线程阻塞和切换的开销。</p>
</li>
<li><p>重量级锁：当轻量级锁无法解决线程竞争问题时，锁会进一步升级为重量级锁。重量级锁使用<strong>操作系统的互斥量（Mutex）</strong>来实现对锁的获取和释放，具有可靠性高但开销较大的特点。</p>
</li>
</ol>
<p>锁升级的过程是根据具体场景和竞争情况动态进行的，Java的虚拟机会根据运行时数据来选择合适的锁粒度。锁升级可以提高并发性能，但也会增加一些额外的开销，因此在设计和使用锁时需要根据实际情况进行权衡和选择。</p>
<p>在Java中，锁升级主要涉及到两种锁：<code>ReentrantLock</code>和<code>synchronized</code>。</p>
<ol>
<li><p>ReentrantLock：<br><code>ReentrantLock</code>是Java.util.concurrent包下提供的可重入锁（Reentrant Lock），它可以作为替代<code>synchronized</code>关键字的一种更加灵活、可扩展的锁机制。ReentrantLock内部通过CAS操作和自旋来实现锁的获取和释放，具备更低的锁竞争开销。<br>在使用<code>ReentrantLock</code>时，可以手动控制锁的获取和释放，可以使用lock()方法获取锁，调用unlock()方法释放锁。此外，<code>ReentrantLock</code>还支持公平锁和非公平锁的选择。</p>
</li>
<li><p>synchronized：<br><code>synchronized</code>关键字是Java中最常见的锁机制，可以修饰代码块或者方法，也是可重入锁。当一个线程获取到<code>synchronized</code>锁之后，其他线程会被阻塞直到该线程释放锁。<br><code>synchronized</code>关键字的锁升级过程是由JVM自动完成的。初始状态下，<code>synchronized</code>是偏向锁。当有多个线程竞争同一个锁时，会升级为轻量级锁。如果轻量级锁竞争失败，则升级为重量级锁。</p>
</li>
</ol>
<p>需要注意的是，<code>synchronized</code>比<code>ReentrantLock</code>更简单易用，但在某些特定场景下，<code>ReentrantLock</code>可能更灵活，例如支持可中断锁、超时锁、公平锁等特性。在选择锁的时候，应根据具体需求和性能需求来选择合适的锁机制。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云企业云邮箱收发设置</title>
    <url>/p/17df.html</url>
    <content><![CDATA[<p>一天一个小技巧</p>
<span id="more"></span>

<blockquote>
<p>小明最近在自己的mac上面登录公司的企业邮箱（运营一套用的都是阿里云），找到了阿里云邮箱的收件和发件邮箱地址设置方法，给大家节省一下时间。</p>
</blockquote>
<h1 id="企业云邮箱POP-SMTP-IMAP地址和端口信息"><a href="#企业云邮箱POP-SMTP-IMAP地址和端口信息" class="headerlink" title="企业云邮箱POP\SMTP\IMAP地址和端口信息"></a>企业云邮箱POP\SMTP\IMAP地址和端口信息</h1><h2 id="收件服务器地址"><a href="#收件服务器地址" class="headerlink" title="收件服务器地址"></a>收件服务器地址</h2><p>发件协议两个协议可供选择</p>
<ul>
<li>POP 服务器地址：pop3.mxhichina.com(或者pop3.公司域名，举例:pop3.coderxm.com) 端口110，如果采用SSL加密，则端口改为加密端口995</li>
</ul>
<p>或者</p>
<ul>
<li>IMAP 服务器地址：imap.mxhichina.com(或者pop3.公司域名，举例:pop3.coderxm.com) 端口143，如果采用SSL加密，则端口改为加密端口993</li>
</ul>
<h2 id="发件服务器地址"><a href="#发件服务器地址" class="headerlink" title="发件服务器地址"></a>发件服务器地址</h2><ul>
<li>SMTP 服务器地址：smtp.mxhichina.com 端口25，如果采用SSL加密，则端口改为加密端口465</li>
</ul>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>项目中遇到过什么难题</title>
    <url>/p/7611.html</url>
    <content><![CDATA[<p>方法总比问题多</p>
<span id="more"></span>

<h2 id="两个产品的平滑融合"><a href="#两个产品的平滑融合" class="headerlink" title="两个产品的平滑融合"></a>两个产品的平滑融合</h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>受经济影响，今年公司进行战略调整，所在的部门要进行产品线精简，现有的两个Sass平台进行合并，从而实现开源节流：原有开发人员缩减一半，减少人力成本。</p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul>
<li>原有客户业务不能受影响</li>
<li>两个产品的功能需要合并</li>
<li>历史数据的迁移及实时数据的同步</li>
</ul>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul>
<li>分批迁移客户<ul>
<li>征集客户意愿，参与首批新品体验</li>
</ul>
</li>
<li>两个产品服务需要保障并行运行一段时间，给用户一个过渡期体验<ul>
<li>引入新版概念，开放新版入口</li>
</ul>
</li>
<li>产品经理梳理两个产品的功能点异同，将产品功能对其<ul>
<li>原有服务不再迭代更新，比如A融合到B，则A不更新，B进行迭代更新，实现功能对齐</li>
</ul>
</li>
<li>为了解决两个平台的跨域问题，根据同个域名下同步不同路径反向代理指向不同产品</li>
</ul>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>日常开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/p/55194.html</url>
    <content><![CDATA[<p>🔧 如题</p>
<span id="more"></span>
<h2 id="修改启动后容器的配置"><a href="#修改启动后容器的配置" class="headerlink" title="修改启动后容器的配置"></a>修改启动后容器的配置</h2><p>首先关闭docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<p>如果执行后提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: Stopping docker.service, but it can still be activated by: docker.socket</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这表示docker在关闭状态下会被访问自动唤醒机制，很人性化，即这时再执行任意docker命令会直接启动。<br>如果不希望docker被访问自动唤醒，需要再执行(或者直接执行)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop docker.socket</span><br></pre></td></tr></table></figure>

<p>接下来修改配置，先进入docker的container里面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/lib/docker/containers/AAA</span><br></pre></td></tr></table></figure>

<p>这里 AAA 是 container ID，然后修改指定的配置即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim config.v2.json</span><br></pre></td></tr></table></figure>

<h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><h3 id="linux-安装"><a href="#linux-安装" class="headerlink" title="linux 安装"></a>linux 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum update ;yum -y install docker  ; yum install docker-io;</span><br></pre></td></tr></table></figure>

<h4 id="启动和开机启动service-docker-startchkconfig-docker-on"><a href="#启动和开机启动service-docker-startchkconfig-docker-on" class="headerlink" title="启动和开机启动service docker startchkconfig docker on"></a>启动和开机启动service docker startchkconfig docker on</h4><ul>
<li><p>查看所有镜像docker images</p>
</li>
<li><p>获取镜像<br> docker pull</p>
</li>
<li><p>查看所有容器docker ps -a</p>
</li>
<li><p>查看正在运行的容器docker ps</p>
</li>
<li><p>进入正在运行的容器docker exec -t -i 容器id /bin/bash</p>
</li>
<li><p>退出ctrl+d</p>
</li>
<li><p>应用场景：可以在里面重启应用程序</p>
</li>
<li><p>执行容器中的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash -c &#x27;echo $PATH&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器的网络配置docker inspect 容器名</p>
</li>
<li><p>查看容器的IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; 容器名</span><br></pre></td></tr></table></figure></li>
<li><p>修改镜像名称和标签名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag eb40dcf64078 django:latest</span><br></pre></td></tr></table></figure>
<p> eb40dcf64078为images id </p>
</li>
<li><p>运行镜像docker run –name mynginx -d nginx:latest</p>
</li>
<li><p>运行镜像并保持后台运行</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name containerName imageId</span><br></pre></td></tr></table></figure>

<ul>
<li><p>端口映射<br>docker run -it  -p 外部端口:容器端口  –name 起个名字 镜像名称</p>
</li>
<li><p>运行之前启动过的容器docker start 容器 id，容器名等</p>
</li>
<li><p>重启<br>  docker restart 容器id</p>
</li>
<li><p>停止正在运行的容器* docker stop 容器，容器名id等<br>停止指定容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps | grep  &#x27;screenshot&#x27;| awk &#x27;&#123;print $1&#125;&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>docker镜像和容器删除注意：1. 删除前需要保证容器是停止的  stop2. 需要注意删除镜像和容器的命令不一样。 docker rmi ID  ,其中 容器(rm)  和 镜像(rmi)3. 顺序需要先删除容器</p>
</li>
<li><p>docker rm CONTAINER_ID//先删除容器</p>
</li>
<li><p>docker rmi IMAGE_ID //再删除镜像</p>
</li>
<li><p>常用命令</p>
</li>
<li><p>复制e.g. -&gt; docker cp config_inc.php mantis_mantisbt_1:/var/www/html/config/</p>
</li>
<li><p>应用场景docker cp 可以解决因docker容器内部配置文件出现问题而无法通过docker exec -i -t 容器名 /bin/bash进入的状况，比如容器内部无限重启时。</p>
</li>
<li><p>可以将正在运行的容器commit成镜像</p>
</li>
<li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]OPTIONS说明:-a :提交的镜像作者;-c :使用Dockerfile指令来创建镜像;-m :提交时的说明文字;-p :在commit时,将容器暂停。e.g. docker commit -m=”comment” -a=”author” cd1ce3371224 java8:1.0</p>
</li>
<li><p>在docker之间导出导入镜像的方法<a class="link"   href="http://www.jb51.net/article/119038.htm" >http://www.jb51.net/article/119038.htm<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><ol>
<li>导出 export - 导入 import</li>
</ol>
</li>
<li><p>导出格式：docker export CONTAINER(容器)docker export docker_mantisbt_1 &gt; ./docker_mantisbt.tar</p>
</li>
<li><p>导入格式：docker import CONTAINER(容器)docker import - docker_mantisbt &lt; docker_mantisbt.tar</p>
</li>
<li><p>2.保存save - 加载 load相当于镜像的备份和恢复</p>
</li>
<li><p>保存格式：docker save IMAGE(镜像)docker save 9610cfc68e8d &gt; /home/myubuntu-save-1204.tar</p>
</li>
<li><p>加载格式：docker load IMAGE(镜像)docker load &lt; /home/myubuntu-save-1204.tar</p>
</li>
<li><p>3.导出 export 与 保存 save 的区别</p>
</li>
<li><p>(1)export导出的镜像文件大小 小于 save保存的镜像</p>
</li>
<li><p>(2)export 导出（import导入）根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作（docker tag <LAYER ID> <IMAGE NAME>）；而save保存（load加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。（查看方式：docker images –tree）</p>
</li>
<li><p>注：导入加载进来觉得不合适可以使用 docker rm 容器ID 、 docker rmi 镜像ID 来删掉。</p>
</li>
<li><p>移除所有的容器和镜像（大扫除）docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a)    -q, –quiet           Only display numeric IDs </p>
</li>
<li><p>移除孤立的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure></li>
<li><p>清理镜像<br>我们在使用 Docker 一段时间后，系统一般都会残存一些临时的、没有被使用的镜像文件，可以通过以下命令进行清理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="docker制作"><a href="#docker制作" class="headerlink" title="docker制作"></a>docker制作</h2><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>，注意<code>.</code>表示上下文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t &#123;imageName:imageVersion&#125; .</span><br></pre></td></tr></table></figure>

<h2 id="docker上传仓库"><a href="#docker上传仓库" class="headerlink" title="docker上传仓库"></a>docker上传仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login &#123;registry_address&#125; -u &#123;用户名&#125; -p &#123;密码&#125; &amp;&amp; docker push &#123;imageName:imageVersion&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改容器配置文件-env等"><a href="#修改容器配置文件-env等" class="headerlink" title="修改容器配置文件(env等)"></a>修改容器配置文件(env等)</h2><p>配置文件位置：/var/lib/docker/containers/容器ID/config.v2.json<br>容器ID 有点长，所以在容器关闭前记录下容器ID<br>修改，确保docker服务关闭！！！<br>vim config.v2.json</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch常用的API</title>
    <url>/p/50161.html</url>
    <content><![CDATA[<p>总结一下最近频繁使用的api，以备不时之需，使用的是kibana可视化工具。</p>
<span id="more"></span>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220927114744.png"
                     
                ></p>
<h2 id="查看索引中的数据"><a href="#查看索引中的数据" class="headerlink" title="查看索引中的数据"></a>查看索引中的数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET 20220918_weibo/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;:5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据id查看某个文档"><a href="#根据id查看某个文档" class="headerlink" title="根据id查看某个文档"></a>根据id查看某个文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET yqms_20220918_weibo/_doc/20220918_1_06a8fe74714cac2554a704e3f6022f47</span><br></pre></td></tr></table></figure>

<h2 id="查看索引数据量"><a href="#查看索引数据量" class="headerlink" title="查看索引数据量"></a>查看索引数据量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /20220918_weibo/_count</span><br></pre></td></tr></table></figure>
<p>Tips:支持*通配符</p>
<h1 id="查看分词器"><a href="#查看分词器" class="headerlink" title="查看分词器"></a>查看分词器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET 20220918_weibo/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;title&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;志胜说自己是红绿色盲&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引的分片信息"><a href="#索引的分片信息" class="headerlink" title="索引的分片信息"></a>索引的分片信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET _cat/shards/20220116_weibo?v</span><br></pre></td></tr></table></figure>

<p>v会增加表头</p>
<h2 id="批量改副本数"><a href="#批量改副本数" class="headerlink" title="批量改副本数"></a>批量改副本数</h2><p>复制分片会让你的数据更安全，查询更快，但会影响你入库的速度，所以当数据发生大量拥堵时，可以临时调整分片数，加快入库速度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT 20220926*/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot; : &#123;</span><br><span class="line">        &quot;number_of_replicas&quot; : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看索引别名是否存在"><a href="#查看索引别名是否存在" class="headerlink" title="查看索引别名是否存在"></a>查看索引别名是否存在</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEAD /_alias/20220918_weibo</span><br></pre></td></tr></table></figure>

<h1 id="添加索引别名"><a href="#添加索引别名" class="headerlink" title="添加索引别名"></a>添加索引别名</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;add&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;old_20220919_weibo&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;new_20220919_weibo&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除索引别名"><a href="#删除索引别名" class="headerlink" title="删除索引别名"></a>删除索引别名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;remove&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;old_20220919_weibo&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;new_20220919_weibo&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="query-string"><a href="#query-string" class="headerlink" title="query string"></a>query string</h2><p>这个api支持AND、OR、 NOT 、”” （记得大写），另外，还可以指定type类型：best_fields（默认）、phrase<br><a class="link"   href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/query-dsl-query-string-query.html" >官方文档<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="批量更新文档"><a href="#批量更新文档" class="headerlink" title="批量更新文档"></a>批量更新文档</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /20220918_*/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.distinguish_type = 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="根据id删除"><a href="#根据id删除" class="headerlink" title="根据id删除"></a>根据id删除</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /20220918_weibo/_doc/13l3G3kBX4ydNSzBVQtb</span><br></pre></td></tr></table></figure>

<h2 id="批量删除指定文档"><a href="#批量删除指定文档" class="headerlink" title="批量删除指定文档"></a>批量删除指定文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST 20220918_weibo/_delete_by_query?wait_for_completion=false&amp;scroll_size=1000&amp;conflicts=proceed</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;source&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;old_20220910_weibo&quot;,</span><br><span class="line">        &quot;size&quot;:5000</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dest&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;new_20220910_weibo&quot;,</span><br><span class="line">        &quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;conflicts&quot;: &quot;proceed&quot;,</span><br><span class="line">    &quot;script&quot;: &#123;</span><br><span class="line">        &quot;source&quot;:&quot;&quot;&quot;</span><br><span class="line">          def publish_time;</span><br><span class="line">          if(ctx._source.ctime !=null )&#123;</span><br><span class="line">            publish_time = ctx._source.ctime * 1000L;</span><br><span class="line">          &#125;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><blockquote>
<p>用自己惨痛的教训告诉你，删除前一定要仔细！！！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用Delete Index API</span><br></pre></td></tr></table></figure>
<p>DELETE /my_index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用DELETE Index API可以直接从ES集群中删除指定的索引，这个操作非常简单易用。</span><br><span class="line"></span><br><span class="line">2.使用curl命令删除索引</span><br></pre></td></tr></table></figure>
<p>curl -XDELETE ‘<a class="link"   href="http://localhost:9200/my_index&#39;" >http://localhost:9200/my_index&#39;<i class="fas fa-external-link-alt"></i></a><br>curl命令可以在命令行中使用，也可以在脚本中使用。直接调用http请求可以在删除大量索引时方便快捷。</p>
<p>3.使用Kibana删除索引<br>Kibana是ES提供的一个可视化工具，可以直接连接到ES集群。在Kibana界面上点击左侧的导航栏“Management”，然后找到需要删除的索引，右键点击“Delete”按钮即可删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 筛选指定执行中的任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GET _tasks?detailed=true&amp;actions=*reindex</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 根据任务id查看任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GET _tasks/9eOsi8WJRIyQNnLr5ZxndA:368975752</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 取消任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>POST _tasks/9eOsi8WJRIyQNnLr5ZxndA:367774670/_cancel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 批量更新</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>POST /20220918_weibo/_update_by_query<br>{<br>  “query”: {<br>    “match_all”: {}<br>  },<br>  “script”: {<br>    “source”: “ctx._source.distinguish_type = 1”<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 删除快照</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DELETE _snapshot/{repository}/{snapshot}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># es集群状态</span><br><span class="line">## 查看当前es正在运行的线程</span><br></pre></td></tr></table></figure>
<p>GET /_cat/thread_pool/?v&amp;h=id,name,active,rejected,completed,size,type&amp;pretty&amp;s=type</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 当前活跃的线程</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GET /_nodes/hot_threads</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 查询节点状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GET /_cat/nodes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 查看分片失败的原因</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GET /_cluster/allocation/explain?pretty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 尝试重新分配失败的分片</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>POST /_cluster/reroute?retry_failed=true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 清除缓存</span><br></pre></td></tr></table></figure>
<p>POST /_cache/clear</p>
<pre><code>

</code></pre>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES性能分析</title>
    <url>/p/39368.html</url>
    <content><![CDATA[<p>📚 esrally使用记录</p>
<span id="more"></span>

<p>要使用 Elasticsearch Rally (esrally) 比较两个 Elasticsearch 集群的性能，需要按照以下步骤操作：</p>
<h3 id="步骤-1-安装和配置-esrally"><a href="#步骤-1-安装和配置-esrally" class="headerlink" title="步骤 1: 安装和配置 esrally"></a>步骤 1: 安装和配置 esrally</h3><p>如果你还没有安装 esrally，可以通过 pip 安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install esrally</span><br></pre></td></tr></table></figure>

<p>在首次运行 esrally 时，需要进行一些基本配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esrally configure</span><br></pre></td></tr></table></figure>

<p>这个命令会引导你完成一系列配置步骤，包括设置 Elasticsearch 集群的地址、选择是否上传测试结果等。</p>
<h3 id="步骤-2-选择或创建测试场景（Track）"><a href="#步骤-2-选择或创建测试场景（Track）" class="headerlink" title="步骤 2: 选择或创建测试场景（Track）"></a>步骤 2: 选择或创建测试场景（Track）</h3><p>esrally 提供了多种预定义的测试场景（称为 tracks），你可以选择一个适合你需求的场景。例如，<code>geonames</code> 是一个常用的场景，适用于通用的性能测试。</p>
<p>如果预定义的场景不符合你的需求，你可以创建自定义的场景。这涉及到定义数据集和测试操作。</p>
<h3 id="步骤-3-对第一个集群进行测试"><a href="#步骤-3-对第一个集群进行测试" class="headerlink" title="步骤 3: 对第一个集群进行测试"></a>步骤 3: 对第一个集群进行测试</h3><p>使用以下命令对第一个 Elasticsearch 集群进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esrally --track=geonames --target-hosts=es_cluster1_host:9200 --pipeline=benchmark-only</span><br></pre></td></tr></table></figure>

<p>这里，<code>--track=geonames</code> 指定了使用的测试场景，<code>--target-hosts</code> 指定了第一个 Elasticsearch 集群的地址。</p>
<h3 id="步骤-4-对第二个集群进行测试"><a href="#步骤-4-对第二个集群进行测试" class="headerlink" title="步骤 4: 对第二个集群进行测试"></a>步骤 4: 对第二个集群进行测试</h3><p>同样的，对第二个 Elasticsearch 集群进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esrally --track=geonames --target-hosts=es_cluster2_host:9200 --pipeline=benchmark-only</span><br></pre></td></tr></table></figure>

<p>确保测试条件（如 track、数据量等）与第一个集群的测试相同，以便进行公平比较。</p>
<h3 id="步骤-5-比较结果"><a href="#步骤-5-比较结果" class="headerlink" title="步骤 5: 比较结果"></a>步骤 5: 比较结果</h3><p>测试完成后，esrally 会生成详细的报告，包括吞吐量、延迟等关键性能指标。你需要比较两个集群的测试结果：</p>
<ul>
<li><strong>吞吐量</strong>：通常以每秒处理的请求数量来衡量。</li>
<li><strong>延迟</strong>：观察平均延迟和延迟分布。</li>
<li><strong>资源使用情况</strong>：比如 CPU、内存和磁盘 I/O。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>确保在相似的条件下测试两个集群，包括硬件配置、网络环境、Elasticsearch 配置等。</li>
<li>测试可能会对集群性能产生短暂影响，因此建议在低峰时段进行。</li>
<li>分析结果时，考虑到可能的外部因素，如网络延迟、硬件差异等。</li>
</ul>
<p>通过这种方法，你可以获得两个 Elasticsearch 集群在相似条件下的性能数据，从而进行有效的比较和分析。</p>
<p>使用 Elasticsearch Rally (esrally) 进行性能测试时指定特定的索引。这通常涉及到创建自定义的测试场景（称为 “track”），其中你可以定义要测试的具体索引以及相关的查询和操作。</p>
<h3 id="创建自定义-Track"><a href="#创建自定义-Track" class="headerlink" title="创建自定义 Track"></a>创建自定义 Track</h3><p>为了针对特定索引进行测试，你需要创建一个自定义的 track。以下是创建自定义 track 的基本步骤：</p>
<h4 id="1-定义-Track-结构"><a href="#1-定义-Track-结构" class="headerlink" title="1. 定义 Track 结构"></a>1. 定义 Track 结构</h4><p>创建一个新的文件夹来存放你的自定义 track。在这个文件夹中，你需要创建一个名为 <code>track.json</code> 的文件，这是定义 track 的主要文件。</p>
<h4 id="2-编写-track-json"><a href="#2-编写-track-json" class="headerlink" title="2. 编写 track.json"></a>2. 编写 track.json</h4><p>在 <code>track.json</code> 文件中，你可以定义要测试的索引、数据集、操作（比如查询）等。以下是一个简单的示例，展示了如何定义一个针对特定索引的 track：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Custom Track&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;indices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_index&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index-settings.json&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;corpora&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_corpora&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;documents&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;source-file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;documents.json.bz2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;document-count&quot;</span><span class="punctuation">:</span> <span class="number">1000000</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;compressed-bytes&quot;</span><span class="punctuation">:</span> <span class="number">100000000</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;uncompressed-bytes&quot;</span><span class="punctuation">:</span> <span class="number">500000000</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;challenges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;schedule&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;operation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index-append&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;search&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;operation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;operation-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;search&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_index&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>indices</code> 部分定义了要测试的索引（在这个例子中是 <code>my_index</code>），而 <code>challenges</code> 部分定义了要执行的操作，例如索引数据和执行查询。</p>
<h4 id="3-准备数据文件"><a href="#3-准备数据文件" class="headerlink" title="3. 准备数据文件"></a>3. 准备数据文件</h4><p>如果你的 track 需要索引数据，你需要准备数据文件。这些文件应该放在与 <code>track.json</code> 相同的文件夹中。在上面的示例中，<code>documents.json.bz2</code> 是一个压缩的数据文件，包含了要索引的文档。</p>
<h4 id="4-运行自定义-Track"><a href="#4-运行自定义-Track" class="headerlink" title="4. 运行自定义 Track"></a>4. 运行自定义 Track</h4><p>一旦你的 track 和相关文件准备好了，你可以使用以下命令运行 esrally：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">esrally --track-path=/path/to/your/track --target-hosts=es_host:9200 --pipeline=benchmark-only</span><br></pre></td></tr></table></figure>

<p>这里 <code>--track-path</code> 指向你的自定义 track 文件夹。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>确保你的自定义 track 中的索引名称、数据文件等与你的实际需求相符。</li>
<li>如果你的 Elasticsearch 集群有安全设置（如基本认证），需要在 esrally 的配置中指定这些信息。</li>
<li>创建 track 时，确保定义的操作（如查询）适用于你的数据和索引结构。</li>
</ul>
<p>通过这种方式，你可以对特定的索引进行细致的性能测试，从而更准确地评估和优化 Elasticsearch 集群的性能。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>开发</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>「Elasticsearch」ES重建索引怎么才能做到数据无缝迁移呢？</title>
    <url>/p/20547.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>众所周知，Elasticsearch是⼀个实时的分布式搜索引擎，为⽤户提供搜索服务。当我们决定存储某种数据，在创建索引的时候就需要将数据结构，即Mapping确定下来，于此同时索引的设定和很多固定配置将不能改变。</p>
<span id="more"></span>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220927160140.png"
                     
                ></p>
<p>那如果后续业务发生变化，需要改变数据结构或者更换ES更换分词器怎么办呢？为此，Elastic团队提供了很多通过辅助⼯具来帮助开发⼈员进⾏重建索引的方案。<br>如果对 <code>reindex</code> API 不熟悉，那么在遇到重构的时候，必然事倍功半，效率低下。反之，就可以方便地进行索引重构，省时省力。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>假设之前我们已经存在一个blog索引，因为更换分词器需要对该索引中的数据进行重建索引，以便支持业务使用新的分词规则搜索数据，并且尽可能使这个变化对外服务没有感知，大概分为以下几个步骤：​</p>
<ul>
<li>新增⼀个索引<code>blog_lastest</code>，Mapping数据结构与<code>blog</code>索引一致</li>
<li>将<code>blog</code>数据同步至<code>blog_lastest</code></li>
<li>删除<code>blog</code>索引</li>
<li>数据同步后给<code>blog_lastest</code>添加别名<code>blog</code></li>
</ul>
<h3 id="新建索引"><a href="#新建索引" class="headerlink" title="新建索引"></a>新建索引</h3><blockquote>
<p>在这里推荐一个ES管理工具<strong>Kibana</strong>，主要针对数据的探索、可视化和分析。</p>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/mweb/16093371925425.jpg"
                      alt="官网"
                ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put /blog_lastest/</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;title&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;ik_max_word&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;author&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;keyword&quot;,</span><br><span class="line">                &quot;fields&quot;:&#123;</span><br><span class="line">                    &quot;seg&quot;:&#123;</span><br><span class="line">                        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                        &quot;analyzer&quot;:&quot;ik_max_word&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将旧索引数据copy到新索引"><a href="#将旧索引数据copy到新索引" class="headerlink" title="将旧索引数据copy到新索引"></a>将旧索引数据copy到新索引</h3><h4 id="同步等待"><a href="#同步等待" class="headerlink" title="同步等待"></a>同步等待</h4><p>接⼝将会在 reindex 结束后返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_reindex</span><br><span class="line">&#123;</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;dest&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog_lastest&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>kibana</code> 中的使用如下所示<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/mweb/16093465633359.jpg"
                      alt="-w706"
                ></p>
<p>当然高版本（7.1.1）中，ES都有提供对应的<code>Java REST Client</code>，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReindexRequest reindexRequest = new ReindexRequest();</span><br><span class="line">reindexRequest.setSourceIndices(&quot;blog&quot;).setSource.setDestIndex(&quot;blog_lastest&quot;);</span><br><span class="line">TaskSubmissionResponse taskSubmissionResponse = client.submitReindexTask(reindexRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>
<p>为了防止赘述，接下来举例全部以<code>kibana</code>中请求介绍，如果有需要用<code>Java REST Client</code>，可以自行去ES官网查看。</p>
<h4 id="异步执⾏"><a href="#异步执⾏" class="headerlink" title="异步执⾏"></a>异步执⾏</h4><p>如果 reindex 时间过⻓，建议加上 <code>wait_for_completion=false</code> 的参数条件，这样 reindex 将直接返回 <code>taskId</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_reindex?wait_for_completion=false</span><br><span class="line">&#123;</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;dest&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog_lastest&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;task&quot; : &quot;dpBihNSMQfSlboMGlTgCBA:4728038&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="op-type-参数"><a href="#op-type-参数" class="headerlink" title="op_type 参数"></a>op_type 参数</h4><p><code>op_type</code> 参数控制着写入数据的冲突处理方式，如果把 <code>op_type</code> 设置为 <code>create</code>【默认值】，在 <code>_reindex</code> API 中，表示写入时只在 <code>dest.index</code>中添加不存在的 doucment，如果相同的 document 已经存在，则会报 <code>version confilct</code> 的错误，那么索引操作就会失败。【这种方式与使用 _create API 时效果一致】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog_lastest&quot;,</span><br><span class="line">    &quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这样设置了，也就不存在更新数据的场景了【冲突数据无法写入】<br>官方文档是这样解释的：</p>
<blockquote>
<p>Setting op_type to create causes _reindex to only create missing documents in the destination. All existing documents will cause a version conflict.<br>Because data streams are append-only, any reindex request to a destination data stream must have an op_type of<code>create</code>. A reindex can only add new documents to a destination data stream. It cannot update existing documents in a destination data stream.</p>
</blockquote>
<h4 id="conflicts-配置"><a href="#conflicts-配置" class="headerlink" title="conflicts 配置"></a>conflicts 配置</h4><p>默认情况下，当发生 <code>version conflict</code> 的时候，<code>_reindex</code> 会被 <code>abort</code>，任务终止【此时数据还没有 <code>reindex</code> 完成】，在返回体中的 <code>failures</code> 指标中会包含冲突的数据【有时候数据会非常多】，除非把 <code>conflicts</code> 设置为 <code>proceed</code>。</p>
<p>关于 <code>abort</code> 的说明，如果产生了 <code>abort</code>，已经执行的数据【例如更新写入的】仍然存在于目标索引，此时任务终止，还会有数据没有被执行，也就是漏数了。换句话说，该执行过程不会回滚，只会终止。如果设置了 <code>proceed</code>，任务在检测到数据冲突的情况下，不会终止，会跳过冲突数据继续执行，直到所有数据执行完成，此时不会漏掉正常的数据，只会漏掉有冲突的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog_lastest&quot;,</span><br><span class="line">    &quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;conflicts&quot;: &quot;proceed&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以故意把 <code>op_type</code> 设置为 <code>create</code>，人为制造数据冲突的场景，测试时更容易观察到冲突现象。</p>
<p>如果把 <code>conflicts</code> 设置为 <code>proceed</code>，在返回体结果中不会再出现 <code>failures</code> 的信息，但是通过 <code>version_conflicts</code> 指标可以看到具体的数量。</p>
<h4 id="批次大小配置"><a href="#批次大小配置" class="headerlink" title="批次大小配置"></a>批次大小配置</h4><p>当你发现<code>reindex</code>的速度有些慢的时候，可以在 <code>query</code> 参数的同一层次【即 <code>source</code> 参数中】添加 <code>size</code> 参数，表示 <code>scroll size</code> 的大小【会影响批次的次数，进而影响整体的速度】，如果不显式设置，默认是一批 1000 条数据，在一开始的简单示例中也看到了。<br>如下，设置 <code>scroll size</code> 为 5000：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_reindex?wait_for_completion=false</span><br><span class="line">&#123;</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog&quot;,</span><br><span class="line">		&quot;size&quot;:5000</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;dest&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog_lastest&quot;,</span><br><span class="line">		&quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;conflicts&quot;: &quot;proceed&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试后，速度达到了 30 分钟 500 万左右，明显提升了很多。</p>
<h4 id="分片slices-auto"><a href="#分片slices-auto" class="headerlink" title="分片slices=auto"></a>分片slices=auto</h4><p>slices=auto命令可以指定数据同步时候的根据索引的分片数量，开启与分片数相同的分片进行数据同步。</p>
<h4 id="根据taskId可以实时查看任务的执行状态"><a href="#根据taskId可以实时查看任务的执行状态" class="headerlink" title="根据taskId可以实时查看任务的执行状态"></a>根据taskId可以实时查看任务的执行状态</h4><p>一般来说，如果我们的 <code>source index</code> 很大【比如几百万数据量】，则可能需要比较长的时间来完成 <code>_reindex</code> 的工作，可能需要几十分钟。而在此期间不可能一直等待结果返回，可以去做其它事情，如果中途需要查看进度，可以通过 <code>_tasks</code> API 进行查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_tasks/&#123;taskId&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;completed&quot; : false,</span><br><span class="line">  &quot;task&quot; : &#123;</span><br><span class="line">    &quot;node&quot; : &quot;dpBihNSMQfSlboMGlTgCBA&quot;,</span><br><span class="line">    &quot;id&quot; : 4704218,</span><br><span class="line">    &quot;type&quot; : &quot;transport&quot;,</span><br><span class="line">    &quot;action&quot; : &quot;indices:data/write/reindex&quot;,</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行完毕时，<code>completed</code>为true<br>查看任务进度以及取消任务，除了根据taskId查看以外，我们还可以通过查看所有的任务中筛选本次<code>reindex</code>的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET _tasks?detailed=true&amp;actions=*reindex</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;nodes&quot; : &#123;</span><br><span class="line">    &quot;dpBihNSMQfSlboMGlTgCBA&quot; : &#123;</span><br><span class="line">      &quot;name&quot; : &quot;node-16111-9210&quot;,</span><br><span class="line">      &quot;transport_address&quot; : &quot;192.168.XXX.XXX:9310&quot;,</span><br><span class="line">      &quot;host&quot; : &quot;192.168.XXX.XXX&quot;,</span><br><span class="line">      &quot;ip&quot; : &quot;192.168.16.111:9310&quot;,</span><br><span class="line">      &quot;roles&quot; : [</span><br><span class="line">        &quot;ingest&quot;,</span><br><span class="line">        &quot;master&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;attributes&quot; : &#123;</span><br><span class="line">        &quot;xpack.installed&quot; : &quot;true&quot;,</span><br><span class="line">        &quot;transform.node&quot; : &quot;false&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tasks&quot; : &#123;</span><br><span class="line">        &quot;dpBihNSMQfSlboMGlTgCBA:6629305&quot; : &#123;</span><br><span class="line">          &quot;node&quot; : &quot;dpBihNSMQfSlboMGlTgCBA&quot;,</span><br><span class="line">          &quot;id&quot; : 6629305,</span><br><span class="line">          &quot;type&quot; : &quot;transport&quot;,</span><br><span class="line">          &quot;action&quot; : &quot;indices:data/write/reindex&quot;,</span><br><span class="line">          &quot;status&quot; : &#123;</span><br><span class="line">            &quot;total&quot; : 8361421,</span><br><span class="line">            &quot;updated&quot; : 0,</span><br><span class="line">            &quot;created&quot; : 254006,</span><br><span class="line">            &quot;deleted&quot; : 0,</span><br><span class="line">            &quot;batches&quot; : 743,</span><br><span class="line">            &quot;version_conflicts&quot; : 3455994,</span><br><span class="line">            &quot;noops&quot; : 0,</span><br><span class="line">            &quot;retries&quot; : &#123;</span><br><span class="line">              &quot;bulk&quot; : 0,</span><br><span class="line">              &quot;search&quot; : 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;throttled_millis&quot; : 0,</span><br><span class="line">            &quot;requests_per_second&quot; : -1.0,</span><br><span class="line">            &quot;throttled_until_millis&quot; : 0</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;description&quot; : &quot;reindex from [blog] to [blog_lastest][_doc]&quot;,</span><br><span class="line">          &quot;start_time_in_millis&quot; : 1609338953464,</span><br><span class="line">          &quot;running_time_in_nanos&quot; : 1276738396689,</span><br><span class="line">          &quot;cancellable&quot; : true,</span><br><span class="line">          &quot;headers&quot; : &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意观察里面的几个重要指标，例如从 <code>description</code> 中可以看到任务描述，从 tasks 中可以找到任务的 <code>id</code>【例如 <code>dpBihNSMQfSlboMGlTgCBA:6629305</code>】，从 <code>cancellable</code> 可以判断任务是否支持取消操作。<br>这个 API 其实就是模糊匹配，同理也可以查询其它类型的任务信息，例如使用 <code>GET _tasks?detailed=true&amp;actions=*byquery</code> 查看查询请求的状态。<br>当集群的任务太多时我们就可以根据<code>task_id</code>，也就是上面提到<code>GET /_tasks/task_id</code> 方式更加准确地查询指定任务的状态，避免集群的任务过多，不方便查看。<br>如果遇到操作失误的场景，想取消任务，有没有办法呢？<br>当然有啦，虽然覆水难收，通过调用<br><code>_tasks API</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _tasks/task_id/_cancel</span><br></pre></td></tr></table></figure>
<p>这里的 <code>task_id</code> 就是通过上面的查询任务接口获取的任务id（任务要支持取消操作，即【cancellable 为 true】时方能收效）。</p>
<h3 id="删除旧索引"><a href="#删除旧索引" class="headerlink" title="删除旧索引"></a>删除旧索引</h3><p>当我们通过 API 查询发现任务完成后，就可以进行后续操作，我这里是要删除旧索引，然后再给新索引起别名，用于替换旧索引，这样才能保证对外服务没有任何感知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /blog</span><br></pre></td></tr></table></figure>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    &quot;actions&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;add&quot;:&#123;</span><br><span class="line">                &quot;index&quot;:&quot;blog_lastest&quot;,</span><br><span class="line">                &quot;alias&quot;:&quot;blog&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过别名访问新索引"><a href="#通过别名访问新索引" class="headerlink" title="通过别名访问新索引"></a>通过别名访问新索引</h3><p>进行过以上操作后，我们可以使用一个简单的搜索验证服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /blog/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;match&quot;: &#123;</span><br><span class="line">			&quot;author&quot;: &quot;james&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果搜索结果达到我们的预期目标，至此，数据索引重建迁移完成。</p>
<h3 id="其他reindex的用法"><a href="#其他reindex的用法" class="headerlink" title="其他reindex的用法"></a>其他reindex的用法</h3><h4 id="source中包含多个源索引"><a href="#source中包含多个源索引" class="headerlink" title="source中包含多个源索引"></a>source中包含多个源索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: [&quot;twitter&quot;, &quot;blog&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;all_together&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也支持*号来匹配多个索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;twitter*&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;all_together&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="限制处理的记录数"><a href="#限制处理的记录数" class="headerlink" title="限制处理的记录数"></a>限制处理的记录数</h4><p>通过设置size大小来限制处理文档的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 10000,</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;twitter&quot;,</span><br><span class="line">    &quot;sort&quot;: &#123; &quot;date&quot;: &quot;desc&quot; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;new_twitter&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从远程ES集群中重建索引"><a href="#从远程ES集群中重建索引" class="headerlink" title="从远程ES集群中重建索引"></a>从远程ES集群中重建索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;remote&quot;: &#123;</span><br><span class="line">      &quot;host&quot;: &quot;http://otherhost:9200&quot;,</span><br><span class="line">      &quot;username&quot;: &quot;user&quot;,</span><br><span class="line">      &quot;password&quot;: &quot;pass&quot;,</span><br><span class="line">      &quot;socket_timeout&quot;: &quot;1m&quot;,</span><br><span class="line">      &quot;connect_timeout&quot;: &quot;10s&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;index&quot;: &quot;source&quot;,</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">      &quot;match&quot;: &#123;</span><br><span class="line">        &quot;test&quot;: &quot;data&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;dest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h4><p>重建索引，将原索引中的flag字段重命名为tag字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.tag = ctx._source.remove(\&quot;flag\&quot;)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 大家猜一下ctx是谁的简写？对了，就是context，表示文档的上下文，ctx._source 就是一个HashMap，可以使用HashMap的API操作，script使用的默认语法是painless，专为 Elasticsearch 脚本设计，扩展 Java 的语法并提供 Groovy 样式的脚本语言功能，使脚本更易于编写！</p>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>「Elasticsearch」SpringBoot快速集成ES</title>
    <url>/p/21452.html</url>
    <content><![CDATA[<blockquote>
<p>Elastic Search 的底层是开源库 Lucene。但是Lucene的使用门槛比较高，必须自己写代码去调用它的接口。而Elastic Search的出现正是为了解决了这个问题，它是 Lucene 的封装，提供了 REST API 的操作接口，我们可以开箱即用。</p>
</blockquote>
<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>JDK版本：8</li>
<li>SpringBoot:2.x</li>
<li>ES版本：7.1.1<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   集成es client，并排除低版本依赖(5.6)     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2>使用配置类配置，可以参考如下所示：<br>先创建一个builder，用于初始化ES client<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsClientBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">socketTimeoutMillis</span> <span class="operator">=</span> <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connectionRequestTimeoutMillis</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxConnectPerRoute</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxConnectTotal</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HttpHost&gt; httpHosts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EsClientBuilder</span><span class="params">(List&lt;HttpHost&gt; httpHosts)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpHosts = httpHosts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EsClientBuilder <span class="title function_">setConnectTimeoutMillis</span><span class="params">(<span class="type">int</span> connectTimeoutMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectTimeoutMillis = connectTimeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EsClientBuilder <span class="title function_">setSocketTimeoutMillis</span><span class="params">(<span class="type">int</span> socketTimeoutMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socketTimeoutMillis = socketTimeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EsClientBuilder <span class="title function_">setConnectionRequestTimeoutMillis</span><span class="params">(<span class="type">int</span> connectionRequestTimeoutMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionRequestTimeoutMillis = connectionRequestTimeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EsClientBuilder <span class="title function_">setMaxConnectPerRoute</span><span class="params">(<span class="type">int</span> maxConnectPerRoute)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxConnectPerRoute = maxConnectPerRoute;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EsClientBuilder <span class="title function_">setMaxConnectTotal</span><span class="params">(<span class="type">int</span> maxConnectTotal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxConnectTotal = maxConnectTotal;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EsClientBuilder <span class="title function_">build</span><span class="params">(List&lt;HttpHost&gt; httpHosts)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EsClientBuilder</span>(httpHosts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        HttpHost[] httpHostArr = httpHosts.toArray(<span class="keyword">new</span> <span class="title class_">HttpHost</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">RestClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RestClient.builder(httpHostArr);</span><br><span class="line"></span><br><span class="line">        builder.setRequestConfigCallback(requestConfigBuilder -&gt; &#123;</span><br><span class="line">            requestConfigBuilder.setConnectTimeout(connectTimeoutMillis);</span><br><span class="line">            requestConfigBuilder.setSocketTimeout(socketTimeoutMillis);</span><br><span class="line">            requestConfigBuilder.setConnectionRequestTimeout(connectionRequestTimeoutMillis);</span><br><span class="line">            <span class="keyword">return</span> requestConfigBuilder;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        builder.setHttpClientConfigCallback(httpClientBuilder -&gt; &#123;</span><br><span class="line">            httpClientBuilder.setMaxConnTotal(maxConnectTotal);</span><br><span class="line">            httpClientBuilder.setMaxConnPerRoute(maxConnectPerRoute);</span><br><span class="line">            <span class="keyword">return</span> httpClientBuilder;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再交给spring容器管理：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ESConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.nodes&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.schema&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String schema;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.max-connect-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxConnectTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.max-connect-per-route&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxConnectPerRoute;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.connection-request-timeout-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer connectionRequestTimeoutMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.socket-timeout-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer socketTimeoutMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.connect-timeout-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer connectTimeoutMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">getRestHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;HttpHost&gt; httpHosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String[] parts = StringUtils.split(node, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">                Assert.notNull(parts,<span class="string">&quot;Must defined&quot;</span>);</span><br><span class="line">                Assert.state(parts.length == <span class="number">2</span>, <span class="string">&quot;Must be defined as &#x27;host:port&#x27;&quot;</span>);</span><br><span class="line">                httpHosts.add(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(parts[<span class="number">0</span>], Integer.parseInt(parts[<span class="number">1</span>]), schema));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;Invalid ES nodes &quot;</span> + <span class="string">&quot;property &#x27;&quot;</span> + node + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EsClientBuilder.build(httpHosts)</span><br><span class="line">                .setConnectionRequestTimeoutMillis(connectionRequestTimeoutMillis)</span><br><span class="line">                .setConnectTimeoutMillis(connectTimeoutMillis)</span><br><span class="line">                .setSocketTimeoutMillis(socketTimeoutMillis)</span><br><span class="line">                .setMaxConnectTotal(maxConnectTotal)</span><br><span class="line">                .setMaxConnectPerRoute(maxConnectPerRoute)</span><br><span class="line">                .create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再配置一下常用的配置：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置es</span></span><br><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="comment">#  如果是cluster，application.yml的nodes设置多个ip:host逗号隔开即可。</span></span><br><span class="line">  <span class="attr">nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9200</span></span><br><span class="line">  <span class="attr">schema:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">max-connect-total:</span> <span class="number">50</span></span><br><span class="line">  <span class="attr">max-connect-per-route:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">connection-request-timeout-millis:</span> <span class="number">500</span></span><br><span class="line">  <span class="attr">socket-timeout-millis:</span> <span class="number">30000</span></span><br><span class="line">  <span class="attr">connect-timeout-millis:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>接下来我们测试一下配置是否生效，一个简单的验证送给大家，如下所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">MainResponse</span> <span class="variable">info</span> <span class="operator">=</span> client.info(RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(info.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
配置生效的话，就会返回Elastic Search的配置信息：包含当前节点、集群、版本等信息。<br>SpringBoot集成ES至此结束。</li>
</ul>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>「Elasticsearch」查询并删除匹配文档之_delete_by_query</title>
    <url>/p/6cce.html</url>
    <content><![CDATA[<blockquote>
<p>思路：先查询确认，后精准删除</p>
</blockquote>
<p>假设我想删除title是”小明今晚真的不加班“这条记录，先查看一下现有的记录：</p>
<p>(不加班不好吗？为什么要删除呢？)</p>
<span id="more"></span>
<blockquote>
<p>tips:可以使用<code>match_phrase</code>精准查询，查询命令可以通过curl查询，也可以通过其他工具请求（其实道理都一样）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http://192.168.16.65:9211/blog/_search&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;小明今晚真的不加班&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>

<p><code>blog</code>为索引，<code>_search</code>为es的查询指令，查询结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;took&quot;: 13,</span><br><span class="line">	&quot;timed_out&quot;: false,</span><br><span class="line">	&quot;_shards&quot;: &#123;</span><br><span class="line">		&quot;total&quot;: 3,</span><br><span class="line">		&quot;successful&quot;: 3,</span><br><span class="line">		&quot;skipped&quot;: 0,</span><br><span class="line">		&quot;failed&quot;: 0</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;hits&quot;: &#123;</span><br><span class="line">		&quot;total&quot;: &#123;</span><br><span class="line">			&quot;value&quot;: 1,</span><br><span class="line">			&quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;max_score&quot;: 110.28655,</span><br><span class="line">		&quot;hits&quot;: [&#123;</span><br><span class="line">			&quot;_index&quot;: &quot;blog&quot;,</span><br><span class="line">			&quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">			&quot;_id&quot;: &quot;6a0d343fb629da2e2cdf6f4bf250af04&quot;,</span><br><span class="line">			&quot;_score&quot;: 110.28655,</span><br><span class="line">			&quot;_source&quot;: &#123;</span><br><span class="line">				&quot;author&quot;: &quot;程序员小明&quot;,</span><br><span class="line">				&quot;capture_time&quot;: 1583820020000,</span><br><span class="line">				&quot;content&quot;: &quot;今晚终于可以王者荣耀带妹了&quot;,</span><br><span class="line">				&quot;title&quot;: &quot;小明今晚真的不加班&quot;,</span><br><span class="line">				&quot;top_domain&quot;: &quot;mynamecoder.com&quot;,</span><br><span class="line">				&quot;url&quot;: &quot;http://blog.mynamecoder.com&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到数据中有一条符合条件的文档，我们现在就要删除该文档。</p>
<p>删除<code>title</code>为”小明今晚真的不加班”的文档（忍痛）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http://127.0.0.1:9211/blog/_delete_by_query&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match&quot;:&#123;</span><br><span class="line">      &quot;title&quot;:&quot;小明今晚真的不加班&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 使用<code>_delete_by_query</code>时，必须指定索引，此处<code>blog</code>就是索引，<code>_delete_by_query</code>是elasticsearch的删除指令</p>
</blockquote>
<p>删除结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 147,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;deleted&quot;: 1,</span><br><span class="line">  &quot;batches&quot;: 1,</span><br><span class="line">  &quot;version_conflicts&quot;: 0,</span><br><span class="line">  &quot;noops&quot;: 0,</span><br><span class="line">  &quot;retries&quot;: &#123;</span><br><span class="line">    &quot;bulk&quot;: 0,</span><br><span class="line">    &quot;search&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;throttled_millis&quot;: 0,</span><br><span class="line">  &quot;requests_per_second&quot;: -1.0,</span><br><span class="line">  &quot;throttled_until_millis&quot;: 0,</span><br><span class="line">  &quot;total&quot;: 119,</span><br><span class="line">  &quot;failures&quot; : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注<code>total</code>（查询到的条数）和<code>deleted</code>（删除的总数）两个字段，最后不放心的话，可以再查询一下刚才那个文档是否还存在。</p>
<blockquote>
<p>tips:es执行删除的时候es并不是立即删除，虽然我们再次查询已经找不到了，但es自身是将该文档先标记准备删除状态，一段时间后，异步删除。</p>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git删除暂存区或版本库中的文件</title>
    <url>/p/48.html</url>
    <content><![CDATA[<h1 id="故事提要"><a href="#故事提要" class="headerlink" title="故事提要"></a>故事提要</h1><blockquote>
<p>小明今天遇到了一个bug，莫名奇妙改着改着就乱了，万分后悔，一心想回退到之前的版本重新开始，不过庆幸的是使用了git托管，一起来看看git作为管理工具的强大之处吧。</p>
</blockquote>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Git有三大区（工作区、暂存区、版本库）以及几个状态（untracked、unstaged、uncommited），下面只是简述下Git的大概工作流程，详细的可以参见<a class="link"   href="http://www.cnblogs.com/cposture/category/642672.html" >其他有关Git的文章<i class="fas fa-external-link-alt"></i></a>。 </p>
<ul>
<li><p>打开你的项目文件夹，除了隐藏的.git文件夹，其他项目文件位于的地方便是工作区，工作区的文件需要添加到Git的暂存区（git add），随后再提交到Git的版本库（git commit）。</p>
</li>
<li><p>首次新建的文件都是untracked状态（未跟踪），此时需要git add到暂存区，Git便会在暂存区中生成一个该文件的索引，文件此时处于uncommited状态，需要git commit生成版本库。添加到了版本库之后，再对文件进行修改，那么文件的状态会变为unstaged状态。<br>简单的认识了Git的工作流程，接下来便可以看看如何删除错误添加到暂存区或版本库里的文件了！</p>
<h1 id="删除错误添加到暂存区的文件"><a href="#删除错误添加到暂存区的文件" class="headerlink" title="删除错误添加到暂存区的文件"></a>删除错误添加到暂存区的文件</h1></li>
</ul>
<p>有时你在工作区新建了文件TestFile，并且已经将它添加到了暂存区，git会告知，现有有一个文件未提交到版本库，如下图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/t3dWQ1r/2019-05-07-6-32-30.png"
                      alt="未提交到版本库"
                ></p>
<h1 id="仅仅删除暂存区里的文件"><a href="#仅仅删除暂存区里的文件" class="headerlink" title="仅仅删除暂存区里的文件"></a>仅仅删除暂存区里的文件</h1><p>此时你想撤销错误添加到暂存区里的文件，可以输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cache 文件名</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/fkp4Khq/2019-05-07-6-33-26.png"
                      alt="撤销错误添加到暂存区"
                ></p>
<p>上面的命令仅仅删除暂存区的文件而已，不会影响工作区的文件，如上图，TestFile.txt仍然存在，此时输入下面命令，git会告知有一个未跟踪的文件TestFile.txt。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<h1 id="删除暂存区和工作区的文件"><a href="#删除暂存区和工作区的文件" class="headerlink" title="删除暂存区和工作区的文件"></a>删除暂存区和工作区的文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -f 文件名</span><br></pre></td></tr></table></figure>
<p><strong>工作区的文件也被删除了。</strong></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/K6K77vj/2019-05-07-6-33-54.png"
                      alt="工作区的文件"
                ></p>
<h1 id="删除错误提交的commit"><a href="#删除错误提交的commit" class="headerlink" title="删除错误提交的commit"></a>删除错误提交的commit</h1><p>有时，不仅添加到了暂存区，而且commit到了版本库，这个时候就不能使用git rm了，需要使用git reset命令。<br>错误提交到了版本库，此时无论工作区、暂存区，还是版本库，这三者的内容都是一样的，所以在这种情况下，只是删除了工作区和暂存区的文件，下一次用该版本库回滚那个误添加的文件还会重新生成。<br>这个时候，我们必须撤销版本库的修改才能解决问题！<br>git reset有三个选项，–hard、–mixed、–soft。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//仅仅只是撤销已提交的版本库，不会修改暂存区和工作区</span><br><span class="line">git reset --soft 版本库ID</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//仅仅只是撤销已提交的版本库和暂存区，不会修改工作区</span><br><span class="line">git reset --mixed 版本库ID</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//彻底将工作区、暂存区和版本库记录恢复到指定的版本库</span><br><span class="line">git reset --hard 版本库ID</span><br></pre></td></tr></table></figure>

<p>那我们到底应该用哪个选项好呢？</p>
<ul>
<li>如果你是在提交了后，对工作区的代码做了修改，并且想保留这些修改，那么可以使用git reset –mixed 版本库ID，注意这个版本库ID应该不是你刚刚提交的版本库ID，而是刚刚提交版本库的上一个版本库。如下图：</li>
<li>如果不想保留这些修改，可以直接使用彻底的恢复命令，git reset –hard 版本库ID。</li>
<li>为什么不使用–soft呢，因为它只是恢复了版本库，暂存区仍然存在你错误提交的文件索引，还需要进一步使用上一节的删除错误添加到暂存区的文件，详细见上文。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/L9QcfCR/2019-05-07-6-34-10.png"
                      alt="版本历史"
                ></p>
<h2 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git小技巧--如何从其他分支merge个别文件或文件夹</title>
    <url>/p/8834.html</url>
    <content><![CDATA[<blockquote>
<p>小明发现在实际项目开发过程中，总会遇到各种各样的情况，比如一个大型的项目或版本迭代可能不是一次上线，可能会分好几次上线，这时候就会涉及创建多个分支，分别开发。</p>
</blockquote>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>产品经理：我们本次开发三个功能，列表页功能、详情页功能、系统消息功能，分两次上线，先上列表功能，再上详情页和系统消息。</p>
<p>小明：好的吧。</p>
<p>紧接着，小明就将本次需求分为2个分支，分别为A、B。</p>
<ul>
<li>A：开发列表页功能</li>
<li>B：开发详情页功能、系统消息功能</li>
</ul>
<p><strong>原计划</strong>：产品经理说先上列表功能，那小明就先开发A分支，列表功能很快开发完成（厉害吧）。</p>
<p><strong>计划有变</strong>：风云变幻，第二天小明按照计划开发B分支，开发到一半，产品经理突然说目前的系统消息功能（位于B分支）比较紧急，需要和列表功能（位于A分支）一起上线，当时小明就懵逼了。赶紧暂停开发详情页（位于B分支，虽然已经开发了一部分），转战系统消息功能的开发。当系统消息功能开发完成之后，就需要考虑将系统消息功能（位于B分支）和列表功能（位于A分支）放在一个分支上提测（开发一部分的详情页功能暂先不需要合并）的问题，这时候<strong>分支合并</strong>就要派上用场了。</p>
<h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>说起<strong>分支合并</strong>，大家第一个想到的命令肯定是<code>git merge</code> ，因为这是<strong>分支合并</strong>的常用命令。</p>
<p>使用<code>git merge</code> 合并分支会将两个分支的<strong>所有内容</strong>进行比较合并，因此我们如果想合并两个分支中的<strong>一部分</strong>，显然直接使用这个命令是行不通的。</p>
<p>So what happens next ? 嘿嘿，有两种方案可供我们选择：</p>
<h2 id="强制合并"><a href="#强制合并" class="headerlink" title="强制合并"></a>强制合并</h2><p>从其他分支<code>merge</code>指定文件到当前分支，<code>git checkout</code>是个合适的工具。</p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout source_branch &lt;path&gt;...</span><br></pre></td></tr></table></figure>

<p>我们使用git checkout 将B分支上的系统消息功能添加到A分支上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  * A  </span><br><span class="line">    B</span><br><span class="line">    </span><br><span class="line">$ git checkout B message.html message.css message.js other.js</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"># On branch A</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#    new file:   message.css</span><br><span class="line">#    new file:   message.html</span><br><span class="line">#    new file:   message.js</span><br><span class="line">#    modified:   other.js</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>合并完成</p>
<p>但是……</p>
<p><strong>注意：在使用git checkout某文件到当前分支时，会将当前分支的对应文件强行覆盖</strong></p>
<p>因此，合并A分支上没有存在的文件没问题，但是如果合并A分支上原先就存在的文件（比如两个分支上都对<strong>other.js</strong>进行过修改），位于分支A上的文件<strong>other.js</strong>就会被<strong>checkout</strong>（分支B）过来的<strong>other.js</strong>覆盖，导致分支A上之前开发的<strong>列表功能</strong>付之东流，这样做肯定是优雅的！</p>
<p>那如何避免同一个文件不强制覆盖，有没有更好的解决方案呢（调一下味口）？我们一起来看一下第二种方案。</p>
<h2 id="智能合并"><a href="#智能合并" class="headerlink" title="智能合并"></a>智能合并</h2><p><strong>思路</strong>：曲线救国，我们通过<strong>git merge</strong> 强大的分支合并功能来完成此次无缝合并。</p>
<ol>
<li>首先使用<code>git checkout</code>根据A分支创建一个A_temp分支(避免影响A分支)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b A_temp</span><br><span class="line">Switched to a new branch &#x27;A_temp&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后将B分支合并到A_temp分支，此时两个都经修改过的文件会跑出冲突，我们只需解决冲突即可。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge B</span><br><span class="line">Updating 1f73596..04627b5</span><br><span class="line">Fast-forward</span><br><span class="line"> message.css                     | 0</span><br><span class="line"> message.html                    | 0</span><br><span class="line"> message.js                      | 0</span><br><span class="line"> other.js                        | 1 +</span><br><span class="line"> 4 files changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 message.css</span><br><span class="line"> create mode 100644 message.html</span><br><span class="line"> create mode 100644 message.js</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再次切换到A分支，并使用<strong>git checkout</strong> 将A_temp分支上的系统消息功能相关文件或文件夹覆盖到A分支，此时可以大胆的覆盖！因为我们已经在第二步处理过冲突问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ git checkout A</span><br><span class="line">Switched to branch &#x27;A&#x27;</span><br><span class="line"></span><br><span class="line">$ git checkout A_temp message.html message.css message.js other.js</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"># On branch A</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#    new file:   message.css</span><br><span class="line">#    new file:   message.html</span><br><span class="line">#    new file:   message.js</span><br><span class="line">#    modified:   other.js</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>最后，有强迫症的患者可以卸磨杀驴，把刚刚根据分支A创建的A_temp删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d A_temp</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>OK，到此分支合并就完结了，现在我们就可以自信地召唤产品经理（我们公司产品兼测试）测试这两个功能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>另外给大家介绍一下<code>git merge</code> 使用的小技巧</p>
<p>举例：要把<code>master</code>分支合并到<code>dev</code>分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout dev // 切换到dev分支</span><br><span class="line">git merge master --no-ff // 使用--no-ff</span><br></pre></td></tr></table></figure>

<p>默认使用<code>merge</code>命令是<code>ff</code>，即 <code>fast-forward</code>，这种方式从Git 合并历史中是无法查看到是哪几个提交对象在一起实现了一个功能。</p>
<p>而<code>--no-ff</code> 标记会在分支合并的时候，创建一个新的提交对象，可以避免丢失<code>master</code>分支的历史信息，并且把所有的功能叠加在一起提交上去。两者的区别如下图所示，大家可以自己体验一下两者的区别。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/09/18/nHeDPS.png"
                      alt="两者的区别"
                ></p>
<p>以上就是小明工作中使用git合并总结的经验，希望能帮助到大家，仅供参考，有错误请指出，谢谢！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo忽略编译某些文件</title>
    <url>/p/d2c.html</url>
    <content><![CDATA[<p>我们需要自己定义一些页面，比如：404.html，需要在<code>source</code>目录下填加一个<code>demo</code>目录放一些示例文件，hexo默认会编译<code>source</code>目录下的所有文件。但demo目录并不需要编译，<code>_config.yml</code>有提供一个配置项<code>skip_render</code>, 官网说明：</p>
<blockquote>
<p>skip_render：跳过指定文件的渲染，您可使用<a class="link"   href="https://github.com/isaacs/minimatch" >glob表达式<i class="fas fa-external-link-alt"></i></a>来匹配路径。</p>
</blockquote>
<p>glob表达式链接的是<code>minimatch</code>，说明路径匹配用的应该是<code>minimatch</code>这个npm模块包来完成的。需要指出的是这里面配置的路径都是相对<code>source</code>目录的。</p>
<ol>
<li><p>如何需要跳过<code>source</code>目录下文件的编译:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 跳过单个文件</span><br><span class="line">skip_render: test.html</span><br><span class="line"></span><br><span class="line">// 跳过所有的html的文件</span><br><span class="line">skip_render: &#x27;*.html&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳过某一目录下的所有文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: test/*</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要跳过某一目录下的所有文件和子目录时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: test/**</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳过多个目录，或者多个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 最新版本的hexo，用这个好使</span><br><span class="line">skip_render: [&#x27;*.html&#x27;, demo/**, test/*]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>看见有人是说是这样，反正我试不管事，可能的版本的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 我试了试，不管事啊。</span><br><span class="line">skip_render:</span><br><span class="line">    - test1/*.html</span><br><span class="line">    - test2/**</span><br></pre></td></tr></table></figure>

<p>ps：</p>
<ol>
<li><p>如果设置<code>skip_render</code>不起作用，可以先执行<code>hexo clean</code>清除一下缓存。</p>
</li>
<li><p>如果跳过多个目录编译失败，请尝试更新<code>hexo</code>, 在<code>source</code>同级目录中执行<code>npm update hexo</code></p>
</li>
<li><p>如果需要查看是否成功跳过编译，可以在编译的时候加上<code>--debug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate --debug</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>关注打印出来的<code>Rendering xxxx</code> 中的东西。</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo推荐插件</title>
    <url>/p/17116.html</url>
    <content><![CDATA[<h3 id="1、缩短生成的静态页面名"><a href="#1、缩短生成的静态页面名" class="headerlink" title="1、缩短生成的静态页面名"></a>1、缩短生成的静态页面名</h3><p>每次从博客分享文章给别人都很苦恼，Hexo 默认生成的链接太长了，而且一旦文章名字改变，链接也跟着改变。有没有什么方法让地址尽量短小精悍，同时永久化呢？</p>
<p>感谢 <code>rozbo/hexo-abbrlink</code>，完美解决此痛点。</p>
<p>使用方法也很简单：</p>
<p>在 Hexo 博客根目录，执行 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>在 _config.yml 配置文件写入</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc16</span> <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#support dec(default) and hex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处为更改 permalink的值</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">p/:abbrlink.html</span> </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+git搭建自己的博客</title>
    <url>/p/2969.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>喜欢写 Blog 的人，会经历三个阶段。</p>
<p>第一阶段，刚接触 Blog，觉得很新鲜，试着选择一个免费空间来写。<br>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。<br>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>这是阮一峰在博客中写到的关于 Blog 的想法，而这里的第三阶段的实现就是利用 GitHub Pages 搭建博客。</p>
<p>使用 GitHub Pages 功能搭建博客的好处有：</p>
<ul>
<li>免费，GitHub 提供无限流量。</li>
<li>都是静态文件，世界各地都有理想的访问速度。(访问速度可以进一步优化)</li>
<li>拥有绝对的管理权，又享受 Git 的版本管理功能，不用担心文章遗失。</li>
</ul>
<p>Hexo 是基于 Node.js 的一款静态博客框架，如果想要搭建博客，不想自己写页面的话可以考虑用 Hexo，其中有很多的简洁主题可供选择，同时 Hexo 支持 Markdown 语法，编辑文章更加方便，快捷。</p>
<p><strong>注：此篇分享还以 Mac 为例哈</strong></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><a class="link"   href="https://hexo.io/zh-cn/docs/" >Hexo 文档<i class="fas fa-external-link-alt"></i></a>有对 Hexo 安装及使用的详细介绍，推荐阅读。这里我主要写自己安装的步骤、踩过的坑以及一些优化的方法。</p>
<p>在正式安装 Hexo 之前，我们需要确认电脑中是否已安装下列应用程序:</p>
<ul>
<li><a class="link"   href="https://nodejs.org/en/" >Node.js<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://git-scm.com/" >Git<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>当然，我们还需要 GitHub 账号，如果没有请<a class="link"   href="https://github.com/" >注册<i class="fas fa-external-link-alt"></i></a>。<br>注册之后记得一定要前往邮箱确认注册，否则无法使用 GitHub Pages。</p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。终端输入如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>输入管理员密码( Mac 登录密码)即开始安装。</p>
<blockquote>
<p>这里有个小坑：<a class="link"   href="https://hexo.io/zh-cn/docs/" >Hexo 官网<i class="fas fa-external-link-alt"></i></a>上的安装命令是<code>npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>使用终端<code>cd</code>到一个您指定的目录，执行以下命令(命令中的<code>blog</code>是您将要建立的文件夹的名称)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p>使用终端<code>cd</code>到<code>blog</code>文件夹下，执行以下命令，安装npm：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>好了，现在可以试试看是否已经初始化成功，执行如下命令，开启本地 Hexo 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>此时，浏览器中打开网址(默认是4000端口) <a class="link"   href="http://localhost:4000/" >http://localhost:4000<i class="fas fa-external-link-alt"></i></a> ，能看到如下页面：</p>
<p><a href="https://camo.githubusercontent.com/1f1940bfde096eddda51c3856fde79e2ba5068be/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30352f353964356337386634616161652e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/1f1940bfde096eddda51c3856fde79e2ba5068be/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30352f353964356337386634616161652e706e67"
                      alt="Hexo 本地"
                ></a></p>
<p>这里我踩了个不算坑的坑，终端输入<code>hexo s</code>后没有成功，我也在网上搜到了很多解决办法，但是都没有奏效，后来我尝试改了下端口就成功了，也就是说默认的4000端口无法连接。如果您的情况跟我一样，尝试了网上的很多解决办法之后依然无效，那您也许可以尝试输入命令<code>hexo s -p 5000</code>改一下端口试试看。</p>
<h2 id="关联-GitHub"><a href="#关联-GitHub" class="headerlink" title="关联 GitHub"></a>关联 GitHub</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><ol>
<li>登录您的 GitHub 账号，新建名称为<code>您的用户名.github.io</code>的仓库。假设我的 GitHub 账号的用户名是 <code>luxun</code>，那么我就应该新建名称为<code>luxun.github.io</code>的仓库。</li>
<li><code>Description</code>可写可不写，随意。</li>
<li>勾上<code>Initialize this repository with a README</code>。</li>
<li>点击<code>Create Repository</code>完成创建。</li>
</ol>
<h3 id="开启-GitHub-Pages"><a href="#开启-GitHub-Pages" class="headerlink" title="开启 GitHub Pages"></a>开启 GitHub Pages</h3><p>点击<code>Settings</code>，你将会打开这个库的 Settings 页面，向下拖动，直到看见 GitHub Pages，如图：</p>
<p><a href="https://camo.githubusercontent.com/bf5629a7167f6a0f931edd10a231e1520793e202/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f31302f30362f353964366531306239636235662e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/bf5629a7167f6a0f931edd10a231e1520793e202/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f31302f30362f353964366531306239636235662e706e67"
                      alt="gh-p"
                ></a></p>
<h3 id="修改全局配置文件"><a href="#修改全局配置文件" class="headerlink" title="修改全局配置文件"></a>修改全局配置文件</h3><p><a class="link"   href="https://hexo.io/zh-cn/docs/configuration.html" >Hexo 官方文档<i class="fas fa-external-link-alt"></i></a>中有对全局配置的详细说明，推荐阅读。</p>
<blockquote>
<p>小坑提醒，修改本地所有的配置文件时，注意所有的冒号<code>:</code>后边都要加一个空格，否则执行 Hexo 命令时会报错，一定注意。</p>
</blockquote>
<p>找到本地<code>blog</code>文件夹下<code>_config.yml</code>，打开后滑到最后，修改成下边的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>您需要将<code>repository</code>后的所有<code>xxx</code>换成你自己的用户名，或者也可以在下图位置获取：</p>
<p><a href="https://camo.githubusercontent.com/6d9ac169f0d7ce162c61926fbc7438be266647c3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30362f353964373166333333313334332e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/6d9ac169f0d7ce162c61926fbc7438be266647c3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30362f353964373166333333313334332e706e67"
                      alt="https 地址"
                ></a></p>
<p>然后，您需要为自己配置身份信息，终端输入<code>yourname</code>和<code>youremail</code>换成您自己的 GitHub 用户名和邮箱)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>

<p>终端<code>cd</code>到<code>blog</code>文件夹下执行生成静态页面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>此时若出现如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: &#x27;npm install hexo --save&#x27;</span><br></pre></td></tr></table></figure>

<p>尝试执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>

<p>若无报错，自行忽略此步骤。</p>
<p>然后在当前目录下，终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>这里踩了个坑，如果您执行命令<code>hexo d</code>仍然报错：无法连接 git 或找不到 git，则执行如下命令来安装<code>hexo-deployer-git</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>完成安装之后，再次执行<code>hexo g</code>和<code>hexo d</code>命令。</p>
<p>随后按照提示，分别输入自己的 GitHub 用户名和密码，开始上传。</p>
<p>完成上传之后，通过<code>http://xxx.github.io/</code> (<code>xxx</code>换成您自己的仓库名，也就是用户名)来访问自己刚刚上传的网站。</p>
<ul>
<li>为避免每次输入 GitHub 用户名和密码的麻烦，可参照后文 <strong>优化(个性化设置)</strong> <code>添加ssh key 到 GitHub</code>进行优化</li>
</ul>
<h2 id="常用指令和发布文章"><a href="#常用指令和发布文章" class="headerlink" title="常用指令和发布文章"></a>常用指令和发布文章</h2><ul>
<li>常用指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot;        //新建文章</span><br><span class="line">hexo new page &quot;pageName&quot;        //新建页面</span><br><span class="line">hexo g          //生成静态页面至public目录</span><br><span class="line">hexo server         //开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy         //将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure>

<ul>
<li>常用组合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo d -g #生成部署</span><br><span class="line">hexo s -g #生成预览</span><br></pre></td></tr></table></figure>

<ul>
<li>发布文章</li>
</ul>
<p>终端<code>cd</code>到<code>blog</code>文件夹下，执行如下命令新建文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>名为<code>xxx.md</code>的文件会建在目录<code>.../blog/source/_posts</code>下。</p>
<p>所有的文章都会以<code>md</code>形式保存在<code>_post</code>文件夹中，只要在<code>_post</code>文件夹中新建<code>md</code>类型的文档，就能在执行<code>hexo g</code>的时候被渲染。新建的文章头需要添加一些信息，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx    //在此处添加你的标题。</span><br><span class="line">date: 2016-10-07 13:38:49   //在此处输入编辑这篇文章的时间。</span><br><span class="line">tags: xxx    //在此处输入这篇文章的标签。</span><br><span class="line">categories: xxx    //在此处输入这篇文章的分类。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>文章编辑完成后，终端<code>cd</code>到<code>blog</code>文件夹下，依次执行如下命令来发布：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>至此，Mac 上搭建基于 GitHub Pages + Hexo 的博客就完成了。</p>
<p>下面的内容是介绍安装 Themes 、个性化设置以及优化。</p>
<h2 id="设置-Themes"><a href="#设置-Themes" class="headerlink" title="设置 Themes"></a>设置 Themes</h2><p>如果您喜欢 Hexo 默认的主题的话，可以跳过这部分。如果您想换一个主题的话，可以到<a class="link"   href="https://hexo.io/themes/" >Hexo 主题<i class="fas fa-external-link-alt"></i></a>挑选自己中意的主题。</p>
<p>这里以<a class="link"   href="https://github.com/iissnan/hexo-theme-next" >nexT 主题<i class="fas fa-external-link-alt"></i></a>为例。</p>
<p>终端<code>cd</code>到<code>blog</code>目录下执行如下命令(这是目前的稳定版本，不是最新版。最新版有一些新特性，但是可能会不稳定，所以这里推荐选择安装稳定版)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>如果想尝试最新版，请执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>打开<code>blog</code>目录下的<code>_config.yml</code>，找到<code>theme: landscape</code>修改为<code>theme: next</code>。</p>
<p>终端<code>cd</code>到<code>blog</code>目录下，依次执行如下命令(每次部署文章的步骤)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>至于更改博客的名称、描述、头像等，只需要修改<code>blog/_config.yml</code>文件和<code>blog/themes/next/_config.yml</code>文件中对应的属性名称即可(不要忘记冒号<code>:</code>后加空格)。</p>
<ul>
<li>更多设置<a class="link"   href="http://theme-next.iissnan.com/" >NexT 使用文档<i class="fas fa-external-link-alt"></i></a>里有极详细的介绍，推荐阅读。</li>
</ul>
<h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><ul>
<li><strong>首先参照NexT 官方文档进行个性化设置，之后再看下文。</strong></li>
</ul>
<h3 id="为博客加上-GitHub-丝带"><a href="#为博客加上-GitHub-丝带" class="headerlink" title="为博客加上 GitHub 丝带"></a>为博客加上 GitHub 丝带</h3><p>这里以 Next 主题为例(其他主题也差不多)，添加 GitHub 丝带：在<code>blog\themes\next\layout\_layout.swig</code>中加入<a class="link"   href="https://github.com/blog/273-github-ribbons" >相关代码<i class="fas fa-external-link-alt"></i></a>，记得修改自己的链接。</p>
<h3 id="添加-README-md"><a href="#添加-README-md" class="headerlink" title="添加 README.md"></a>添加 README.md</h3><p>每个项目仓库下一般都有一个 <code>README.md</code> 文件，但是使用 hexo 部署到仓库后，项目仓库中是没有 <code>README.md</code> 文件的。</p>
<p>在 <code>blog</code> 目录下的 <code>source</code> 目录下添加一个 <code>README.md</code> 文件，修改站点配置文件 <code>_config.yml</code>，将 <code>skip_render</code> 参数的值设置为 <code>README.md</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure>

<p>保存退出即可。</p>
<h3 id="为博客添加-LICENSE"><a href="#为博客添加-LICENSE" class="headerlink" title="为博客添加 LICENSE"></a>为博客添加 LICENSE</h3><p>在主题配置文件中添加下面这段代码(添加之前先看看您的主题配置文件是否已经包含这段代码，已经包含就不用添加了，因为重复会报错)，LICENSE 会显示在侧边栏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># http://creativecommons.org/</span><br><span class="line"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line">creative_commons: by-nc-sa</span><br><span class="line">#creative_commons:</span><br></pre></td></tr></table></figure>

<h3 id="修改文章底部的带-号的标签"><a href="#修改文章底部的带-号的标签" class="headerlink" title="修改文章底部的带 # 号的标签"></a>修改文章底部的带 <code>#</code> 号的标签</h3><p>如果您觉得<code>#</code>不好看，想改成图标，那么请按照下面修改。<br>打开<code>/themes/next/layout/_macro/post.swig</code>，搜索(组合键<code>command</code>+<code>f</code>)<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。</p>
<h3 id="将阅读量改为热度"><a href="#将阅读量改为热度" class="headerlink" title="将阅读量改为热度"></a>将阅读量改为热度</h3><p>很多人将文章标题下的 <strong>阅读次数</strong> 改为了 <strong>热度</strong>，如果您喜欢的话可以这样修改。</p>
<p>打开<code>blog/themes/next/languages/zh-Hans</code>文件，查找<code>阅读次数</code>这几个字，可以看到，在<code>post</code>中的<code>visitors</code>被定义为<code>阅读次数</code>，把这里的<code>阅读次数</code>改为<code>热度</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visitors: 热度</span><br></pre></td></tr></table></figure>

<p>那么怎么在页面中显示呢？打开Next主题文件夹中<code>blog/themes/next/layout/_macro/post.swig</code>，在这个文件里加上摄氏度的标志，在<code>&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</code>下面增加一行<code>&lt;span&gt;℃&lt;/span&gt;</code>即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><ul>
<li>修改 hexo-generator-index 插件</li>
</ul>
<p>替换文件<code>blog/node_modules/hexo-generator-index/lib/generator.js</code> 内的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var pagination = require(&#x27;hexo-pagination&#x27;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &#x27;page&#x27;;</span><br><span class="line">  return pagination(&#x27;&#x27;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&#x27;index&#x27;, &#x27;archive&#x27;],</span><br><span class="line">    format: paginationDir + &#x27;/%d/&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置文章置顶</li>
</ul>
<p>在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx</span><br><span class="line">date: 2015-04-02 14:36:04</span><br><span class="line">categories: xxx</span><br><span class="line">tags: xxx</span><br><span class="line">top: 10</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="NexT-首页文章-加载更多-设置"><a href="#NexT-首页文章-加载更多-设置" class="headerlink" title="NexT 首页文章 加载更多 设置"></a>NexT 首页文章 加载更多 设置</h3><p>这里只说一个方法：编辑文章时，在您希望显示 <code>加载更多</code> 按钮的地方，加上<code>&lt;!--more--&gt;</code>：</p>
<p><a href="https://camo.githubusercontent.com/a4a9629c1d7a4d8fe4a869a4656c208b9dc955a3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964616366616432333134632e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/a4a9629c1d7a4d8fe4a869a4656c208b9dc955a3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964616366616432333134632e706e67"
                      alt="more"
                ></a></p>
<h3 id="首页分割线"><a href="#首页分割线" class="headerlink" title="首页分割线"></a>首页分割线</h3><p>  在 <code>\themes\next\source\css\_custom\custom.styl</code> 文件中添加以下代码，可以修改博客首页中每篇文章的分割线样式，<code>width</code>是长度，<code>height</code>是宽度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//index页面中每篇文章相隔的那条线</span><br><span class="line">.posts-expand &#123;</span><br><span class="line">  .post-eof &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    margin: $post-eof-margin-top auto $post-eof-margin-bottom;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 3px;</span><br><span class="line">    background: $grey-light;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小图标设置"><a href="#小图标设置" class="headerlink" title="小图标设置"></a>小图标设置</h3><p>博客中一切小图标都可以在<a class="link"   href="http://fontawesome.io/icons/" >fontawesome 图标库<i class="fas fa-external-link-alt"></i></a>自行搜索(qq、微博、微信等图标是有的，但知乎、豆瓣等图标目前还没有)。</p>
<ul>
<li>修改网页底部的桃心图标<br>打开<code>blog/themes/next/layout/_partials/footer.swig</code>，找到这段代码进行修改(还是在<a class="link"   href="http://fontawesome.io/icons/" >fontawesome 图标库<i class="fas fa-external-link-alt"></i></a>找自己喜欢的图标)：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span class=&quot;with-love&quot;&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-share-alt&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h3 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h3><p>准备一张 icon 图标文件，放在 source 目录下就可以了，在<code>主题配置文件</code>中找到 favicon 的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Put your favicon.ico into `hexo-site/source/` directory.</span><br><span class="line">favicon: /favicon.ico</span><br></pre></td></tr></table></figure>

<h3 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>具体实现方法</p>
<p>打开<code>blog\themes\next\source\css\_custom\custom.styl</code>文件，添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏网页底部-powered-By-Hexo-强力驱动"><a href="#隐藏网页底部-powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部 powered By Hexo / 强力驱动"></a>隐藏网页底部 powered By Hexo / 强力驱动</h3><p>打开<code>blog/themes/next/layout/_partials/footer.swig</code>，使用<code>&lt;!--</code> <code>--&gt;</code>隐藏符号之间的代码即可，或者直接将这段代码删除。位置如图：</p>
<p><a href="https://camo.githubusercontent.com/ccd1f539b033ed7f11d9f8ae7f5f052b9a79944e/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964396236313963646232372e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/ccd1f539b033ed7f11d9f8ae7f5f052b9a79944e/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964396236313963646232372e706e67"
                      alt="隐藏底部 Hexo"
                ></a></p>
<h3 id="添加-SSH-key-到-GitHub"><a href="#添加-SSH-key-到-GitHub" class="headerlink" title="添加 SSH key 到 GitHub"></a>添加 SSH key 到 GitHub</h3><ul>
<li>检查 SSH keys 是否已经存在</li>
</ul>
<p>终端执行如下命令，检查SSH keys是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果显示如下信息(下面是我个人的显示，也许您跟我显示的不一样，但重点是只要有<code>id_rsa</code>和<code>id_rsa.pub</code>)，就说明 SSH keys 已经存在了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id_rsa	   id_rsa.pub	  known_hosts</span><br></pre></td></tr></table></figure>

<p>如果存在，则直接跳过下一个步骤进入<code>将 SSH key 添加到 GitHub 中</code>，否则请继续下一步骤 <code>生成新的 SSH key</code>。</p>
<ul>
<li>生成新的 SSH key</li>
</ul>
<p>终端执行如下命令生成新的 SSH key，注意将<code>your_email@example.com</code>换成你自己注册 GitHub 的邮箱地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>默认会在相应路径<code>~/.ssh</code>下生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<p>1.3.将 SSH key 添加到 GitHub 中</p>
<p>终端依次输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制所有显示的内容</p>
<p>进入GitHub –&gt; Settings –&gt; SSH and GPG keys –&gt; NEW SSH key，如下图所示：</p>
<p><a href="https://camo.githubusercontent.com/74765507927a29b4bef4b04a5c0dc470e4a62a5d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663639656337332e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/74765507927a29b4bef4b04a5c0dc470e4a62a5d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663639656337332e706e67"
                      alt="settings"
                ></a></p>
<p><a href="https://camo.githubusercontent.com/4aac3af0611d3b11a554f9d8b297826d8d73733c/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663830393662372e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/4aac3af0611d3b11a554f9d8b297826d8d73733c/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663830393662372e706e67"
                      alt="ssh_key"
                ></a></p>
<p>Title 里任意添一个标题，将复制的内容粘贴到 Key 里，点击下方 Add SSH key 绿色按钮即可，如下图所示：</p>
<p><a href="https://camo.githubusercontent.com/d7f739371b722e2a5e69a4b10c536c866bc32a64/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383532306339666362632e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/d7f739371b722e2a5e69a4b10c536c866bc32a64/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383532306339666362632e706e67"
                      alt="add_ssh_key"
                ></a></p>
<h3 id="绑定独立域名"><a href="#绑定独立域名" class="headerlink" title="绑定独立域名"></a>绑定独立域名</h3><ul>
<li>首先，需要注册一个域名。可以选择<a class="link"   href="https://www.godaddy.com/" >GoDaddy<i class="fas fa-external-link-alt"></i></a>或<a class="link"   href="https://wanwang.aliyun.com/" >万网<i class="fas fa-external-link-alt"></i></a>中的任意一家。</li>
<li>然后，我们需要配置一下域名解析。推荐使用<a class="link"   href="https://www.dnspod.cn/" >DNSPod<i class="fas fa-external-link-alt"></i></a>的服务，免费稳定，解析速度也比较快。在域名注册商处(Godaddy 或万网)修改 NS 服务器地址为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1g1ns1.dnspod.net</span><br><span class="line">f1g1ns2.dnspod.net</span><br></pre></td></tr></table></figure>

<p>域名解析详细的步骤这里我就不写了，给个图：</p>
<p><a href="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67"
                      alt="dnspod"
                ></a></p>
<p>图中设置国内国外的原因是想让博客加载速度更快，方法请阅读后文 <strong>将个人博客同时部署到 GitHub 和 Coding</strong>。</p>
<ul>
<li>如果将域名指向另一个域名，实现与被指向域名相同的访问效果，需要增加 CNAME 记录。</li>
</ul>
<p>进入 <code>blog/source</code> 目录下，添加并打开 <code>CNAME</code> 文件，输入您的域名，重新上传您的博客。</p>
<p>在 GitHub 中打开您自己的博客仓库，进入库的 Settings 界面，如果看到了如下提示，说明配置成功了。</p>
<p><a href="https://camo.githubusercontent.com/6431246933090b54e265ac2ea1cc8c19ceefa85b/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613432336336353138392e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/6431246933090b54e265ac2ea1cc8c19ceefa85b/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613432336336353138392e706e67"
                      alt="CNAME"
                ></a></p>
<p>在这一系列的操作中，修改 NS 服务器、设置解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的 DNS 服务器。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="将个人博客同时部署到-GitHub-和-Coding"><a href="#将个人博客同时部署到-GitHub-和-Coding" class="headerlink" title="将个人博客同时部署到 GitHub 和 Coding"></a>将个人博客同时部署到 GitHub 和 Coding</h3><p><a class="link"   href="https://coding.net/" >Coding<i class="fas fa-external-link-alt"></i></a> 可以理解为国内的 GitHub。通过将博客同时部署到 GitHub 和 Coding，可以提升博客的加载速度。</p>
<p>这里有个提醒，Coding 会强制用户在网站上挂推广图标，通过 Coding 加载博客还会有5s广告，如果觉得这样不好，可以选择放弃部署在 Coding 上。还有一个选择，就是花钱成为 Coding 的会员，这样上述的问题就都没有了。</p>
<ul>
<li>首先到<a class="link"   href="https://coding.net/" >Coding<i class="fas fa-external-link-alt"></i></a>注册。创建仓库跟 GitHub 上创建仓库的要求一样。</li>
<li>打开本地 <code>blog</code> 目录下的 <code>_config.yml</code> 文件，滑到最下面，修改如下(xxx换成自己的用户名)：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:</span><br><span class="line">    github: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">    coding: https://git.coding.net/xxx/xxx.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<ul>
<li>然后执行命令<code>hexo clean</code> <code>hexo g</code> <code>hexo d</code></li>
<li>个人域名添加两条 CNAME 解析。将 GitHub 的地址 解析为 <code>国外</code> ，将 Coding 的地址 解析为 <code>国内</code> ：</li>
</ul>
<p><a href="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67"
                      alt="dnspod"
                ></a></p>
<ul>
<li>如果您有个人域名的话，到 Coding 博客仓库的 <code>Pages 服务</code> 界面，添加域名绑定，输入个人域名就 OK 了，可能需要耐心等待几分钟。</li>
</ul>
<p>这样就可以实现从国内访问就通过 Coding 加载博客项目，从国外访问就通过 GitHub 加载博客项目，从而提升加载博客的速度。</p>
<h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>压缩代码也是一个优化加载速度的方法。</p>
<p>目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp 插件。hexo-all-minifier 使用比较简单，也可以压缩图片，不过对文章缩进不支持。如果您对文章缩进有要求，可以暂时使用 gulp 压缩手段。</p>
<ul>
<li>Hexo-all-minifier 使用方法</li>
</ul>
<p>安装 hexo-all-minifier，在站点的根目录下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure>

<p><code>hexo g</code>编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 <a class="link"   href="https://github.com/chenzhutian/hexo-all-minifier" >hexo-all-minifier<i class="fas fa-external-link-alt"></i></a>。</p>
<ul>
<li>glup 使用方法</li>
</ul>
<p>Hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp -g</span><br><span class="line">npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure>

<p>在<code>blog</code>目录下，新建 <code>gulpfile.js</code> 并填入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">var minifycss = require(&#x27;gulp-minify-css&#x27;);</span><br><span class="line">var uglify = require(&#x27;gulp-uglify&#x27;);</span><br><span class="line">var htmlmin = require(&#x27;gulp-htmlmin&#x27;);</span><br><span class="line">var htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">// 压缩 public 目录 css</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, function() &#123;</span><br><span class="line">    return gulp.src(&#x27;./public/**/*.css&#x27;)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public 目录 html</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;, function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: true,</span><br><span class="line">         minifyJS: true,</span><br><span class="line">         minifyCSS: true,</span><br><span class="line">         minifyURLs: true,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public/js 目录 js</span><br><span class="line">gulp.task(&#x27;minify-js&#x27;, function() &#123;</span><br><span class="line">    return gulp.src(&#x27;./public/**/*.js&#x27;)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(&#x27;default&#x27;, [</span><br><span class="line">    &#x27;minify-html&#x27;,&#x27;minify-css&#x27;,&#x27;minify-js&#x27;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>生成博文时执行 <code>hexo g &amp;&amp; gulp</code> 就会根据 <code>gulpfile.js</code> 中的配置，对 public 目录中的静态资源文件进行压缩。</p>
<h2 id="SEO-搜索引擎优化"><a href="#SEO-搜索引擎优化" class="headerlink" title="SEO(搜索引擎优化)"></a>SEO(搜索引擎优化)</h2><h3 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h3><ul>
<li><a class="link"   href="https://accounts.google.com/signin/v2/sl/pwd?service=sitemaps&passive=1209600&continue=https://www.google.com/webmasters/verification/home?hl=zh-CN&followup=https://www.google.com/webmasters/verification/home?hl=zh-CN&hl=zh-CN&flowName=GlifWebSignIn&flowEntry=ServiceLogin" >Google 提交入口<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://zhanzhang.baidu.com/dashboard/index" >百度提交入口<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>验证方式有几种，推荐最简单的两种：文件验证和 CNAME 验证。</p>
<ul>
<li>文件验证</li>
</ul>
<ol>
<li>登录百度站长选择添加网站，使用方式为文件验证</li>
<li>将下载的文件放到<code>source</code>文件下</li>
<li>由于 hexo 自动会对 html 文件进行渲染，所以在<code>站点配置文件</code>中找到<code>skip_render:</code></li>
<li>在后面添加文件名字，若有多个用这样的形式<code>[xxx.html, xxx.html]</code>，比如： <code>skip_render: [googleff0226f76d5f451b.html, baidu_verify_vHC5EAW09E.html]</code></li>
<li>重新渲染文件： <code>hexo clean</code> <code>hexo d -g</code></li>
<li>点击站长的验证按钮，完成验证。</li>
</ol>
<ul>
<li>CNAME 验证</li>
</ul>
<ol>
<li>去站长添加网站选择 CNAME 验证</li>
<li>把地址解析到<code>zz.baidu.com</code></li>
<li>完成验证</li>
</ol>
<h3 id="添加并提交sitemap"><a href="#添加并提交sitemap" class="headerlink" title="添加并提交sitemap"></a>添加并提交sitemap</h3><p>安装 Hexo 的 sitemap 网站地图生成插件，终端<code>cd</code>到<code>blog</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<p>在<code>站点配置文件</code>中任意位置添加如下代码，但要看清您的 Hexo 版本。</p>
<p>如果您的 Hexo 版本是 2.x.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br></pre></td></tr></table></figure>

<p>如果您的 Hexo 版本是 3.x.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">path: baidusitemap.xml</span><br></pre></td></tr></table></figure>

<p>配置成功后，会生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。</p>
<p>百度 sitemap 提交如图，Google 也是一样的：</p>
<p><a href="https://camo.githubusercontent.com/78d3ea331416e6c1a53b9a42bb0f539e1c4f0bca/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623331643630633836612e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/78d3ea331416e6c1a53b9a42bb0f539e1c4f0bca/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623331643630633836612e706e67"
                      alt="sitemap_yz"
                ></a></p>
<p>验证成功之后就可以开始推送了。Google 的收录比较快，通常第二天就能搜得到，百度就比较慢了。</p>
<h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><p>安装主动推送插件，终端<code>cd</code>到<code>blog</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>

<p>在根目录下，把以下内容配置到站点配置文件中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3     ## 比如3，代表提交最新的三个链接</span><br><span class="line">  host: xxx     ## 在百度站长平台中注册的域名</span><br><span class="line">  token: xxx       ## 请注意这是您的秘钥，请不要发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt       ## 文本文档的地址，新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>

<p>至于上面提到的<code>token</code>可在百度站长如下位置找到：</p>
<p><a href="https://camo.githubusercontent.com/0be351243233a8d88d3671a58368e0e583f49615/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623361633931616635332e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/0be351243233a8d88d3671a58368e0e583f49615/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623361633931616635332e706e67"
                      alt="token"
                ></a></p>
<p>其次，记得查看<code>站点配置文件</code>中的<code>url</code>，必须包含站长平台注册的域名，比如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://harleywang93.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br></pre></td></tr></table></figure>

<p>接下来添加一个新的 <code>deploy</code> 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: baidu_url_submitter</span><br><span class="line">- type: git</span><br><span class="line">  repository:</span><br><span class="line">    github: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">    coding: https://git.coding.net/xxx/xxx.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>执行<code>hexo d</code>的时候，新的链接就会被推送了。原理：</p>
<ul>
<li>新链接的产生，<code>hexo g</code>会产生一个文本文件，里面包含最新的链接。</li>
<li>新链接的提交，<code>hexo d</code>会从上述文件中读取链接，提交至百度搜索引擎。</li>
</ul>
<h3 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h3><p>把 NexT 主题配置文件中的<code>baidu_push:</code>设置为<code>true</code>，就可以了。</p>
<h3 id="添加蜘蛛协议"><a href="#添加蜘蛛协议" class="headerlink" title="添加蜘蛛协议"></a>添加蜘蛛协议</h3><p>在<code>blog/source/</code>目录下新建一个<code>robots.txt</code>文件，添加下面的一段代码(可根据自己的需要修改)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line"></span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: http://xxx/sitemap.xml</span><br><span class="line">Sitemap: http://xxx/baidusitemap.xml</span><br></pre></td></tr></table></figure>

<p>然后到站长(这里以百度为例，Google 一样)更新一下，就像这样：</p>
<p><a href="https://camo.githubusercontent.com/3ca54425ad21dd7925c9ce541cfc4ba60dc7f00d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623364636531616566382e706e67"><img  
                     lazyload
                     alt="image"
                     data-src="https://camo.githubusercontent.com/3ca54425ad21dd7925c9ce541cfc4ba60dc7f00d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623364636531616566382e706e67"
                      alt="robots"
                ></a></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>自己搭建博客时，很是折腾了一番，也学习到了很多知识，阅读了很多相关的博文，在此向相关博文的作者表示感谢，谢谢你们的文章让我进步。同时，我看到有很多人想拥有自己的博客或者优化自己的博客，期间可能会遇到很多问题，我也是这么一个坑一个坑踩过来的，所以我就写了这么一篇自己折腾博客的分享，希望可以在帮助自己的同时帮助到别人。(如果踩了新坑的话，一定会更新的。)</p>
<ul>
<li>目前已经弃掉了此方法写博客，因为想回到回归初心，写博客最初的目的 - 总结梳理知识以及分享一些感受，不在乎形式。( 其实是因为懒得折腾了，Hexo 有一些不稳定性，所以目前弃掉了，喜欢折腾的可以继续尝试 lol )</li>
</ul>
<p>希望大家也能有此感受。</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo用自己的服务器搭建博客</title>
    <url>/p/35e7.html</url>
    <content><![CDATA[<blockquote>
<p>最近小明介绍过自己用hexo+git搭建个人博客之后，大家好像更关心的是域名<strong>mynamecoder.com</strong>，不是应该关注技术嘛，让小明哭笑不得😂，今天继续给大家讲一下如果觉得这两个代码托管平台打开加载太慢，我们可以考虑部署到自己的ECS服务器（小明在腾讯云搞活动够买的99元一年的服务器，邀请链接在文末）。</p>
</blockquote>
<h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>Hexo(<a class="link"   href="https://hexo.io/zh-cn/" >https://hexo.io/zh-cn/<i class="fas fa-external-link-alt"></i></a>) 是一个快速，简单和强大的博客框架，基于 Node.js。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>在一台 CentOS 7.2 的 ECS 云服务器上快速部署基于 Hexo 的博客站点</li>
<li>可以在本地简洁快速发布一篇博文到个人云服务器上, 用于个人站点展示</li>
</ul>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ul>
<li>hexo环境搭建</li>
<li>git钩子自动部署</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>你能操作的个人电脑PC * 1台</li>
<li>自己能控制的服务器Sever * 1台</li>
</ul>
<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><blockquote>
<p>默认 ROOT 权限登录</p>
</blockquote>
<ul>
<li><p><strong>安装 Git Nginx</strong><br>升级 CentOS 所有包，包括系统版本内核升级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br><span class="line">yum install -y git nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Nginx 配置</strong><br>创建文件目录, 用于博客站点文件存放, 并更改目录读写权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /data/www/hexo</span><br><span class="line">chmod -R 755 /data/www/hexo</span><br></pre></td></tr></table></figure>
<p>添加 index.html 用于检测配置 Nginx 是否成功</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /data/www/hexo/index.html</span><br></pre></td></tr></table></figure>

<p>添加如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Nginx running&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>配置 Nginx 服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"># vim 查找: /listen 80</span><br></pre></td></tr></table></figure>

<p>通过 vim 查找功能找到如下代码, 并修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">server &#123;</span><br><span class="line">      listen       80 default_server;</span><br><span class="line">      listen       [::]:80 default_server;</span><br><span class="line">      server_name  www.mynamcoder.com; # 填写个人域名</span><br><span class="line">      root         /data/www/hexo;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>访问服务器 IP 或者域名显示</p>
<blockquote>
<p>Nginx running</p>
</blockquote>
<p>Nginx 配置成功</p>
<ul>
<li><strong>Git 配置</strong><br>创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. mkdir /data/GitLibrary</span><br><span class="line">2. chmod -R 755 /data/GitLibrary</span><br></pre></td></tr></table></figure>

<p>Git 初始化裸库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/GitLibrary</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure>

<p>创建 Git 钩子(hook)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /data/GitLibrary/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>用于指定 Git 的源代码 和 Git 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/data/www/hexo --git-dir=/data/GitLibrary/hexo.git checkout -f</span><br></pre></td></tr></table></figure>

<p>保存并退出后, 给该文件添加可执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /data/GitLibrary/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>小明使用的是mac，下面主要讲一下在 MacOS 上安装 node.js、 Git、 Hexo</p>
<blockquote>
<p>Windows &amp; Linux 搜索对应平台软件安装即可</p>
</blockquote>
<ul>
<li><p><strong>安装 Git</strong><br>在 Terminal.app(终端) 中输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>按照提示完成安装, 最后在 Terminal 中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git -v</span><br></pre></td></tr></table></figure>

<p>如下显示, 表示 Git 安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git version 2.11.0 (Apple Git-81)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Node.js 和 Npm</strong><br>Node.js 安装在 MacOS 中需要用到 Homebrew 进行安装管理</p>
<blockquote>
<p>Homebrew 在 MacOS 里类似于 CentOS 的 yum</p>
</blockquote>
<p>在 Terminal 输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<p>使用 Homebrew 安装 Node.js</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>

<p>  在 Terminal 中键入类似的命令, 如下显示, 表示 Node 和 Npm 安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">v7.10.0</span><br><span class="line">npm -v</span><br><span class="line">4.2.0</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>安装 Hexo 及相关插件</strong><br>全局安装 hexo-cli 和 hexo-server</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli hexo-server hexo-deployer-git -g</span><br></pre></td></tr></table></figure>

<p>安装完成后, 在本地初始化博客站点搭建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init ~/myBlog</span><br><span class="line"></span><br><span class="line"># ~/myBlog 即本地存放路径</span><br></pre></td></tr></table></figure>

<p>完成安装, 便可以在本地路径查看项目</p>
</li>
<li><p><strong>本地 Hexo 配置</strong><br>进入~/myBlog 目录, 修改 Hexo 博客站点配置文件 <em>_config.yml</em>，如下修改:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 程序员小明     //页面标题</span><br><span class="line">subtitle: 一个不加班的程序员     //小标题</span><br><span class="line">description: 不忘初心，牢记使命     //描述</span><br><span class="line">author: 小明       //作者</span><br><span class="line">language: zh-CN     //语言</span><br><span class="line">timezone:       //时区，可以为空</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">### If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: http://www.mynamecoder.com      //个人域名</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"># 一个是服务器</span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: root@94.191.25.157:/root/hexo.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>将本地部署到服务器</p>
<ul>
<li><p>清除缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成静态页面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地静态页面目录部署到云服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>完成 Hexo 个人博客网站搭建, 通过服务器 IP 或者域名即可访问</p>
</li>
</ul>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>以上就是我个人采用Hexo+云服务器搭建个人博客的全部流程，较为完整地介绍了 Hexo 博客的安装及简单配置，服务端如何配置通过 Git 部署 Nginx 及 Linux 简单应用。<br>在云服务器上创建私有 Git 仓库, 通过 Git 钩子，将 Hexo 生成的博客静态页面文件，推送到 Nginx 服务的托管目录, 完成部署。</p>
<p>如有疑问, 可留言或者搜索引擎解决哈。</p>
<h3 id="购买服务器邀请链接"><a href="#购买服务器邀请链接" class="headerlink" title="购买服务器邀请链接"></a>购买服务器邀请链接</h3><p>【新用户限量秒杀】热门云产品限量秒杀，云服务器1核1G 首年99元<br><a class="link"   href="http://1t.click/a75v" >http://1t.click/a75v<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>确定了，今天带一个看板娘回家</title>
    <url>/p/4059.html</url>
    <content><![CDATA[<p>💃 内容为王，但谁还不是一个颜控？</p>
<span id="more"></span>
<p>有一说一，向来我自己的站点风格都尽力保持简约大方，没有多余的功能模块，也没有花里胡哨的css和js，就是简简单单的，希望给人一种大家闺秀的感觉。但这样，难免会缺少邻家小妹的秀气，宛如房间里缺少绿植，少了些许灵动。于是，我决定走出去观赏哈大佬们的博客，只有这样才可以让愚笨的我找到些许灵感，进而让我的寒舍蓬荜生辉。</p>
<p>💃 <strong>对不起，我看上你家的老板娘了</strong></p>
<p>怀着初心，四处寻觅，在TX交友网站<a class="link"   href="https://github.com/" >「Github」<i class="fas fa-external-link-alt"></i></a>停留良久，尤其是基于<a class="link"   href="https://hexo.io/themes/" >Hexo的主题<i class="fas fa-external-link-alt"></i></a>更是让人眼花缭乱。</p>
<blockquote>
<p>乱花渐欲迷人眼，浅草才能没马蹄。 —— 钱塘湖春行(白居易)</p>
</blockquote>
<p>为了维持现有的博客风格，自然是不能大修大改。正在踌躇时，一篇博文引起了我的注意，当然现在我已经想不起来具体文章内容，只记得左下角有一个可可爱爱的女孩像花一样冲着我笑，还很调皮。我坦白，当时我就……瞬间有了灵感。</p>
<div>
<video src= "https://file.mynamecoder.com/live2d_api/live2d-demo.mp4" width="200" height="250"  muted autoplay loop></video>
</div>

<p>是不是很二次元！<a class="link"   href="https://mi.js.org/live2d-widget/demo/demo.html" >点击完整体验<i class="fas fa-external-link-alt"></i></a> 当时我猜想，这个姑娘应该是该网站的老板娘，如果把她带走放置到我的网站，岂不是会增加些许灵气？</p>
<p>💃 <strong>一见钟情，我带走了别人的看板娘</strong></p>
<p>说干就干，查了相关资料，原来这个叫做<a class="link"   href="https://www.live2d.com/" >Live2D<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>是一种应用于电子游戏的绘图渲染技术，技术由日本Cybernoids公司开发。通过一系列的连续图像和人物建模来生成一种类似三维模型的二维图像，对于以动画风格为主的冒险游戏来说非常有用。</p>
</blockquote>
<p>集成到网页中后，学术名叫<strong>看板娘</strong>，hexo官方已经存在插件<a class="link"   href="https://github.com/EYHN/hexo-helper-live2d.git" >hexo-helper-live2d<i class="fas fa-external-link-alt"></i></a>，但是5年前就已经停止更新，没有新的模型，不推荐大家使用。</p>
<p>看着看着我就打开了控制台……<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230310114431.jpg"
                     
                ><br>分析了一下网络请求，原来看板娘分两块内容：</p>
<ul>
<li>框架</li>
<li>模型</li>
</ul>
<p>所以，首先我们得先把框架集成到项目中，然后再将模型文件引入进来。</p>
<h5 id="看板娘框架"><a href="#看板娘框架" class="headerlink" title="看板娘框架"></a>看板娘框架</h5><p>我又在TX交友网站<a class="link"   href="https://github.com/" >「Github」<i class="fas fa-external-link-alt"></i></a>根据关键词检索了一番，发现一个不错的框架<a class="link"   href="https://github.com/WhenCoding/live2d-widget" >stevenjoezhang/live2d-widget<i class="fas fa-external-link-alt"></i></a>，支持的模型也很可爱，目前这个框架已经开源，我已经fork。感谢该作者，说明文档也写的很全面，此处不再赘述如何使用，主要有两种集成方式：</p>
<table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直接引用JS</td>
<td align="center">一键引入、方便快捷、节省生命</td>
<td align="center">不支持自定义</td>
</tr>
<tr>
<td align="center">魔改框架✅</td>
<td align="center">将源码下载后，魔改该框架，这样更契合你的网站</td>
<td align="center">花点时间理解框架</td>
</tr>
</tbody></table>
<p>我当然选择了魔改框架，因为我要为我的网站高级定制看板娘。</p>
<h5 id="看板娘模型"><a href="#看板娘模型" class="headerlink" title="看板娘模型"></a>看板娘模型</h5><p>当你看懂这个框架之后，会发现，虽然这个框架不提供模型，但是，很明显<code>cdnPath</code>就是访问模型的路径。模型的静态资源已经放入到cdn上面了，速度却还是很慢。所以，接下来，我有一个想法：把静态资源爬下来，放到国内的cdn上。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230310215816.jpg"
                     
                ><br>通过分析网络请求，发现前三个请求都是<code>json</code>格式的配置文件：</p>
<ul>
<li><code>model_list.json</code>是展示该模型库所有的模型列表</li>
<li><code>waifu-tips.json</code> 是控制看板娘框架不同交互的提示语，在框架中控制，不属于模型库</li>
<li><code>index.json</code>指的是当前展示的模型需要哪些配置</li>
<li>剩下的网络请求路径全部依托于<code>index.json</code>里面的配置内容</li>
</ul>
<p>所以，我们可以得出结论，如果想要爬取这个模型库，那我们按以下步骤：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230310224059.png"
                     
                ><br>人生苦短，我用python写了一个脚本爬取，主要用到的库是<code>requests</code>、<code>os</code>，在写的过程中发现一个趣事：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkdirs竟然可以支持创建带有上级路径的文件夹</span><br><span class="line">path = &#x27;/pic/../video&#x27;</span><br><span class="line">os.path.mkdirs(path) # 会创建video的文件夹</span><br><span class="line"># abspath可以计算绝对路径，比如输入`/pic/../video/xx.mp4`</span><br><span class="line">path = &#x27;/pic/../video/xx.mp4&#x27;</span><br><span class="line">print(os.path.abspath(path)) # 输出`/video/xx.mp4`</span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://github.com/WhenCoding/python-demo/tree/master/common/live2d" >爬取live2d模型代码<i class="fas fa-external-link-alt"></i></a>我已经上传到Github上面，大家可以参考。这个仓库会更新一些平时写的脚本，老哥们感兴趣的话，可以star⭐️。<br>经过爬取，我整理了一下模型库，总共有27个模型，并将各个模型的名字也标注出来：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230312225005.png"
                     
                ><br>模型库我已经上传到<a class="link"   href="https://github.com/WhenCoding/live2d_models" >WhenCoding/live2d_models<i class="fas fa-external-link-alt"></i></a>，推荐大家可以将这些模型都上传自己的cdn服务（大小70M+，不适合放入项目中），然后在<code>model_list.json</code>配置自己喜欢的模型，cdn服务我一直用的是七牛云，一个月不到1块钱（可能是没什么访问量😒）<br><a href="https://s.qiniu.com/zY77jy"><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230312230900.jpg"
                     
                ></a><br>访问速度很快，服务稳定，价格便宜，方便管理（比如防盗链等设置），现在可以点击我的<a class="link"   href="https://s.qiniu.com/zY77jy" >推广链接<i class="fas fa-external-link-alt"></i></a>进行试用。<br>当前我的网站就配置了6个模型<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230313000544.jpeg"
                      width=400 height=400
                ></p>
<p>好啦，大家如果感兴趣可以带一个看板娘回家，如果在配置过程中遇到什么问题，可以关注微信公众号、留言、进群交流。</p>
<h5 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h5><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CurrentHashMap底层实现原理</title>
    <url>/p/undefined.html</url>
    <content><![CDATA[<p>🌴 不得不知道</p>
<span id="more"></span>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>哈希表就是一种以 键-值(key-indexed) 存储数据的结构，又称散列函数，我们只要输入待查找的值即key，即可查找到其对应的值。<br>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p>
<h4 id="链式哈希表"><a href="#链式哈希表" class="headerlink" title="链式哈希表"></a>链式哈希表</h4><p>链式哈希表从根本上说是由一组链表构成。每个链表都可以看做是一个“桶”，我们将所有的元素通过散列的方式放到具体的不同的桶中。插入元素时，首先将其键传入一个哈希函数（该过程称为哈希键），函数通过散列的方式告知元素属于哪个“桶”，然后在相应的链表头插入元素。查找或删除元素时，用同样的方式先找到元素的“桶”，然后遍历相应的链表，直到发现我们想要的元素。因为每个“桶”都是一个链表，所以链式哈希表并不限制包含元素的个数。然而，如果表变得太大，它的性能将会降低。</p>
<p>参考链接：<a class="link"   href="https://baijiahao.baidu.com/s?id=1617089947709260129&amp;wfr=spider&amp;for=pc" >https://baijiahao.baidu.com/s?id=1617089947709260129&amp;wfr=spider&amp;for=pc<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>JDK8日常开发系列：Consumer详解</title>
    <url>/p/9bfd.html</url>
    <content><![CDATA[<p>java.util.function中 <strong>Function</strong>, <strong>Supplier</strong>, <strong>Consumer</strong>, <strong>Predicate</strong>和其他函数式接口广泛用在支持lambda表达式的API中。这些接口有一个抽象方法，会被lambda表达式的定义所覆盖。</p>
<span id="more"></span>
<p>Consumer的作用顾名思义,是给定义一个参数,对其进行(消费)处理,处理的方式可以是任意操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void accept(T t);</span><br><span class="line"></span><br><span class="line">    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其核心方法如下:</p>
<ul>
<li>void accept(T t);<br>对给定的参数T执行定义的操作</li>
</ul>
<ul>
<li>default Consumer<T> andThen(Consumer&lt;? super T&gt; after)<br>对给定的参数T执行定义的操作执行再继续执行after定义的操作</li>
</ul>
<p>下面对上述方法进行实例测试：</p>
<h2 id="accept-T-t"><a href="#accept-T-t" class="headerlink" title="accept(T t)"></a>accept(T t)</h2><p>比如将给定的一批用户里面的名称为”lisi”的用户都给打包起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此处使用lombok插件（值得了解）</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Accessors(chain = true)</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; lisiList = new ArrayList&lt;&gt;();</span><br><span class="line">Consumer&lt;Person&gt; consumer  = x -&gt; &#123;</span><br><span class="line">    if (x.getName().equals(&quot;lisi&quot;))&#123;</span><br><span class="line">        lisiList.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Stream.of(</span><br><span class="line">        new Person(21,&quot;zhangsan&quot;),</span><br><span class="line">        new Person(22,&quot;lisi&quot;),</span><br><span class="line">        new Person(23,&quot;wangwu&quot;),</span><br><span class="line">        new Person(24,&quot;wangwu&quot;),</span><br><span class="line">        new Person(23,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;zhangsan&quot;)</span><br><span class="line">).forEach(consumer);</span><br><span class="line"></span><br><span class="line">System.out.println(JSON.toJSONString(lisiList));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;age&quot;:22,&quot;name&quot;:&quot;lisi&quot;&#125;,&#123;&quot;age&quot;:23,&quot;name&quot;:&quot;lisi&quot;&#125;,&#123;&quot;age&quot;:26,&quot;name&quot;:&quot;lisi&quot;&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="default-Consumer-andThen-Consumer-lt-super-T-gt-after"><a href="#default-Consumer-andThen-Consumer-lt-super-T-gt-after" class="headerlink" title="default Consumer andThen(Consumer&lt;? super T&gt; after)"></a>default Consumer<T> andThen(Consumer&lt;? super T&gt; after)</h2><p>比如将给定的一批用户里面的名称为”lisi”且年龄大于22岁的用户都给打包起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; lisiList = new ArrayList&lt;&gt;();</span><br><span class="line">Consumer&lt;Person&gt; consumer  = x -&gt; &#123;</span><br><span class="line">    if (x.getName().equals(&quot;lisi&quot;))&#123;</span><br><span class="line">        lisiList.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">consumer = consumer.andThen(</span><br><span class="line">        x -&gt; lisiList.removeIf(y -&gt; y.getAge() &lt; 23)</span><br><span class="line">);</span><br><span class="line">Stream.of(</span><br><span class="line">        new Person(21,&quot;zhangsan&quot;),</span><br><span class="line">        new Person(22,&quot;lisi&quot;),</span><br><span class="line">        new Person(23,&quot;wangwu&quot;),</span><br><span class="line">        new Person(24,&quot;wangwu&quot;),</span><br><span class="line">        new Person(23,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;zhangsan&quot;)</span><br><span class="line">).forEach(consumer);</span><br><span class="line"></span><br><span class="line">System.out.println(JSON.toJSONString(lisiList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;age&quot;:23,&quot;name&quot;:&quot;lisi&quot;&#125;,&#123;&quot;age&quot;:26,&quot;name&quot;:&quot;lisi&quot;&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="与Consumer相关的接口"><a href="#与Consumer相关的接口" class="headerlink" title="与Consumer相关的接口"></a>与Consumer<T>相关的接口</h2><ul>
<li>BiConsumer&lt;T, U&gt;</li>
</ul>
<p>处理一个两个参数</p>
<ul>
<li>DoubleConsumer</li>
</ul>
<p>处理一个double类型的参数</p>
<ul>
<li>IntConsumer</li>
</ul>
<p>处理一个int类型的参数</p>
<ul>
<li>LongConsumer</li>
</ul>
<p>处理一个long类型的参数</p>
<ul>
<li>ObjIntConsumer<T></li>
</ul>
<p>处理两个参数,且第二个参数必须为int类型</p>
<ul>
<li>ObjLongConsumer<T></li>
</ul>
<p>处理两个参数,且第二个参数必须为long类型</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 1.8 处理时间常用举例</title>
    <url>/p/f00a.html</url>
    <content><![CDATA[<blockquote>
<p>在Java 8以前，日期和时间处理一直被广大java程序员抱怨太难用，首先是<code>java.util</code>和<code>java.sql</code>中，都包含<code>Date</code>类，如果要处理<code>java.text.DateFormat</code>类处理。同时<code>java.util.Date</code>中既包含了日期，又包含了时间，所以java8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方日期库<code>joda</code>很多的优点。</p>
</blockquote>
<p>在java8中，<code>java.time</code>包下主要包含下面几个主要的类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Instant：时间戳  </span><br><span class="line">Duration：持续时间，时间差  </span><br><span class="line">LocalDate：只包含日期，比如：2016-10-20  </span><br><span class="line">LocalTime：只包含时间，比如：23:12:10  </span><br><span class="line">LocalDateTime：包含日期和时间，比如：2016-10-20 23:14:21  </span><br><span class="line">Period：时间段  </span><br><span class="line">ZoneOffset：时区偏移量，比如：+8:00  </span><br><span class="line">ZonedDateTime：带时区的时间  </span><br><span class="line">Clock：时钟，比如获取目前美国纽约的时间  </span><br></pre></td></tr></table></figure>

<p>以及<code>java.time.format</code>包中的</p>
<p><code>DateTimeFormatter：时间格式化</code></p>
<p>下面我们通过例子来看如何使用java8新的日期时间库</p>
<h2 id="获取今天的日期"><a href="#获取今天的日期" class="headerlink" title="获取今天的日期"></a>获取今天的日期</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate todayDate = LocalDate.now();  </span><br><span class="line">System.out.println(&quot;今天的日期：&quot;+todayDate);  </span><br><span class="line">//结果</span><br><span class="line">今天的日期：2016-10-20</span><br></pre></td></tr></table></figure>

<h2 id="指定日期，进行相应操作"><a href="#指定日期，进行相应操作" class="headerlink" title="指定日期，进行相应操作"></a>指定日期，进行相应操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//取2016年10月的第1天</span><br><span class="line">LocalDate firstDay = oneday.with(TemporalAdjusters.firstDayOfMonth());  </span><br><span class="line">System.out.println(firstDay);</span><br><span class="line"></span><br><span class="line">//取2016年10月的第1天，另外一种写法</span><br><span class="line">LocalDate firstDay2 = oneday.withDayOfMonth(1);  </span><br><span class="line">System.out.println(firstDay2);</span><br><span class="line"></span><br><span class="line">//取2016年10月的最后1天，不用考虑大月，小月，平年，闰年</span><br><span class="line">LocalDate lastDay = oneday.with(TemporalAdjusters.lastDayOfMonth());  </span><br><span class="line">System.out.println(lastDay);</span><br><span class="line"></span><br><span class="line">//当前日期＋1天</span><br><span class="line">LocalDate tomorrow = oneday.plusDays(1);  </span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line"></span><br><span class="line">//当前日期-7天</span><br><span class="line">LocalDate minus = oneday.minus(7, ChronoUnit.DAYS);</span><br><span class="line">//或者</span><br><span class="line">LocalDate minus = oneday.minusDays(7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断是否为闰年</span><br><span class="line">boolean isLeapYear = tomorrow.isLeapYear();  </span><br><span class="line">System.out.println(isLeapYear);</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">2016-10-20  </span><br><span class="line">2016-10-01  </span><br><span class="line">2016-10-01  </span><br><span class="line">2016-10-31  </span><br><span class="line">2016-10-21  </span><br><span class="line">true  </span><br></pre></td></tr></table></figure>

<h2 id="生日检查或者账单日检查"><a href="#生日检查或者账单日检查" class="headerlink" title="生日检查或者账单日检查"></a>生日检查或者账单日检查</h2><p>开发过程中，经常需要为过生日的用户送上一些祝福，例如，用户的生日为1990-10-12，如果今天是2016-10-12，那么今天就是用户的生日（按公历／身份证日期来算），那么通过java8新的日期库，我们该如何来进行判断？</p>
<p>在java8中，可以使用<code>MonthDay</code>，该类不包含年份信息，当然还有一个类是<code>YearMonth</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(1990, 10, 12);  </span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());  </span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.of(2016, 10, 12));  </span><br><span class="line">System.out.println(today.equals(birthdayMd));  </span><br><span class="line">//结果</span><br><span class="line">true  </span><br></pre></td></tr></table></figure>

<h2 id="获取当前的时间"><a href="#获取当前的时间" class="headerlink" title="获取当前的时间"></a>获取当前的时间</h2><p>日期主要是使用LocalTime，该类不包含日期，只有时间信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取当前的时间</span><br><span class="line">LocalTime nowTime = LocalTime.now(); //结果14:29:40.558</span><br><span class="line"></span><br><span class="line">//如果不想显示毫秒</span><br><span class="line">LocalTime nowTime2 = LocalTime.now().withNano(0); //14:43:14</span><br><span class="line"></span><br><span class="line">//指定时间</span><br><span class="line">LocalTime time = LocalTime.of(14, 10, 21); //14:10:21  </span><br><span class="line">LocalTime time2 = LocalTime.parse(&quot;12:00:01&quot;); // 12:00:01</span><br><span class="line"></span><br><span class="line">//当前时间增加2小时</span><br><span class="line">LocalTime nowTimePlus2Hour = nowTime.plusHours(2); //16:47:23.144  </span><br><span class="line">//或者</span><br><span class="line">LocalTime nowTimePlus2Hour2 = nowTime.plus(2, ChronoUnit.HOURS);  </span><br></pre></td></tr></table></figure>

<h2 id="日期前后比较"><a href="#日期前后比较" class="headerlink" title="日期前后比较"></a>日期前后比较</h2><p>比较2个日期哪个在前，哪个在后，java8 LocalDate提供了2个方法，<code>isAfter()</code>,<code>isBefore</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();  </span><br><span class="line">LocalDate specifyDate = LocalDate.of(2015, 10, 20);  </span><br><span class="line">System.out.println(today.isAfter(specifyDate)); //true  </span><br></pre></td></tr></table></figure>

<h2 id="处理不同时区的时间"><a href="#处理不同时区的时间" class="headerlink" title="处理不同时区的时间"></a>处理不同时区的时间</h2><p>java8中，将日期，时间，时区都很好的进行了分离。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看当前的时区</span><br><span class="line">ZoneId defaultZone = ZoneId.systemDefault();  </span><br><span class="line">System.out.println(defaultZone); //Asia/Shanghai</span><br><span class="line"></span><br><span class="line">//查看美国纽约当前的时间</span><br><span class="line">ZoneId america = ZoneId.of(&quot;America/New_York&quot;);  </span><br><span class="line">LocalDateTime shanghaiTime = LocalDateTime.now();  </span><br><span class="line">LocalDateTime americaDateTime = LocalDateTime.now(america);  </span><br><span class="line">System.out.println(shanghaiTime); //2016-11-06T15:20:27.996  </span><br><span class="line">System.out.println(americaDateTime); //2016-11-06T02:20:27.996 ，可以看到美国与北京时间差了13小时</span><br><span class="line"></span><br><span class="line">//带有时区的时间</span><br><span class="line">ZonedDateTime americaZoneDateTime = ZonedDateTime.now(america);  </span><br><span class="line">System.out.println(americaZoneDateTime); //2016-11-06T02:23:44.863-05:00[America/New_York]  </span><br></pre></td></tr></table></figure>
<h2 id="比较两个日期之前时间差"><a href="#比较两个日期之前时间差" class="headerlink" title="比较两个日期之前时间差"></a>比较两个日期之前时间差</h2><p>在项目中，经常需要比较两个日期之间相差几天，或者相隔几个月，我们可以使用java8的Period来进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();  </span><br><span class="line">LocalDate specifyDate = LocalDate.of(2015, 10, 2);  </span><br><span class="line">Period period = Period.between(specifyDate, today);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getDays());  //4  </span><br><span class="line">System.out.println(period.getMonths()); //1  </span><br><span class="line">System.out.println(specifyDate.until(today, ChronoUnit.DAYS)); //401  </span><br><span class="line">//输出结果</span><br><span class="line">4  </span><br><span class="line">1  </span><br><span class="line">401  </span><br></pre></td></tr></table></figure>

<p>我们可以看到，我们使用<code>Period</code>类比较天数，比较奇怪，他返回的值，并不是2个日期之间总共的天数差，而是一个相对天数差，比如，5月1日，和10月2日，他比较的是仅仅2个天之间的差，那1号和2号，相差1天，而实际上，因为中间相差了好几个月，所以真正的天数差肯定不是1天，所以我们可以使用<code>until</code>，并指明精度单位是<code>days</code>，就可以计算真正的天数差了。</p>
<h2 id="日期时间格式解析、格式化"><a href="#日期时间格式解析、格式化" class="headerlink" title="日期时间格式解析、格式化"></a>日期时间格式解析、格式化</h2><p>在java8之前，我们进行时间格式化主要是使用<code>SimpleDateFormat</code>，而在java8中，主要是使用<code>DateTimeFormatter</code>,java8中，预定义了一些标准的时间格式，我们可以直接将时间转换为标准的时间格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String specifyDate = &quot;20151011&quot;;  </span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;  </span><br><span class="line">LocalDate formatted = LocalDate.parse(specifyDate,formatter);  </span><br><span class="line">System.out.println(formatted);  </span><br><span class="line">//输出</span><br><span class="line">2015-10-11  </span><br><span class="line">当然，很多时间标准的时间格式可能也不满足我们的要求，我们需要转为自定义的时间格式</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(&quot;YYYY MM dd&quot;);  </span><br><span class="line">System.out.println(formatter2.format(LocalDate.now()));  </span><br><span class="line">//结果</span><br><span class="line">2015 10 11  </span><br></pre></td></tr></table></figure>

<h2 id="java8-时间类与Date类的相互转化"><a href="#java8-时间类与Date类的相互转化" class="headerlink" title="java8 时间类与Date类的相互转化"></a>java8 时间类与Date类的相互转化</h2><p>在转换中，我们需要注意，因为java8之前<code>Date</code>是包含日期和时间的，而<code>LocalDate</code>只包含日期，<code>LocalTime</code>只包含时间，所以与<code>Date</code>在互转中，势必会丢失日期或者时间，或者会使用起始时间。如果转<code>LocalDateTime</code>，那么就不存在信息误差。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Date与Instant的相互转化</span><br><span class="line">Instant instant  = Instant.now();  </span><br><span class="line">Date date = Date.from(instant);  </span><br><span class="line">Instant instant2 = date.toInstant();</span><br><span class="line"></span><br><span class="line">//Date转为LocalDateTime</span><br><span class="line">Date date2 = new Date();  </span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.ofInstant(date2.toInstant(), ZoneId.systemDefault());</span><br><span class="line">//Date转为LocalDate</span><br><span class="line">LocalDate localDate = date2.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"></span><br><span class="line">//LocalDateTime转Date</span><br><span class="line">LocalDateTime localDateTime3 = LocalDateTime.now();  </span><br><span class="line">Instant instant3 = localDateTime3.atZone(ZoneId.systemDefault()).toInstant();  </span><br><span class="line">Date date3 = Date.from(instant);</span><br><span class="line"></span><br><span class="line">//LocalDate转Date</span><br><span class="line">//因为LocalDate不包含时间，所以转Date时，会默认转为当天的起始时间，00:00:00</span><br><span class="line">LocalDate localDate4 = LocalDate.now();  </span><br><span class="line">Instant instant4 = localDate4.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant();  </span><br><span class="line">Date date4 = Date.from(instant); </span><br></pre></td></tr></table></figure>

<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Spring Bean的生命周期</title>
    <url>/p/990.html</url>
    <content><![CDATA[<h3 id="Java-Spring-Bean的生命周期包括以下阶段："><a href="#Java-Spring-Bean的生命周期包括以下阶段：" class="headerlink" title="Java Spring Bean的生命周期包括以下阶段："></a>Java Spring Bean的生命周期包括以下阶段：</h3><ul>
<li><p>实例化：当Spring容器接收到创建Bean的请求时，它会使用Java<strong>反射机制</strong>创建一个Bean实例。</p>
</li>
<li><p>属性赋值：在实例化Bean之后，Spring容器会将Bean的<strong>属性值注入</strong>到Bean实例中。这些属性值可以通过XML配置文件、注解或Java代码进行设置。</p>
</li>
<li><p><code>BeanPostProcessor</code>的前置处理：在Bean实例化和属性赋值之后，Spring容器会调用所有实现了<code>BeanPostProcessor</code>接口的类的<code>postProcessBeforeInitialization()</code>方法。这些类可以在Bean初始化之前对Bean进行一些自定义的处理。</p>
</li>
<li><p>初始化：在<code>BeanPostProcessor</code>的前置处理之后，Spring容器会调用Bean的初始化方法。这个初始化方法可以是自定义的方法，也可以是实现了<code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法。</p>
</li>
<li><p><code>BeanPostProcessor</code>的后置处理：在Bean初始化之后，Spring容器会调用所有实现了<code>BeanPostProcessor</code>接口的类的<code>postProcessAfterInitialization()</code>方法。这些类可以在Bean初始化之后对Bean进行一些自定义的处理。</p>
</li>
<li><p>使用：在<code>Bean</code>初始化之后，<code>Bean</code>就可以被应用程序使用了。</p>
</li>
<li><p>销毁：当应用程序关闭时，Spring容器会调用所有实现了<code>DisposableBean</code>接口的<code>destroy()</code>方法，以销毁Bean实例。同时，也可以通过配置文件或注解来指定自定义的销毁方法。</p>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>总之，Java Spring Bean的生命周期包括实例化、属性赋值、BeanPostProcessor的前置处理、初始化、BeanPostProcessor的后置处理、使用和销毁等阶段。在这些阶段中，开发人员可以通过自定义的方式对Bean进行一些自定义的处理。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中反射的作用及应用场景是什么？</title>
    <url>/p/20050.html</url>
    <content><![CDATA[<p>🐤 你小子喜欢走后门？</p>
<span id="more"></span>
<p>Java 反射机制的作用是在运行时获取类的信息，并可以动态地操作对象或者调用方法。通过反射机制，可以在运行时获取类的属性和方法，并且可以在运行时调用这些方法或者实例化对象，从而实现一些动态性的操作。</p>
<p>Java 反射机制的应用场景非常广泛，例如：</p>
<ul>
<li>在 Spring 框架中，使用反射机制实现依赖注入和自动装配；</li>
<li>在 Hibernate 框架中，使用反射机制实现对象的持久化和查询；</li>
<li>在 JUnit 单元测试框架中，使用反射机制动态地创建测试对象并调用测试方法；</li>
<li>在 Android 应用开发中，使用反射机制实现动态生成界面和修改界面元素属性等。<br>以下是一个简单的示例代码，演示了如何使用反射机制创建对象、设置属性和调用方法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflectionExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取类的 Class 对象</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(&quot;com.example.Person&quot;);</span><br><span class="line"></span><br><span class="line">            // 创建对象</span><br><span class="line">            Object person = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            // 设置属性</span><br><span class="line">            Field nameField = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">            nameField.setAccessible(true);</span><br><span class="line">            nameField.set(person, &quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">            Field ageField = clazz.getDeclaredField(&quot;age&quot;);</span><br><span class="line">            ageField.setAccessible(true);</span><br><span class="line">            ageField.set(person, 18);</span><br><span class="line"></span><br><span class="line">            // 调用方法</span><br><span class="line">            Method sayHelloMethod = clazz.getDeclaredMethod(&quot;sayHello&quot;);</span><br><span class="line">            sayHelloMethod.setAccessible(true);</span><br><span class="line">            sayHelloMethod.invoke(person);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, my name is &quot; + name + &quot;, I&#x27;m &quot; + age + &quot; years old.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们通过 <code>Class.forName()</code> 方法获取了 <code>Person</code> 类的 <code>Class</code> 对象，并通过 <code>newInstance()</code> 方法创建了 <code>Person</code> 类的实例。接着，我们使用反射机制设置了 <code>Person</code> 类的 <code>name</code> 和 <code>age</code> 属性的值，然后调用了 <code>Person</code> 类的 <code>sayHello()</code> 方法，并打印了方法的输出结果。</p>
<p>需要注意的是，在使用反射时<strong>需要处理异常</strong>，否则程序可能会崩溃。同时，反射的使用也<strong>会带来一定的性能损失</strong>，因此在实际开发中需要谨慎使用。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 垃圾回收算法及详细过程（一）</title>
    <url>/p/3205.html</url>
    <content><![CDATA[<p>😬 图文并茂才能更快掌握</p>
<span id="more"></span>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>理解 Java 虚拟机垃圾回收机制的底层原理，是系统调优与线上问题排查的基础，也是一个高级 Java 程序员的基本功，本文就针对 Java 垃圾回收这一主题做一些整理与记录。Java 垃圾回收器的种类繁多，它们的设计要在吞吐量（内存空间）与实时性（用户线程中断）方面进行权衡，各个垃圾回收器的适应场景也不尽相同（如：桌面应用，web 应用），因此，这里我们只讨论 JDK8 下的默认垃圾回收器，毕竟目前 JDK8 版本是业界的主流（占 80%），并且我们只讨论堆内存空间的垃圾回收。</p>
<p>JDK8 下的默认垃圾回收器：UseParallelGC ： Parallel （新生代）+ （老年代）堆内存回收机制</p>
<h2 id="如何判断对象是否可回收？"><a href="#如何判断对象是否可回收？" class="headerlink" title="如何判断对象是否可回收？"></a>如何判断对象是否可回收？</h2><p>首先思考一个问题，内存堆中那么多对象，回收器要回收哪些对象？怎么判断出这些要回收的对象呢？因此对于垃圾回收，判断并标识对象是否可回收是第一步。从理论层面来说，判断对象是否可回收一般两种方法。</p>
<ul>
<li><p>引用计数器算法<br>每当对象被引用一次计数器加 1，对象失去引用计数器减 1，计数器为 0 是就可以判断对象死亡了。这种算法简单高效，但是对于循环引用或其他复杂情况，需要更多额外的开销，因此 Java 几乎不使用该算法。</p>
</li>
<li><p>根搜索算法-可达性分析算法<br>所谓可达性分析是指，顺着 GCRoots 根一直向下搜索（用一个成语概括就是“顺藤摸瓜”），整个搜索的过程就构成了一条“引用链”，只要在引用链上的对象叫做可达，在引用链之外的（说明跟 GCRoots 没有任何关系）叫不可达，不可达的对象就可以判断为可回收的对象。 哪些对象可作为 GCRoots 对象呢？ 包括如下：</p>
<ul>
<li>虚拟机栈帧上本地变量表中的引用对象（方法参数、局部变量、临时变量）</li>
<li>方法区中的静态属性引用类型对象、常量引用对象</li>
<li>本地方法栈中的引用对象（Native 方法的引用对象）</li>
<li>Java 虚拟机内部的引用对象，如异常对象、系统类加载器等</li>
<li>所以被同步锁（synchronize）持有的对象</li>
<li>Java 虚拟机内部情况的注册回调、本地缓存等</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果对虚拟机的内存布局与运行流程有所了解的话，这些作为 GCRoots 都很好理解，它们是程序运行时的源头，程序的正常运行必须依赖它们，而与这些源头没有任何关系的对象，即可视为可回收对象。就好比“瓜从藤上掉下来了， 那这瓜肯定也没有用了”        </p>
</blockquote>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240118173551.png"
                      alt="20240118173551"
                ></p>
<blockquote>
<p>可达性分析从理论上很好理解，但在垃圾收集器具体运行时，要考虑的问题不知道要复杂多少倍，因为在可达性分析的同时，程序也是在并行运行着，整个内存堆的状态随着程序的运行是实时变化的，要实现分析结果与内存状态的一致性，就必须要暂停用户线程，在一个快照去进行分析。</p>
</blockquote>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>可达性分析解决了判断对象是否可回收的问题，那么在垃圾回收时内存空间会发生哪些变化呢？这就是垃圾回收算法要讨论的问题，我们根据算法对内存采取的不同操作，可将垃圾回收算法分为 3 种：</p>
<ul>
<li><strong>标记-清除算法</strong></li>
<li><strong>标记-复制算法</strong></li>
<li><strong>标记-整理算法</strong></li>
</ul>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>根据名称就可以理解改算法分为两个阶段：首先标记出所有需要被回收的对象，然后对标记的对象进行统一清除，清空对象所占用的内存区域，下图展示了回收前与回收后内存区域的对比，红色的表示可回收对象，橙色表示不可回收对象，白色表示内存空白区域。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122162509.png"
                      alt="20240122162509"
                ></p>
<p>标记-清除算法的<strong>两个缺点</strong>：</p>
<ul>
<li>执行效率不可控，试想一下如果堆中大部分的对象都可回收的，收集器要执行大量的标记、收集操作。</li>
<li>产生了许多内存碎片，通过回收后的内存状态图可以知道，被回收后的区域内存并不是连续的，当有大对象要分配而找不到满足大小的空间时，要触发下一次垃圾收集。</li>
</ul>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>针对标记-清除算法执行效率与内存碎片的缺点，计算机科学家又提出了一种“半复制区域”的算法。</p>
<p>标记-复制算法将内存分为大小相同的两个区域：<strong>运行区域</strong>、<strong>预留区域</strong>，所有创建的新对象都分配到运行区域，当运行区域内存不够时，将运作区域中存活对象全部复制到预留区域，然后再清空整个运行区域内存，这时两块区域的角色也发生了变化，每次存活的对象就像皮球一下在运行区域与预留区域踢来踢出，而垃圾对象会随着整个区域内存的清空而释放掉，内存前后的状态参考下图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122162725.png"
                      alt="20240122162725"
                ></p>
<p>标记-复制算法在大量垃圾对象的情况下，只需复制少量的存活对象，并且不会产生内存碎片问题，新内存的分配只需要移动堆顶指针顺序分配即可，很好的兼顾了效率与内存碎片的问题。</p>
<p>标注-复制算法也存在<strong>缺点</strong>：</p>
<p>预留一半的内存区域未免有些浪费了，并且如果内存中大量的是存活状态，只有少量的垃圾对象，收集器要执行更多次的复制操作才能释放少量的内存空间，得不偿失。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记-复制算法要浪费一半内存空间，且在大多数状态为存活状态时使用效率会很低，针对这一情况计算机科学家又提出了一种新的算法“标记-整理算法”，标记整理算法的标记阶段与其他算法一样，但是在整理阶段，算法将存活的对象向内存空间的一端移动，然后将存活对象边界以外的空间全部清空，如下图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122163056.png"
                      alt="20240122163056"
                ></p>
<p>标记整理算法解决了内存碎片问题，也不存在空间的浪费问题，看上去挺美好的。但是，当内存中存活对象多，并且都是一些微小对象，而垃圾对象少时，要移动大量的存活对象才能换取少量的内存空间。可见：不同的垃圾回收算法都有各自的优缺点，适应于不同的垃圾回收场景</p>
<h2 id="新生代、老年代堆内存结构"><a href="#新生代、老年代堆内存结构" class="headerlink" title="新生代、老年代堆内存结构"></a>新生代、老年代堆内存结构</h2><p> Java 堆内存空间新生代、老年代是如何划分的？对象创建后是如何分配到不同的区域的？结合下图可以知道，整个堆内存被分为了 2 个大的区域，新生代，老年代，默认情况下新生代占 1/3 的空间，老年代占 2/3 的空间，新生代又分为两个区 Eden 区 Survial 区，Survial 又分为 S0、S1 区 默认各占 8/10 与 1/10，1/10 的空间。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122164605.png"
                      alt="20240122164605"
                ></p>
<p>为什么要这么设计呢？为什么要分那么多不同的内存区域干嘛？这是由对象的生命周期特征、与各类垃圾回收算法的优缺点所决定的，这正是垃圾回收器设计的理论基础。经过统计分析，大多数应用程序对象生命周期符合两个特征：</p>
<ul>
<li>绝大多数的对象都是“朝生夕灭”的，即创建不久就消亡</li>
<li>熬过越多垃圾回收过程的对象就越难以消亡</li>
</ul>
<p>因此，可以根据对象生命周期特征，将其划分到不同的区域，再对特定区域使用特定的垃圾回收算法，只有这样才能将垃圾算法的优点发挥到极致，这种组合的垃圾回收算法叫：分代垃圾算法。比如：</p>
<ul>
<li>在新生代使用标记-复制算法</li>
<li>在老年代使用标记-整理算法</li>
</ul>
<blockquote>
<p>参考​原文链接:<a class="link"   href="https://xie.infoq.cn/article/9d4830f6c0c1e2df0753f9858" >https://xie.infoq.cn/article/9d4830f6c0c1e2df0753f9858<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 垃圾回收算法及详细过程（二）</title>
    <url>/p/58033.html</url>
    <content><![CDATA[<p>😆 分代垃圾算法有点像垃圾分类的感觉</p>
<span id="more"></span>
<h2 id="堆内存回收过程详解"><a href="#堆内存回收过程详解" class="headerlink" title="堆内存回收过程详解"></a>堆内存回收过程详解</h2><p>我们分析了如何判断对象是否可回收，还有 3 种基础的垃圾回收算法，以及年轻代、老年代的内存区域划分与原因。接下来我们就一步一步来分析堆内存的回收流程。</p>
<h3 id="内存初始状态"><a href="#内存初始状态" class="headerlink" title="内存初始状态"></a>内存初始状态</h3><p>假设在第一垃圾回收之前，内存中的状态如图所示，Eden 区有 2 个存活对象，4 个垃圾对象，内存的可用区域已经所剩无几，Survivor 区因为还没有进行任何 MinorGC 所以是空的，有 1 个大对象直接分配到了老年代。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122164943.png"
                      alt="20240122164943"
                ></p>
<h3 id="第-1-次执行-MinorGC-后状态"><a href="#第-1-次执行-MinorGC-后状态" class="headerlink" title="第 1 次执行 MinorGC 后状态"></a>第 1 次执行 MinorGC 后状态</h3><p>当新的对象分配到 Eden 区，发现内存空间不够，于是触发第一次 MinorGC，垃圾回收器首先将 Edne 区中的两个存活对象复制到 S0 区，然后在清空 Eden 区的空间，如下图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122170929.png"
                      alt="20240122170929"
                ></p>
<h3 id="程序运行一段时间后状态"><a href="#程序运行一段时间后状态" class="headerlink" title="程序运行一段时间后状态"></a>程序运行一段时间后状态</h3><p>经过第 1 次 MinorGC 程序再运行一段时间后，堆内存状态如下：Eden 区又产生了大量的对象，并且大部分对象都可回收状态，这也符合对象“朝生夕灭”的特征，S0 区中也有 1 个对象可以回收，S1 与老年代没有变化，在这种状态下，如果新对象分配再次触发 MinorGC 会发生什么呢？<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122171022.png"
                      alt="20240122171022"
                ></p>
<h3 id="执行第-2-次-MinorGC-后状态"><a href="#执行第-2-次-MinorGC-后状态" class="headerlink" title="执行第 2 次 MinorGC 后状态"></a>执行第 2 次 MinorGC 后状态</h3><p>新对象分配 Eden 区空间不足，又触发了第二次 MinorGC，第二次 MinorGC 与第一次 GC 时在 Eden 区的操作是一样的：将 Eden 区存活的对象复制到 S1 区，然后在清空整个 Eden 区，同时也将 S0 区存活的对象复制到 S1 区并将对象的年龄加 1，再清空 S0 区，GC 后的状态如下图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122171104.png"
                      alt="20240122171104"
                ></p>
<h3 id="执行第-2-次-MinorGC-后，程序运行一段时间后状态"><a href="#执行第-2-次-MinorGC-后，程序运行一段时间后状态" class="headerlink" title="执行第 2 次 MinorGC 后，程序运行一段时间后状态"></a>执行第 2 次 MinorGC 后，程序运行一段时间后状态</h3><p>经过第二 MinorGC 后程序又运行了一段时间，Eden 区中有生成了很多对象，S1 区也有一个对象可回收。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122172309.png"
                      alt="20240122172309"
                ></p>
<h3 id="第-15-次-MinorGC-后内存状态"><a href="#第-15-次-MinorGC-后内存状态" class="headerlink" title="第 15 次 MinorGC 后内存状态"></a>第 15 次 MinorGC 后内存状态</h3><p>在接下来的每次 MinorGC 时，都是第二次一样，从 Eden 区和 survivor 非空白区移动存活对象到 survivor 区中空白区域，并清空这两个区域内存空间，存活对象每此从 survivor 两个区域移动一次，对象年龄加 1，下图表示经过了 15 次 MinorGC 后的堆内存状态。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122172330.png"
                      alt="20240122172330"
                ></p>
<p>对于年轻代区域的内存收集，使用的是标记-复制算法，只是为了减少复制算法空白区域的内存浪费，并不是将内存一份为二，而是巧妙的将内存分为三个区域，预留的空白区域只占整个年轻代区域的 1/10。</p>
<h2 id="对象如何进入老年代"><a href="#对象如何进入老年代" class="headerlink" title="对象如何进入老年代"></a>对象如何进入老年代</h2><p>以上是年轻代的分配与回收问题，那对象如何进入老年代呢？个人认为对象进入老年代，可以分为 2 种类型 6 种情况。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122173016.png"
                      alt="20240122173016"
                ></p>
<h3 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a>直接分配</h3><p>对象创建时直接分配到老年代具体分为 3 种情况：</p>
<ul>
<li>超过虚拟机 PretenureSizeThreshold 参数设置大小的对象，该参数的默认值是 0，也就是说任何大小的对象都会先分配到 Eden 区。</li>
<li>超过 Eden 大小的对象</li>
<li>如果新生代分配失败，一个大数组或者大字符串</li>
</ul>
<h3 id="从年轻代晋升"><a href="#从年轻代晋升" class="headerlink" title="从年轻代晋升"></a>从年轻代晋升</h3><p>从年轻代空间晋升到老年代也可分为 3 种情况：</p>
<ul>
<li>新生代分配担保，在执行 MinorGC 时要将 Eden 区存活的对象复制到 Survivor 区，但是 Survivor 区默认空间是只有新生代的 2/10，实际使用的只有 1/10，当 Survivor 区内存不够所有存活对象分配时，就需要将 Survivor 无法容纳的对象分配到老年代去，这种机制就叫<strong>分配担保</strong>。</li>
<li>对象年龄超过虚拟机 MaxTenuringThreshold 的设置值，最大为 15，</li>
<li>Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半（TargetSurvivorRatio），年龄大于或等于该年龄的对象直接进入老年代。</li>
</ul>
<h3 id="老年代回收算法-FullGC"><a href="#老年代回收算法-FullGC" class="headerlink" title="老年代回收算法-FullGC"></a>老年代回收算法-FullGC</h3><p>当有对象要进入老年代，而老年代空间又不足时就会触发 FullGC，当然，反过来说触发 FullGC 的条件不仅仅只是老年代空间不足，FullGC 使用的算法是上面说的标记-整理算法。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240122173120.png"
                      alt="20240122173120"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>判断对象<strong>是否可以回收</strong>是垃圾回收的基础与前提，通过可达性分析从 GCRoots 开始进行”顺藤摸瓜”找到不可达对象（可回收）</li>
<li>对象生命周期的特征”朝生夕灭”与”越战越强”是垃圾回收算法的理论基础</li>
<li>基础的垃圾回收算法有 3 种分别是 标记-清除算法、标记-复制算法、标记整理算法，都有各自的适应场合与优缺点</li>
<li><strong>分代垃圾算法</strong>根据对象生命周期的特征，将其划分到不同的区域，从而使用最适合的垃圾算法来进行优化</li>
<li>在 JDK8 默认的配置下使用 新生代，老年代的垃圾回收策略，<strong>新生代区域使用标记-复制算法，老年代区域使用标记-整理算法</strong></li>
</ul>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中String与new String的区别</title>
    <url>/p/49908.html</url>
    <content><![CDATA[<p>在Java中，String对象可以通过字面量方式创建，也可以使用new运算符显式地创建。虽然这两种方法都可以创建String对象，但它们存在一些差异。</p>
<ul>
<li>用字面量创建String对象 </li>
</ul>
<p>当使用字面量创建String对象时，存放在方法区，Java会在一个字符串池（string pool）中检查是否存在相同的字符串。如果存在，则返回现有的字符串对象，否则会创建一个新的字符串对象并添加到字符串池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 创建一个字符串，并将其放入字符串池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 检查字符串池中是否已经存在“Hello”，已经存在了就直接返回引用</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 new 运算符显式地创建String对象 </li>
</ul>
<p>使用new运算符创建String对象是不会检查字符串池的，每次创建总会生成一个新的对象，存放在堆空间，即使内容相同，在内存中也是两个不同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 创建一个新的字符串对象，存储在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>由于每次调用new关键字都会创建一个新对象，因此多次使用该方式创建相同内容的字符串对象会占用过多的内存空间。因此建议在不需要改变字符串内容时应该尽量使用字面量的方式创建字符串对象。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中深拷贝和浅拷贝的区别</title>
    <url>/p/13516.html</url>
    <content><![CDATA[<p>👯‍♀️ 老虎老鼠傻傻分不清楚</p>
<span id="more"></span>

<p>在Java中，对象的拷贝可以分为深拷贝和浅拷贝。</p>
<ul>
<li>浅拷贝</li>
</ul>
<p>是指创建一个新对象，然后将原对象的非静态字段值复制到新对象中。如果字段是基本数据类型，那么对应的值会被复制；如果字段是引用类型，那么只会复制引用而不是创建新的对象。这意味着原对象和拷贝对象将共享同一个引用对象。如果修改其中一个对象的引用类型字段，另一个对象也会受到影响。</p>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>是指创建一个新对象，并将原对象的所有字段（无论是基本数据类型还是引用类型）都复制到新对象中。这样，原对象和拷贝对象将完全独立，互不影响。</p>
<h2 id="实现深拷贝有多种方式："><a href="#实现深拷贝有多种方式：" class="headerlink" title="实现深拷贝有多种方式："></a>实现深拷贝有多种方式：</h2><ol>
<li>实现Cloneable接口，并重写clone()方法。在clone()方法中，对于引用类型的字段，需要创建新的对象并复制其内容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> intValue;</span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line">    <span class="keyword">private</span> MyObject objectValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.objectValue = (MyObject) objectValue.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用序列化和反序列化实现深拷贝。将对象写入字节流，然后从字节流中读取数据创建一个新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Serializable</span>&gt; T <span class="title function_">deepCopy</span><span class="params">(T object)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时可以调用<code>DeepCopyUtil.deepCopy()</code>方法来进行深拷贝。</p>
<p>需要注意的是，要实现深拷贝，对象及其所有引用类型字段都必须实现Cloneable接口或者可序列化（Serializable）。否则，在进行深拷贝时会抛出异常。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的HashMap和HashTable到底哪不同？</title>
    <url>/p/54377.html</url>
    <content><![CDATA[<h2 id="父类不同"><a href="#父类不同" class="headerlink" title="父类不同"></a>父类不同</h2><ul>
<li>HashMap 继承自 AbstractMap；</li>
<li>Hashtable 继承自 Dictionary；</li>
</ul>
<h2 id="线程安全性不同"><a href="#线程安全性不同" class="headerlink" title="线程安全性不同"></a>线程安全性不同</h2><ul>
<li>HashMap 线程不安全；<br>Hashtable 线程安全，因为 打开Hashtable的源码可以看到，很多方法都是同步的（synchronized）。<blockquote>
<p>注意：同步的代价就是性能损失，非线程安全场景，建议使用 HashMap。<br>虽然Hashtable是线程安全的,但仍然不建议在多线程环境下使用Hashtable。因为它是一个古老的API,从Java 1.0开始就出现了,它的同步方案还不成熟,性能不好。</p>
</blockquote>
</li>
</ul>
<p>如果要在多线程环下使用HashMap,建议使用ConcurrentHashMap。它不但保证了线程安全,也通过降低锁的粒度提高了并发访问时的性能。</p>
<h2 id="key、value-是否允许null？"><a href="#key、value-是否允许null？" class="headerlink" title="key、value 是否允许null？"></a>key、value 是否允许null？</h2><ul>
<li>HashMap 的 key 和 value 都可以为 null，key 只允许一个 null；</li>
<li>Hashtable 的 key 和 value 都不能为 null；</li>
</ul>
<h2 id="迭代器不同"><a href="#迭代器不同" class="headerlink" title="迭代器不同"></a>迭代器不同</h2><ul>
<li>HashMap.entrySet() 的 Iterator 是 fail-fast 迭代器；</li>
<li>Hashtable.elements() 使用 的是Enumerator 迭代器；</li>
</ul>
<h2 id="什么是-fail-fast？"><a href="#什么是-fail-fast？" class="headerlink" title="什么是 fail-fast？"></a>什么是 fail-fast？</h2><p>fail-fast 机制是 java 集合中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出<br><strong>ConcurrentModificationException</strong> 异常，产生 fail-fast 事件。</p>
<h2 id="hash-的计算方式不同"><a href="#hash-的计算方式不同" class="headerlink" title="hash 的计算方式不同"></a>hash 的计算方式不同</h2><ul>
<li>HashMap 计算了 hash 值；HashMap 中最核心的部分就是哈希函数，又称散列函数。也就是说，哈希函数是通过把 key 的 hash 值映射到数组中的一个位置来进行访问。</li>
<li>Hashtable 使用了 key 的 hashCode 方法；</li>
</ul>
<h2 id="默认初始大小和扩容方式不同"><a href="#默认初始大小和扩容方式不同" class="headerlink" title="默认初始大小和扩容方式不同"></a>默认初始大小和扩容方式不同</h2><p>**HashMap 默认初始大小 16，容量必须是 2 的整数次幂，扩容时将容量变为原来的2倍；</p>
<ul>
<li>Hashtable 默认初始大小 11，扩容时将容量变为原来的 2 倍加 1；</li>
</ul>
<h2 id="是否有-contains-方法？"><a href="#是否有-contains-方法？" class="headerlink" title="是否有 contains 方法？"></a>是否有 contains 方法？</h2><ul>
<li>HashMap 没有 contains 方法，但是添加了 containsValue() 和 containsKey() 方法；</li>
<li>Hashtable 包含 contains 方法，类似于 containsValue；</li>
</ul>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的final关键字</title>
    <url>/p/5404.html</url>
    <content><![CDATA[<p>🍂 唯一不变的是final</p>
<span id="more"></span>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>final 是 Java 中的一个关键字，可以用于修饰类、方法和变量。<br>当一个类被声明为 final 时，它意味着该类不能被继承。<br>当一个方法被声明为 final 时，它意味着该方法不能被重写。<br>当一个变量被声明为 final 时，它意味着该变量的值不能被修改。</p>
<h3 id="final饰修类"><a href="#final饰修类" class="headerlink" title="final饰修类"></a>final饰修类</h3><blockquote>
<p>举例<code>String</code>类就是final修饰的，所以不能被继承，进而重写其方法</p>
</blockquote>
<p>如果声明一个类为final类,  那么这个类就是最终类,不能被继承</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class ParentClass &#123;</span><br><span class="line">    public void happy() &#123;</span><br><span class="line">        System.out.println(&quot;高兴&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当写一个类去继承它的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ChildClass extends ParentClass&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会报错错误；</p>
<blockquote>
<p>注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。</p>
</blockquote>
<p>final类中的成员变量可以根据需要设为final，但是final类中的所有成员方法都会被隐式地指定为final方法。 在使用final修饰类的时候，一定要谨慎选择，除非这个类以后不会用来继承或者出于安全考虑，尽量不要将类设计为final类。</p>
<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><p>当final用来修饰一个方法的时候，这个方法就是最终方法，那么很明显就是说不能被覆盖重写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ParentClass &#123;</span><br><span class="line"> </span><br><span class="line">    public void happy() &#123;</span><br><span class="line">        System.out.println(&quot;高兴&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //用final关键字修饰的方法</span><br><span class="line">    protected final void play()&#123;</span><br><span class="line">        System.out.println(&quot;开心的玩耍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在继承类中去看下 play()方法是不可以被override的，也就是是报错，说明 final修饰的方法，是一个最终方法，不能被子类去覆盖重写。</p>
<h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><p>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</p>
<ul>
<li>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li>
<li>当final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为<strong>引用的值是一个地址</strong>，final要求值，即地址的值不发生变化。<br>final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private final int count = 0;</span><br><span class="line">    public Animal() &#123;</span><br><span class="line">        count = 1; //报错</span><br><span class="line">        final Object object = new Object();</span><br><span class="line">        object = new Object(); //报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的try，如何开启新姿势？</title>
    <url>/p/44518.html</url>
    <content><![CDATA[<blockquote>
<p>时间紧迫，长话短说，今天，小明给大家同步一个知识点，使用<strong>try-with-resources</strong>来优雅地关闭资源。</p>
</blockquote>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>其实，在JDK 7就已经引入了对<strong>try-with-resources</strong>的支持，它的主要作用就是解放小明和小明小伙伴们的双手，帮助我们自动释放使用过的资源（比如输入、输出流）。</p>
<span id="more"></span>
<h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><p>如何才能使用这个自动关闭资源的骚操作呢？我们只需要在try内声明和初始化资源即可，如下所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002129.png"
                     
                ></p>
<p>这样，当我们写入文件时，只需要将心思放在输入的内容就行啦。</p>
<h2 id="3-使用try-with-resources的好处"><a href="#3-使用try-with-resources的好处" class="headerlink" title="3.使用try-with-resources的好处"></a>3.使用try-with-resources的好处</h2><p>在很久很久以前，你是不是和小明一样每每操作输入流、输出流的时候，用的都是<strong>try-catch-finally</strong>代码块？</p>
<p>现在，答应我好嘛，作为小明的小伙伴，看完这篇文章后，再写代码时，不要再将就，务必使用<strong>try-with-resources</strong>会更小明（优雅）一些。</p>
<p>接下来，我们简单地做个比较：</p>
<h4 id="之前的小明"><a href="#之前的小明" class="headerlink" title="之前的小明"></a>之前的小明</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002209.png"
                     
                ></p>
<h5 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h5><p>整体感觉很传统，很冗长。</p>
<h4 id="现在的小明"><a href="#现在的小明" class="headerlink" title="现在的小明"></a>现在的小明</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002247.png"
                     
                ></p>
<h5 id="点评-1"><a href="#点评-1" class="headerlink" title="点评"></a>点评</h5><p>整体感觉很轻巧，很优雅。</p>
<h2 id="4-还可以控制多个资源哦"><a href="#4-还可以控制多个资源哦" class="headerlink" title="4. 还可以控制多个资源哦"></a>4. 还可以控制多个资源哦</h2><p>如果我们想一边控制输入、一边控制输出怎么办？</p>
<p>通通放进去！如图所示</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002320.png"
                     
                ></p>
<h2 id="5-幕后功臣：Closeable"><a href="#5-幕后功臣：Closeable" class="headerlink" title="5.幕后功臣：Closeable"></a>5.幕后功臣：Closeable</h2><p>为什么把资源放进<strong>try-with-resources</strong>，我们就可以束手旁观，高枕无忧呢？原来，要想合法进去<strong>try-with-resources</strong>，不被报警，是需要门票的：实现<strong>Closeable</strong>或<strong>AutoCloseable</strong>接口，并重写<strong>close</strong>方法。就像这样：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002404.png"
                     
                ></p>
<h2 id="6-多个资源的情况下如何顺序关闭呢？"><a href="#6-多个资源的情况下如何顺序关闭呢？" class="headerlink" title="6.多个资源的情况下如何顺序关闭呢？"></a>6.多个资源的情况下如何顺序关闭呢？</h2><blockquote>
<p>剧透：先创建的资源，最后关闭。</p>
</blockquote>
<p>这个故事是这样讲的：小明和小红一起打王者荣耀……</p>
<h5 id="小明"><a href="#小明" class="headerlink" title="小明:"></a>小明:</h5><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002436.png"
                     
                ></p>
<h5 id="小红"><a href="#小红" class="headerlink" title="小红:"></a>小红:</h5><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/codeimg-facebook-shared-image.jpeg"
                     
                ></p>
<h5 id="全军出击"><a href="#全军出击" class="headerlink" title="全军出击:"></a>全军出击:</h5><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002515.png"
                     
                ></p>
<h5 id="故事纵览"><a href="#故事纵览" class="headerlink" title="故事纵览:"></a>故事纵览:</h5><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200413002554.png"
                     
                ></p>
<p>提问：结局是不是和剧透一致？</p>
<h2 id="7-补充"><a href="#7-补充" class="headerlink" title="7. 补充"></a>7. 补充</h2><p>我们使用<strong>try-with-resources</strong>的时候不仅可以优雅地释放资源，而且还可以传统一些，照常使用<strong>catch</strong>和<strong>finally</strong>哦。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>经过小明这么一番生动的讲解：</p>
<p>你是否知道了什么是<strong>try-with-resources</strong>？</p>
<p>你是否知道了如何用<strong>try-with-resources</strong>替换<strong>try-catch-finally</strong>？</p>
<p>你是否知道了<strong>AutoCloseable</strong>构建自定义资源以及关闭资源的顺序？</p>
<blockquote>
<p>附Github源码地址:<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming" >https://github.com/WhenCoding/coder-xiaoming<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>@NotNull</title>
    <url>/p/bf38.html</url>
    <content><![CDATA[<blockquote>
<p>摘自 <a class="link"   href="https://zaizai2013.iteye.com/blog/2352683"  title="Java中的注解 - @NotNull">mhtbbx：”Java中的注解 - @NotNull”<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>比如说，你写了一个后台系统，接收用户的请求，经过运算后返回结果，很通用的一个实现方案。假定所有的方法都需要校验参数是否为空，不然就可能有NullPointerException，如果系统有N个接口，每个接口参数有M个，你需要写N * M个if判断语句。如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (StringUtils.isBlank(request.getA())) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;A is blank&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么写下来，肯定代码是很丑的。那怎么办呢？记得我们之前说过的编码理念，<em>Don’t repeat yourself</em>，就派上用场了。</p>
<h2 id="简单校验"><a href="#简单校验" class="headerlink" title="简单校验"></a>简单校验</h2><h3 id="编写需要校验的bean"><a href="#编写需要校验的bean" class="headerlink" title="编写需要校验的bean"></a>编写需要校验的bean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NotNull(message=&quot;名字不能为空&quot;)</span><br><span class="line">private String userName;</span><br><span class="line">@Max(value=120,message=&quot;年龄最大不能查过120&quot;)</span><br><span class="line">private int age;</span><br><span class="line">@Email(message=&quot;邮箱格式错误&quot;)</span><br><span class="line">private String email;</span><br></pre></td></tr></table></figure>
<h3 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/login&quot;)</span><br><span class="line">public String testValid(@Valid User user, BindingResult result)&#123;</span><br><span class="line">    if (result.hasErrors())&#123;</span><br><span class="line">        List&lt;ObjectError&gt; errorList = result.getAllErrors();</span><br><span class="line">        for(ObjectError error : errorList)&#123;</span><br><span class="line">            System.out.println(error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>备注：这里一个@Valid的参数后必须紧挨着一个BindingResult 参数，否则spring会在校验不通过时直接抛出异常</strong></p>
<h2 id="级联校验"><a href="#级联校验" class="headerlink" title="级联校验"></a>级联校验</h2><h3 id="编写相关的bean"><a href="#编写相关的bean" class="headerlink" title="编写相关的bean"></a>编写相关的bean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReportVO &#123;  </span><br><span class="line">  </span><br><span class="line">    @NotNull(message = &quot;举报内容不能为空&quot;)  </span><br><span class="line">    @Valid</span><br><span class="line">    private ReportContent content;  </span><br><span class="line">  </span><br><span class="line">    @NotNull(message = &quot;举报信息不能为空&quot;)  </span><br><span class="line">    @Valid  </span><br><span class="line">    private ReportInfo info;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReportInfo extends BaseTenantDomain&lt;String&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    private String reportContentId;  </span><br><span class="line">  </span><br><span class="line">    @NotBlank(message = &quot;举报人id不能为空&quot;)  </span><br><span class="line">    private String reportorId;  </span><br><span class="line">  </span><br><span class="line">    @NotNull(message = &quot;举报类型不能为空&quot;)  </span><br><span class="line">    private ReportType reportType;  </span><br><span class="line">  </span><br><span class="line">    @NotBlank(message = &quot;举报详细描述不能为空&quot;)  </span><br><span class="line">    @Size(max=100, message = &quot;举报详细描述不能超过100&quot;)  </span><br><span class="line">    private String desc;  </span><br><span class="line">  </span><br><span class="line">    private Date reportTime; // 举报时间  </span><br><span class="line">    private Date dealTime; // 处理时间  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="校验方法-1"><a href="#校验方法-1" class="headerlink" title="校验方法"></a>校验方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void report(@RequestBody @Valid ReportVO reportVo,BindingResult result) &#123;  </span><br><span class="line">    contentService.report(reportVo.getContent(), reportVo.getInfo());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal解决了什么问题？</title>
    <url>/p/b5c2.html</url>
    <content><![CDATA[<blockquote>
<p>小明所在的项目组（迭代组：一直在迭代的路上），经常会在已有接口的基础上开发一些小功能，并且前提是在保证现有用户的不受影响基础上迭代。功能迭代，在代码层面小明有1w种实现方法（吹牛的），一起来看看这次小明如何使用<strong>ThreadLocal</strong>优雅地完成本次迭代吧！</p>
</blockquote>
<p>由于 ThreadLocal 支持范型，如 ThreadLocal&lt; StringBuilder &gt;，为表述方便，后文用 <strong>变量</strong> 代表 ThreadLocal 本身，而用 <strong>实例</strong> 代表具体类型（如 StringBuidler ）的实例。</p>
<span id="more"></span>
<h2 id="理解误区"><a href="#理解误区" class="headerlink" title="理解误区"></a>理解误区</h2><p>写这篇文章之前，小明就在网上看了很多博客关于 ThreadLocal 的适用场景以及解决的问题，描述的都并不是很清楚，甚至误人子弟的。比如下面是常见对于 ThreadLocal的介绍（<strong>wrong</strong>）</p>
<blockquote>
<p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；<br>ThreadLocal的目的是为了解决多线程访问资源时的共享问题。</p>
</blockquote>
<p>在小明大量阅读和动手实验后得出结论：ThreadLocal 并不是像上面所说为了解决多线程 <strong>共享</strong>变量的问题。</p>
<h2 id="正确理解"><a href="#正确理解" class="headerlink" title="正确理解"></a>正确理解</h2><p>ThreadLoal 变量，它的基本原理是，同一个 ThreadLocal 所包含的对象（对ThreadLocal&lt; StringBuilder &gt;而言即为 StringBuilder 类型变量），在不同的 Thread 中有不同的副本（实际上是不同的实例）:</p>
<ul>
<li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用；</li>
<li>既然其它 Thread 不可访问，那就不存在多线程间共享的问题。</li>
</ul>
<p>官方文档是这样描述的：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/blogimage_20191213135422.png"
                      alt="localthreadofjdk"
                ></p>
<p>我看完之后，得出这样的结论</p>
<blockquote>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都会被回收。</p>
</blockquote>
<p>因此<strong>ThreadLocal 非常适用于这样的场景：每个线程需要自己独立的实例且该实例需要在多个方法中使用</strong>。当然，使用其它方式也可以实现同样的效果，但是看完这篇文章，你会发现 ThreadLocal 会让实现更简洁、更优雅！</p>
<h1 id="ThreadLocal用法"><a href="#ThreadLocal用法" class="headerlink" title="ThreadLocal用法"></a>ThreadLocal用法</h1><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p>我们通过下面的代码，先做个示例，然后分析一下现象，得出一个结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int threadNum = 3;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(threadNum);</span><br><span class="line">        for (int i = 1; i &lt;= threadNum; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt;= 2; j++) &#123;</span><br><span class="line">                    MyUtil.add(String.valueOf(j));</span><br><span class="line">                    MyUtil.print();</span><br><span class="line">                &#125;</span><br><span class="line">                MyUtil.set(&quot;hello world&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, &quot;thread - &quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class MyUtil &#123;</span><br><span class="line"></span><br><span class="line">        public static void add(String newStr) &#123;</span><br><span class="line">            StringBuilder str = StringBuilderUtil.stringBuilderThreadLocal.get();</span><br><span class="line">            StringBuilderUtil.stringBuilderThreadLocal.set(str.append(newStr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void print() &#123;</span><br><span class="line">            System.out.printf(&quot;Thread name:%s , ThreadLocal hashcode:%s, Instance hashcode:%s, Value:%s\n&quot;,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void set(String words) &#123;</span><br><span class="line">            StringBuilderUtil.stringBuilderThreadLocal.set(new StringBuilder(words));</span><br><span class="line">            System.out.printf(&quot;Set, Thread name:%s , ThreadLocal hashcode:%s,  Instance hashcode:%s, Value:%s\n&quot;,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class StringBuilderUtil &#123;</span><br><span class="line">        // ThreadLocal 变量通常被 private static 修饰</span><br><span class="line">        private static ThreadLocal&lt;StringBuilder&gt; stringBuilderThreadLocal = ThreadLocal.withInitial(() -&gt; new StringBuilder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>ThreadLocal本身支持范型，比如该例使用了 StringBuilder 类型的 ThreadLocal 变量。可通过 ThreadLocal 的 get() 方法读取 StringBuidler 实例，也可通过 set(T t) 方法设置 StringBuilder。</p>
<blockquote>
<p>tips:CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个场景：任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。下次，我们可以单独聊聊这一个功能。</p>
</blockquote>
<p>点击运行，控制台输出结果</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/blogimage_20191213102939.png"
                      alt="123"
                ></p>
<p>我们可以发现：</p>
<ul>
<li>每个线程访问的是同一个 ThreadLocal 变量，而通过 ThreadLocal 的 get() 方法拿到的是不同的 StringBuilder 实例；</li>
<li>虽然从代码上都是对 StringBuilderUtil 类的静态 stringBuilderThreadLocal 字段进行 get() 得到 StringBuilder 实例并追加字符串，但是这并不会将所有线程追加的字符串都放进同一个 StringBuilder 中，而是每个线程将字符串追加进各自的 StringBuidler 实例内</li>
<li>使用 set(T t) 方法后，ThreadLocal 变量所指向的 StringBuilder 实例被替换</li>
</ul>
<h1 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>我们大胆猜想一下，既然每个访问 ThreadLocal 变量的线程都有自己的一个“本地”实例副本。一个可能的方案是 ThreadLocal 维护一个 Map，Key 是当前线程，Value是ThreadLocal在当前线程内的实例。这样，线程通过该 ThreadLocal 的 get() 方案获取实例时，只需要以线程为键，从 Map 中找出对应的实例即可。该方案如下图所示</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/blogVarMap_20191213134650.png"
                      alt="VarMap"
                ></p>
<p>这个方案可以满足上文提到的每个线程内部都有一个ThreadLocal 实例备份的要求。每个新线程访问该 ThreadLocal 时，都会向 Map 中添加一个新的映射，而当每个线程结束时再清除该线程对应的映射。But，这样就存在两个问题：</p>
<ul>
<li>开启线程与结束线程时我们都需要及时更新 Map，因此必需保证 Map 的线程安全。</li>
<li>当线程结束时，需要保证它所访问的所有 ThreadLocal 中对应的映射均删除，否则可能会引起内存泄漏。</li>
</ul>
<p>线程安全问题是JDK 未采用该方案的一个主要原因。</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>上面这个方案，存在多线程访问同一个 Map时可能会出现的同步问题。如果该 Map 由 Thread 维护，从而使得每个 Thread 只访问自己的 Map，就不存在这个问题。该方案如下图所示。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/blogThreadMap_20191213134650.png"
                      alt="ThreadMap"
                ></p>
<p>该方案虽然没有锁的问题，但是由于每个线程在访问ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLocal 变量与具体实例的映射，如果不删除这些引用（映射），就有可能会造成内存泄漏的问题。我们一起来看一下Jdk8是如何解决这个问题的。</p>
<h2 id="ThreadLocal-在-JDK-8-中的实现"><a href="#ThreadLocal-在-JDK-8-中的实现" class="headerlink" title="ThreadLocal 在 JDK 8 中的实现"></a>ThreadLocal 在 JDK 8 中的实现</h2><h3 id="ThreadLocalMap与内存泄漏"><a href="#ThreadLocalMap与内存泄漏" class="headerlink" title="ThreadLocalMap与内存泄漏"></a>ThreadLocalMap与内存泄漏</h3><p>在该方案中，Map 由 ThreadLocal 类的静态内部类 ThreadLocalMap 提供。该类的实例维护某个 ThreadLocal 与具体实例的映射。与 HashMap 不同的是，ThreadLocalMap 的每个 <strong>Entry</strong> 都是一个对 <strong>Key</strong> 的弱引用，这一点我们可以从<code>super(k)</code>可看出。另外，每个 Entry 中都包含了一个对 <strong>Value</strong> 的强引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">  /** The value associated with this ThreadLocal. */</span><br><span class="line">  Object value;</span><br><span class="line"></span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    super(k);</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>之所以使用弱引用，是因为当没有强引用指向 ThreadLocal 变量时，这个变量就可以被回收，就避免ThreadLocal 因为不能被回收而造成的内存泄漏的问题。</p>
<p>但是，这里又可能出现另外一种内存泄漏的问题。ThreadLocalMap 维护 ThreadLocal 变量与具体实例的映射，当 ThreadLocal 变量被回收后，该映射的键变为 null，该 Entry 无法被移除。从而使得实例被该 Entry 引用而无法被回收造成内存泄漏。</p>
<p><strong>注意：</strong> Entry是对 ThreadLocal 类型的弱引用，并不是具体实例的弱引用，因此还存在具体实例相关的内存泄漏的问题。</p>
<h3 id="读取实例"><a href="#读取实例" class="headerlink" title="读取实例"></a>读取实例</h3><p>我们来看一下ThreadLocal获取实例的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">    if (e != null) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      T result = (T)e.value;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程获取实例时，首先会通过<code>getMap(t)</code>方法获取自身的 ThreadLocalMap。从如下该方法的定义可见，该 ThreadLocalMap 的实例是 Thread 类的一个字段，即由 Thread 维护 ThreadLocal 对象与具体实例的映射，这一点与上文分析一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">  return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到 ThreadLocalMap 后，通过<code>map.getEntry(this)</code>方法获取该 ThreadLocal 在当前线程的 ThreadLocalMap 中对应的 Entry。该方法中的 this 即当前访问的 ThreadLocal 对象。</p>
<p>如果获取到的 Entry 不为 null，从 Entry 中取出值即为所需访问的本线程对应的实例。如果获取到的 Entry 为 null，则通过<code>setInitialValue()</code>方法设置该 ThreadLocal 变量在该线程中对应的具体实例的初始值。</p>
<h3 id="设置初始值"><a href="#设置初始值" class="headerlink" title="设置初始值"></a>设置初始值</h3><p>设置初始值方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">  T value = initialValue();</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null)</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  else</span><br><span class="line">    createMap(t, value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法为 private 方法，无法被重载。</p>
<p>首先，通过<code>initialValue()</code>方法获取初始值。该方法为 public 方法，且默认返回 null。所以典型用法中常常重载该方法。上例中即在内部匿名类中将其重载。</p>
<p>然后拿到该线程对应的 ThreadLocalMap 对象，若该对象不为 null，则直接将该 ThreadLocal 对象与对应实例初始值的映射添加进该线程的 ThreadLocalMap中。若为 null，则先创建该 ThreadLocalMap 对象再将映射添加其中。</p>
<p>这里并不需要考虑 ThreadLocalMap 的线程安全问题。因为每个线程有且只有一个 ThreadLocalMap 对象，并且只有该线程自己可以访问它，其它线程不会访问该 ThreadLocalMap，也即该对象不会在多个线程中共享，也就不存在线程安全的问题。</p>
<h3 id="设置实例"><a href="#设置实例" class="headerlink" title="设置实例"></a>设置实例</h3><p>除了通过<code>initialValue()</code>方法设置实例的初始值，还可通过 set 方法设置线程内实例的值，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null)</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  else</span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法先获取该线程的 ThreadLocalMap 对象，然后直接将 ThreadLocal 对象（即代码中的 this）与目标实例的映射添加进 ThreadLocalMap 中。当然，如果映射已经存在，就直接覆盖。另外，如果获取到的 ThreadLocalMap 为 null，则先创建该 ThreadLocalMap 对象。</p>
<h3 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h3><p>对于已经不再被使用且已被回收的 ThreadLocal 对象，它在每个线程内对应的实例由于被线程的 ThreadLocalMap 的 Entry 强引用，无法被回收，可能会造成内存泄漏。</p>
<p>针对该问题，ThreadLocalMap 的 set 方法中，通过 replaceStaleEntry 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 rehash 方法中通过 expungeStaleEntry 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  int len = tab.length;</span><br><span class="line">  int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">  for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    if (k == key) &#123;</span><br><span class="line">      e.value = value;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (k == null) &#123;</span><br><span class="line">      replaceStaleEntry(key, value, i);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tab[i] = new Entry(key, value);</span><br><span class="line">  int sz = ++size;</span><br><span class="line">  if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>对于 Java Web 应用而言，Session 保存了很多信息。很多时候需要通过 Session 获取信息，有些时候又需要修改 Session 的信息。一方面，需要保证每个线程有自己单独的 Session 实例。另一方面，由于很多地方都需要操作 Session，存在多方法共享 Session 的需求。如果不使用 ThreadLocal，可以在每个线程内构建一个 Session实例，并将该实例在多个方法间传递，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SessionHandler &#123;</span><br><span class="line"></span><br><span class="line">  @Data</span><br><span class="line">  public static class Session &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String user;</span><br><span class="line">    private String status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Session createSession() &#123;</span><br><span class="line">    return new Session();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getUser(Session session) &#123;</span><br><span class="line">    return session.getUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getStatus(Session session) &#123;</span><br><span class="line">    return session.getStatus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setStatus(Session session, String status) &#123;</span><br><span class="line">    session.setStatus(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      SessionHandler handler = new SessionHandler();</span><br><span class="line">      Session session = handler.createSession();</span><br><span class="line">      handler.getStatus(session);</span><br><span class="line">      handler.getUser(session);</span><br><span class="line">      handler.setStatus(session, &quot;close&quot;);</span><br><span class="line">      handler.getStatus(session);</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是可以实现需求的。但是每个需要使用 Session 的地方，都需要显式传递 Session 对象，方法间耦合度较高，给人的感觉并不优雅。</p>
<p>这里使用 ThreadLocal 重新实现该功能如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SessionHandler &#123;</span><br><span class="line"></span><br><span class="line">  public static ThreadLocal&lt;Session&gt; session = ThreadLocal.&lt;Session&gt;withInitial(() -&gt; new Session());</span><br><span class="line"></span><br><span class="line">  @Data</span><br><span class="line">  public static class Session &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String user;</span><br><span class="line">    private String status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getUser() &#123;</span><br><span class="line">    return session.get().getUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getStatus() &#123;</span><br><span class="line">    return session.get().getStatus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setStatus(String status) &#123;</span><br><span class="line">    session.get().setStatus(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      SessionHandler handler = new SessionHandler();</span><br><span class="line">      handler.getStatus();</span><br><span class="line">      handler.getUser();</span><br><span class="line">      handler.setStatus(&quot;close&quot;);</span><br><span class="line">      handler.getStatus();</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，改造过后的代码，不再需要在各个方法间来回传递 Session 对象，并且不费吹灰之力保证了每个线程都能够拥有自己独立的实例。虽然单看其中某一点，备选方案还很多。比如还可以通过在线程内创建局部变量保证每个线程有自己的实例，通过静态变量可实现变量在方法间的共享。但如果还需要同时满足变量在线程间的隔离与方法间的共享，ThreadLocal再合适不过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>ThreadLocal 并不解决线程间共享数据的问题</li>
<li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li>
<li>每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li>
<li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题</li>
<li>ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏</li>
<li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li>
</ul>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8 Optional 的正确使用姿势</title>
    <url>/p/d6b5.html</url>
    <content><![CDATA[<p>我们知道 Java 8 增加了一些很有用的 API, 其中一个就是 <code>Optional</code>. 如果对它不稍假探索, 只是轻描淡写的认为它可以优雅的解决 <code>NullPointException</code> 的问题, 于是代码就开始这么写了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; user = ……</span><br><span class="line">if (user.isPresent()) &#123;</span><br><span class="line">return user.getOrders();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么不得不说我们的思维仍然是在原地踏步, 只是本能的认为它不过是 User 实例的包装, 这与我们之前写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User user = …..</span><br><span class="line">if (user != null) &#123;</span><br><span class="line">return user.getOrders();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实质上是没有任何分别. 这就是我们将要讲到的使用好 Java 8 <code>Optional</code> 类型的正确姿势.</p>
<p>在里约奥运之时, 新闻一再提起五星红旗有问题, 可是我怎么看都看不出来有什么问题, 后来才道是小星星膜拜中央的姿势不对. 因此我们千万也别对自己习以为常的事情觉得理所当然, 丝毫不会觉得有何不妥, 换句话说也就是当我们切换到 Java 8 的 <code>Optional</code> 时, 不能继承性的对待过往 <code>null</code> 时的那种思维, 应该掌握好新的, 正确的使用 Java 8 <code>Optional</code> 的正确姿势.</p>
<p>直白的讲, 当我们还在以如下几种方式使用 <code>Optional</code> 时, 就得开始检视自己了</p>
<ul>
<li>调用 <code>isPresent()</code> 方法时</li>
<li>调用 <code>get()</code> 方法时</li>
<li><code>Optional</code> 类型作为类/实例属性时</li>
<li><code>Optional</code> 类型作为方法参数时</li>
</ul>
<p><code>Optional</code> 中我们真正可依赖的应该是除了 <code>isPresent()</code> 和 <code>get() </code>的其他方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</span><br><span class="line">public T orElse(T other)</span><br><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; other)</span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer)</span><br><span class="line">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br><span class="line">public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</span><br><span class="line">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</span><br></pre></td></tr></table></figure>

<p>我略有自信的按照它们大概使用频度对上面的方法排了一下序。先又不得不提一下 Optional 的三种构造方式: Optional.of(obj),  <code>Optional.ofNullable(obj)</code> 和明确的 <code>Optional.empty()</code>;</p>
<ul>
<li><code>Optional.of(obj)</code>: 它要求传入的 <code>obj</code> 不能是 <code>null</code> 值的, 否则还没开始进入角色就倒在了 <code>NullPointerException</code> 异常上了.</li>
</ul>
<p><code>Optional.ofNullable(obj)</code>: 它以一种智能的, 宽容的方式来构造一个 <code>Optional</code> 实例. 来者不拒, 传 <code>null</code> 进到就得到 <code>Optional.empty()</code>, 非 <code>null</code> 就调用 <code>Optional.of(obj)</code>.</p>
<p>那是不是我们只要用 <code>Optional.ofNullable(obj)</code> 一劳永逸, 以不变应二变的方式来构造 <code>Optional</code> 实例就行了呢? 那也未必, 否则 <code>Optional.of(obj)</code> 何必如此暴露呢, 私有则可?</p>
<p>我本人的观点是:  </p>
<ol>
<li>当我们非常非常的明确将要传给 <code>Optional.of(obj)</code> 的 <code>obj</code> 参数不可能为 <code>null</code> 时, 比如它是一个刚 <code>new</code> 出来的对象<code>(Optional.of(new User(...)))</code>, 或者是一个非 <code>null</code> 常量时;  </li>
<li>当想为 <code>obj</code> 断言不为 <code>null</code> 时, 即我们想在万一 <code>obj</code> 为 <code>null</code> 立即报告 <code>NullPointException</code> 异常, 立即修改, 而不是隐藏空指针异常时, 我们就应该果断的用 <code>Optional.of(obj)</code> 来构造 <code>Optional</code> 实例, 而不让任何不可预计的 <code>null</code> 值有可乘之机隐身于 <code>Optional</code> 中.</li>
</ol>
<p>现在才开始怎么去使用一个已有的 Optional 实例, 假定我们有一个实例 <code>Optional&lt;User&gt; user</code>, 下面是几个普遍的, 应避免 <code>if(user.isPresent()) &#123; ... &#125; else &#123; ... &#125; </code>几中应用方式.</p>
<h2 id="存在即返回-无则提供默认值"><a href="#存在即返回-无则提供默认值" class="headerlink" title="存在即返回, 无则提供默认值"></a>存在即返回, 无则提供默认值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return user.orElse(null);  //而不是 return user.isPresent() ? user.get() : null;</span><br><span class="line">return user.orElse(UNKNOWN_USER);</span><br></pre></td></tr></table></figure>
<h2 id="存在即返回-无则由函数来产生"><a href="#存在即返回-无则由函数来产生" class="headerlink" title="存在即返回, 无则由函数来产生"></a>存在即返回, 无则由函数来产生</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return user.orElseGet(() -&gt; fetchAUserFromDatabase()); //而不要 return user.isPresent() ? user: fetchAUserFromDatabase();</span><br></pre></td></tr></table></figure>

<h2 id="存在才对它做点什么"><a href="#存在才对它做点什么" class="headerlink" title="存在才对它做点什么"></a>存在才对它做点什么</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user.ifPresent(System.out::println); //传入一个Consumer&lt;? super T&gt; consumer</span><br><span class="line">//而不要下边那样</span><br><span class="line">if (user.isPresent()) &#123;</span><br><span class="line">  System.out.println(user.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-函数隆重登场"><a href="#map-函数隆重登场" class="headerlink" title="map 函数隆重登场"></a>map 函数隆重登场</h2><p>当 <code>user.isPresent()</code> 为真, 获得它关联的 <code>orders</code>, 为假则返回一个空集合时, 我们用上面的 <code>orElse</code>, <code>orElseGet</code> 方法都乏力时, 那原本就是 <code>map</code> 函数的责任, 我们可以这样一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return user.map(u -&gt; u.getOrders()).orElse(Collections.emptyList())</span><br><span class="line"> </span><br><span class="line">//上面避免了我们类似 Java 8 之前的做法</span><br><span class="line">if(user.isPresent()) &#123;</span><br><span class="line">  return user.get().getOrders();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map  是可能无限级联的, 比如再深一层, 获得用户名的大写形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return user.map(u -&gt; u.getUsername())</span><br><span class="line">           .map(name -&gt; name.toUpperCase())</span><br><span class="line">           .orElse(null);</span><br></pre></td></tr></table></figure>
<p>这要搁在以前, 每一级调用的展开都需要放一个 null 值的判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User user = .....</span><br><span class="line">if(user != null) &#123;</span><br><span class="line">  String name = user.getUsername();</span><br><span class="line">  if(name != null) &#123;</span><br><span class="line">    return name.toUpperCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对这方面 Groovy 提供了一种安全的属性/方法访问操作符 ?.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user?.getUsername()?.toUpperCase();</span><br></pre></td></tr></table></figure>

<p>Swift 也有类似的语法, 只作用在  Optional 的类型上.</p>
<p>用了 <code>isPresent()</code> 处理 <code>NullPointerException</code> 不叫优雅, 有了  <code>orElse</code>, <code>orElseGet</code> 等, 特别是 <code>map</code> 方法才叫优雅.</p>
<p>其他几个, <code>filter()</code> 把不符合条件的值变为 <code>empty()</code>,  <code>flatMap()</code> 总是与 <code>map()</code> 方法成对的,  <code>orElseThrow()</code> 在有值时直接返回, 无值时抛出想要的异常.</p>
<p>一句话小结: 使用 <code>Optional</code> 时尽量不直接调用 <code>Optional.get()</code> 方法, <code>Optional.isPresent()</code> 更应该被视为一个私有方法, 应依赖于其他像 <code>Optional.orElse()</code>, <code>Optional.orElseGet()</code>, <code>Optional.map()</code> 等这样的方法.</p>
<p>最后, 最好的理解 Java 8 <code>Optional</code> 的方法莫过于看它的源代码 <code>java.util.Optional</code>, 阅读了源代码才能真真正正的让你解释起来最有底气, <code>Optional</code> 的方法中基本都是内部调用  <code>isPresent() </code>判断, 真时处理值, 假时什么也不做.</p>
<p>参考链接:</p>
<p><a class="link"   href="http://blog.jhades.org/java-8-how-to-use-optional/" >Java 8 Optional: How to Use it<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" >Tired of Null Pointer Exceptions? Consider Using Java SE 8′s Optional!<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8</title>
    <url>/p/2f61.html</url>
    <content><![CDATA[<blockquote>
<p>参考自 1. <a class="link"   href="https://www.jianshu.com/p/5b800057f2d8"  title="java8新特性-终极版">杜琪<i class="fas fa-external-link-alt"></i></a>，2. github地址：<a class="link"   href="https://github.com/winterbe/java8-tutorial"  title="Java 8 新特性最佳指南">SnailClimb<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习这些新特性，并用实际的例子说明在什么场景下适合使用。</p>
<p>这个教程包含Java开发者经常面对的几类问题：</p>
<span id="more"></span>

<ul>
<li>语言</li>
<li>编译器</li>
<li>库</li>
<li>工具</li>
<li>运行时（JVM）</li>
</ul>
<h1 id="Java语言的新特性"><a href="#Java语言的新特性" class="headerlink" title="Java语言的新特性"></a>Java语言的新特性</h1><p>Java 8是Java的一个重大版本，有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。在这一小节中，我们将介绍Java 8的大部分新特性。</p>
<h2 id="Lambda表达式和函数式接口"><a href="#Lambda表达式和函数式接口" class="headerlink" title="Lambda表达式和函数式接口"></a>Lambda表达式和函数式接口</h2><p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。</p>
<p>Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure>
<p>在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure>
<p>如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print( e );</span><br><span class="line">    System.out.print( e );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String separator = &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final String separator = &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>
<p>Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    int result = e1.compareTo( e2 );</span><br><span class="line">    return result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Functional &#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalDefaultMethods &#123;</span><br><span class="line">    void method();</span><br><span class="line">        </span><br><span class="line">    default void defaultMethod() &#123;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式作为Java 8的最大卖点，它有潜力吸引更多的开发者加入到JVM平台，并在纯Java编程中使用函数式编程的概念。如果你需要了解更多Lambda表达式的细节，可以参考官方文档。</p>
<h2 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h2><p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Defaulable &#123;</span><br><span class="line">    // Interfaces now allow default methods, the implementer may or </span><br><span class="line">    // may not implement (override) them.</span><br><span class="line">    default String notRequired() &#123; </span><br><span class="line">        return &quot;Default implementation&quot;; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">public  class DefaultableImpl implements Defaulable &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public  class OverridableImpl implements Defaulable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String notRequired() &#123;</span><br><span class="line">        return &quot;Overridden implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p>
<p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface DefaulableFactory &#123;</span><br><span class="line">    // Interfaces now allow static methods</span><br><span class="line">    static String notRequiredTwo()&#123;</span><br><span class="line">        return &quot;default implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码片段整合了默认方法和静态方法的使用场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main( String[] args ) &#123;</span><br><span class="line">    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line">        </span><br><span class="line">    defaulable = DefaulableFactory.create( OverridableImpl::new );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Default implementation</span><br><span class="line">Overridden implementation</span><br></pre></td></tr></table></figure>
<p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</p>
<p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p>
<p>下面的例子中，Car类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  class Car &#123;</span><br><span class="line">    public static Car create( final Supplier&lt; Car &gt; supplier ) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;              </span><br><span class="line">        </span><br><span class="line">    public static void collide( final Car car ) &#123;</span><br><span class="line">        System.out.println( &quot;Collided &quot; + car.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    public void repair() &#123;   </span><br><span class="line">        System.out.println( &quot;Repaired &quot; + this.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    public void follow( final Car another ) &#123;</span><br><span class="line">        System.out.println( &quot;Following the &quot; + another.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种方法引用的类型是构造器引用，语法是<code>Class::new</code>，或者更一般的形式：<code>Class&lt;T&gt;::new</code>。注意：这个构造器没有参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final Car car = Car.create( Car::new );</span><br><span class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure>
<p>第二种方法引用的类型是静态方法引用，语法是<code>Class::static_method</code>。注意：这个方法接受一个Car类型的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>
<p>第三种方法引用的类型是某个类的成员方法的引用，语法是<code>Class::method</code>，注意，这个方法没有定义入参：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>
<p>第四种方法引用的类型是某个实例对象的成员方法的引用，语法是<code>instance::method</code>。注意：这个方法接受一个Car类型的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final Car police = Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>
<p>运行上述例子，可以在控制台看到如下输出（Car实例可能不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</span><br><span class="line">Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</span><br><span class="line">Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</span><br></pre></td></tr></table></figure>
<p>如果想了解和学习更详细的内容，可以参考官方文档</p>
<h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p>
<p>在Java 8中使用<code>@Repeatable</code>注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.repeatable.annotations;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Repeatable;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">public class RepeatingAnnotations &#123;</span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    public @interface Filters &#123;</span><br><span class="line">        Filter[] value();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    @Repeatable( Filters.class )</span><br><span class="line">    public @interface Filter &#123;</span><br><span class="line">        String value();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    @Filter( &quot;filter1&quot; )</span><br><span class="line">    @Filter( &quot;filter2&quot; )</span><br><span class="line">    public interface Filterable &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123;</span><br><span class="line">            System.out.println( filter.value() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所见，这里的Filter类使用<code>@Repeatable(Filters.class)</code>注解修饰，而Filters是存放Filter注解的容器，编译器尽量对开发者屏蔽这些细节。这样，Filterable接口可以用两个Filter注解注释（这里并没有提到任何关于Filters的信息）。</p>
<p>另外，反射API提供了一个新的方法：<code>getAnnotationsByType()</code>，可以返回某个类型的重复注解，例如<code>Filterable.class.getAnnoation(Filters.class)</code>将返回两个Filter实例，输出到控制台的内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter1</span><br><span class="line">filter2</span><br></pre></td></tr></table></figure>
<p>如果你希望了解更多内容，可以参考官方文档。</p>
<h2 id="更好的类型推断"><a href="#更好的类型推断" class="headerlink" title="更好的类型推断"></a>更好的类型推断</h2><p>Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.type.inference;</span><br><span class="line"></span><br><span class="line">public class Value&lt; T &gt; &#123;</span><br><span class="line">    public static&lt; T &gt; T defaultValue() &#123; </span><br><span class="line">        return null; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T getOrDefault( T value, T defaultValue ) &#123;</span><br><span class="line">        return ( value != null ) ? value : defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列代码是<code>Value&lt;String&gt;</code>类型的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.type.inference;</span><br><span class="line"></span><br><span class="line">public class TypeInference &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Value&lt; String &gt; value = new Value&lt;&gt;();</span><br><span class="line">        value.getOrDefault( &quot;22&quot;, Value.defaultValue() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数<code>Value.defaultValue()</code>的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用<code>Value.&lt;String&gt;defaultValue()</code>。</p>
<h2 id="拓宽注解的应用场景"><a href="#拓宽注解的应用场景" class="headerlink" title="拓宽注解的应用场景"></a>拓宽注解的应用场景</h2><p>Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.annotations;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line"></span><br><span class="line">public class Annotations &#123;</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    @Target( &#123; ElementType.TYPE_USE, ElementType.TYPE_PARAMETER &#125; )</span><br><span class="line">    public @interface NonEmpty &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    public static class Holder&lt; @NonEmpty T &gt; extends @NonEmpty Object &#123;</span><br><span class="line">        public void method() throws @NonEmpty Exception &#123;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    @SuppressWarnings( &quot;unused&quot; )</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Holder&lt; String &gt; holder = new @NonEmpty Holder&lt; String &gt;();       </span><br><span class="line">        @NonEmpty Collection&lt; @NonEmpty String &gt; strings = new ArrayList&lt;&gt;();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ElementType.TYPE_USER和ElementType.TYPE_PARAMETER</code>是Java 8新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。</p>
<h1 id="Java编译器的新特性"><a href="#Java编译器的新特性" class="headerlink" title="Java编译器的新特性"></a>Java编译器的新特性</h1><h2 id="参数名称"><a href="#参数名称" class="headerlink" title="参数名称"></a>参数名称</h2><p>为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如<code>Paranamer liberary</code>。Java 8终于将这个特性规范化，在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.parameter.names;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line">public class ParameterNames &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Method method = ParameterNames.class.getMethod( &quot;main&quot;, String[].class );</span><br><span class="line">        for( final Parameter parameter: method.getParameters() ) &#123;</span><br><span class="line">            System.out.println( &quot;Parameter: &quot; + parameter.getName() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java 8中这个特性是默认关闭的，因此如果不带<code>parameters</code>参数编译上述代码并运行，则会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameter: arg0</span><br></pre></td></tr></table></figure>
<p>如果带<code>parameters</code>参数，则会输出如下结果（正确的结果）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameter: args</span><br></pre></td></tr></table></figure>
<p>如果你使用Maven进行项目管理，则可以在<code>maven-compiler-plugin</code>编译器的配置项中配置<code>parameters</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;compilerArgument&gt;-parameters&lt;/compilerArgument&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Java官方库的新特性"><a href="#Java官方库的新特性" class="headerlink" title="Java官方库的新特性"></a>Java官方库的新特性</h1><p>Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。</p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了<code>Optionals</code>类来解决<code>NullPointerException</code>，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将<code>Optional</code>加入了官方库。</p>
<p><code>Optional</code>仅仅是一个容器：存放T类型的值或者<code>null</code>。它提供了一些有用的接口来避免显式的<code>null</code>检查，可以参考Java 8官方文档了解更多细节。</p>
<p>接下来看一点使用<code>Optional</code>的例子：可能为空的值或者某个类型的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt; String &gt; fullName = Optional.ofNullable( null );</span><br><span class="line">System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );        </span><br><span class="line">System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) ); </span><br><span class="line">System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</span><br></pre></td></tr></table></figure>
<p>如果Optional实例持有一个非空值，则<code>isPresent()</code>方法返回<code>true</code>，否则返回<code>false</code>；<code>orElseGet()</code>方法，<code>Optional</code>实例持有<code>null</code>，则可以接受一个lambda表达式生成的默认值；<code>map()</code>方法可以将现有的<code>Opetional</code>实例的值转换成新的值；<code>orElse()</code>方法与<code>orElseGet()</code>方法类似，但是在持有<code>null</code>的时候返回传入的默认值。</p>
<p>上述代码的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Full Name is set? false</span><br><span class="line">Full Name: [none]</span><br><span class="line">Hey Stranger!</span><br></pre></td></tr></table></figure>
<p>再看下另一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt; String &gt; firstName = Optional.of( &quot;Tom&quot; );</span><br><span class="line">System.out.println( &quot;First Name is set? &quot; + firstName.isPresent() );        </span><br><span class="line">System.out.println( &quot;First Name: &quot; + firstName.orElseGet( () -&gt; &quot;[none]&quot; ) ); </span><br><span class="line">System.out.println( firstName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
<p>这个例子的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First Name is set? true</span><br><span class="line">First Name: Tom</span><br><span class="line">Hey Tom!</span><br></pre></td></tr></table></figure>
<p>如果想了解更多的细节，请参考官方文档。</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>新增的<code>Stream API（java.util.stream）</code>将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p>
<p>Stream API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Streams  &#123;</span><br><span class="line">    private enum Status &#123;</span><br><span class="line">        OPEN, CLOSED</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    private static final class Task &#123;</span><br><span class="line">        private final Status status;</span><br><span class="line">        private final Integer points;</span><br><span class="line"></span><br><span class="line">        Task( final Status status, final Integer points ) &#123;</span><br><span class="line">            this.status = status;</span><br><span class="line">            this.points = points;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Integer getPoints() &#123;</span><br><span class="line">            return points;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Status getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return String.format( &quot;[%s, %d]&quot;, status, points );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Task类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final Collection&lt; Task &gt; tasks = Arrays.asList(</span><br><span class="line">    new Task( Status.OPEN, 5 ),</span><br><span class="line">    new Task( Status.OPEN, 13 ),</span><br><span class="line">    new Task( Status.CLOSED, 8 ) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>首先看一个问题：在这个task集合中一共有多少个OPEN状态的点？在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Calculate total points of all active tasks using sum()</span><br><span class="line">final long totalPointsOfOpenTasks = tasks</span><br><span class="line">    .stream()</span><br><span class="line">    .filter( task -&gt; task.getStatus() == Status.OPEN )</span><br><span class="line">    .mapToInt( Task::getPoints )</span><br><span class="line">    .sum();</span><br><span class="line">        </span><br><span class="line">System.out.println( &quot;Total points: &quot; + totalPointsOfOpenTasks );</span><br></pre></td></tr></table></figure>
<p>运行这个方法的控制台输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total points: 18</span><br></pre></td></tr></table></figure>
<p>这里有很多知识点值得说。首先，tasks集合被转换成steam表示；其次，在steam上的filter操作会过滤掉所有CLOSED的task；第三，mapToInt操作基于每个task实例的Task::getPoints方法将task流转换成Integer集合；最后，通过sum方法计算总和，得出最后的结果。</p>
<p>在学习下一个例子之前，还需要记住一些steams（点此更多细节）的知识点。Steam之上的操作可分为中间操作和晚期操作。</p>
<p>中间操作会返回一个新的steam——执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。</p>
<p>晚期操作（例如forEach或者sum），会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对steam进行遍历。</p>
<p>steam的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有任务的点数之和：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Calculate total points of all tasks</span><br><span class="line">final double totalPoints = tasks</span><br><span class="line">   .stream()</span><br><span class="line">   .parallel()</span><br><span class="line">   .map( task -&gt; task.getPoints() ) // or map( Task::getPoints ) </span><br><span class="line">   .reduce( 0, Integer::sum );</span><br><span class="line">    </span><br><span class="line">System.out.println( &quot;Total points (all tasks): &quot; + totalPoints );</span><br></pre></td></tr></table></figure>
<p>这里我们使用parallel方法并行处理所有的task，并使用reduce方法计算最终的结果。控制台输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total points（all tasks）: 26.0</span><br></pre></td></tr></table></figure>
<p>对于一个集合，经常需要根据某些条件对其中的元素分组。利用steam提供的API可以很快完成这类任务，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Group tasks by their status</span><br><span class="line">final Map&lt; Status, List&lt; Task &gt; &gt; map = tasks</span><br><span class="line">    .stream()</span><br><span class="line">    .collect( Collectors.groupingBy( Task::getStatus ) );</span><br><span class="line">System.out.println( map );</span><br></pre></td></tr></table></figure>
<p>控制台的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Calculate the weight of each tasks (as percent of total points) </span><br><span class="line">final Collection&lt; String &gt; result = tasks</span><br><span class="line">    .stream()                                        // Stream&lt; String &gt;</span><br><span class="line">    .mapToInt( Task::getPoints )                     // IntStream</span><br><span class="line">    .asLongStream()                                  // LongStream</span><br><span class="line">    .mapToDouble( points -&gt; points / totalPoints )   // DoubleStream</span><br><span class="line">    .boxed()                                         // Stream&lt; Double &gt;</span><br><span class="line">    .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) // LongStream</span><br><span class="line">    .mapToObj( percentage -&gt; percentage + &quot;%&quot; )      // Stream&lt; String&gt; </span><br><span class="line">    .collect( Collectors.toList() );                 // List&lt; String &gt; </span><br><span class="line">        </span><br><span class="line">System.out.println( result );</span><br></pre></td></tr></table></figure>
<p>控制台输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[19%, 50%, 30%]</span><br></pre></td></tr></table></figure>
<p>最后，正如之前所说，Steam API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行得读取数据）可以受益于steam处理，这里有一个小例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final Path path = new File( filename ).toPath();</span><br><span class="line">try( Stream&lt; String &gt; lines = Files.lines( path, StandardCharsets.UTF_8 ) ) &#123;</span><br><span class="line">    lines.onClose( () -&gt; System.out.println(&quot;Done!&quot;) ).forEach( System.out::println );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stream的方法<code>onClose</code> 返回一个等价的有额外句柄的Stream，当<code>Stream的close（）</code>方法被调用的时候这个句柄会被执行。Stream API、Lambda表达式还有接口默认方法和静态方法支持的方法引用，是Java 8对软件开发的现代范式的响应。</p>
<h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date/Time API(JSR 310)"></a>Date/Time API(JSR 310)</h2><p>Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。<code>java.util.Date</code>和后来的<code>java.util.Calendar</code>一直没有解决这个问题（甚至令开发者更加迷茫）。</p>
<p>因为上面这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从<code>java.util.Calendar</code>吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p>
<p>我们接下来看看java.time包中的关键类和各自的使用例子。首先，Clock类使用时区来返回当前的纳秒时间和日期。Clock可以替代<code>System.currentTimeMillis()</code>和<code>TimeZone.getDefault()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the system clock as UTC offset </span><br><span class="line">final Clock clock = Clock.systemUTC();</span><br><span class="line">System.out.println( clock.instant() );</span><br><span class="line">System.out.println( clock.millis() );</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12T15:19:29.282Z</span><br><span class="line">1397315969360</span><br></pre></td></tr></table></figure>
<p>第二，关注下<code>LocalDate</code>和<code>LocalTime</code>类。LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the local date and local time</span><br><span class="line">final LocalDate date = LocalDate.now();</span><br><span class="line">final LocalDate dateFromClock = LocalDate.now( clock );</span><br><span class="line">        </span><br><span class="line">System.out.println( date );</span><br><span class="line">System.out.println( dateFromClock );</span><br><span class="line">        </span><br><span class="line">// Get the local date and local time</span><br><span class="line">final LocalTime time = LocalTime.now();</span><br><span class="line">final LocalTime timeFromClock = LocalTime.now( clock );</span><br><span class="line">        </span><br><span class="line">System.out.println( time );</span><br><span class="line">System.out.println( timeFromClock );</span><br></pre></td></tr></table></figure>
<p>上述例子的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12</span><br><span class="line">2014-04-12</span><br><span class="line">11:25:54.568</span><br><span class="line">15:25:54.568</span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>类包含了<code>LocalDate</code>和<code>LocalTime</code>的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些关于<code>LocalDate</code>和<code>LocalTime</code>的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the local date/time</span><br><span class="line">final LocalDateTime datetime = LocalDateTime.now();</span><br><span class="line">final LocalDateTime datetimeFromClock = LocalDateTime.now( clock );</span><br><span class="line">        </span><br><span class="line">System.out.println( datetime );</span><br><span class="line">System.out.println( datetimeFromClock );</span><br></pre></td></tr></table></figure>
<p>上述这个例子的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12T11:37:52.309</span><br><span class="line">2014-04-12T15:37:52.309</span><br></pre></td></tr></table></figure>
<p>如果你需要特定时区的data/time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the zoned date/time</span><br><span class="line">final ZonedDateTime zonedDatetime = ZonedDateTime.now();</span><br><span class="line">final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );</span><br><span class="line">final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( &quot;America/Los_Angeles&quot; ) );</span><br><span class="line">        </span><br><span class="line">System.out.println( zonedDatetime );</span><br><span class="line">System.out.println( zonedDatetimeFromClock );</span><br><span class="line">System.out.println( zonedDatetimeFromZone );</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014-04-12T11:47:01.017-04:00[America/New_York]</span><br><span class="line">2014-04-12T15:47:01.017Z</span><br><span class="line">2014-04-12T08:47:01.017-07:00[America/Los_Angeles]</span><br></pre></td></tr></table></figure>
<p>最后看下Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get duration between two dates</span><br><span class="line">final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</span><br><span class="line">final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );</span><br><span class="line"></span><br><span class="line">final Duration duration = Duration.between( from, to );</span><br><span class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</span><br><span class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</span><br></pre></td></tr></table></figure>
<p>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Duration in days: 365</span><br><span class="line">Duration in hours: 8783</span><br></pre></td></tr></table></figure>
<p>对于Java 8的新日期时间的总体印象还是比较积极的，一部分是因为Joda-Time的积极影响，另一部分是因为官方终于听取了开发人员的需求。如果希望了解更多细节，可以参考官方文档。</p>
<h3 id="LocalDateTime常用举例"><a href="#LocalDateTime常用举例" class="headerlink" title="LocalDateTime常用举例"></a>LocalDateTime常用举例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDatetime = LocalDateTime.of(LocalDate.now(), LocalTime.of(11, 0);// 获取当天某一时刻</span><br><span class="line">LocalDateTime today_start = LocalDateTime.of(LocalDate.now(), LocalTime.MIN);//当天零点</span><br></pre></td></tr></table></figure>
<h3 id="日期类型之间的转换"><a href="#日期类型之间的转换" class="headerlink" title="日期类型之间的转换"></a>日期类型之间的转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Instant instant = LocalDateTime.of(LocalDate.now(), LocalTime.of(11, 0)).atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date =  Date.from(instant);//传入instant即可</span><br></pre></td></tr></table></figure>

<h2 id="Nashorn-JavaScript引擎"><a href="#Nashorn-JavaScript引擎" class="headerlink" title="Nashorn JavaScript引擎"></a>Nashorn JavaScript引擎</h2><p>Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是<code>javax.script.ScriptEngine</code>的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScriptEngineManager manager = new ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );</span><br><span class="line">        </span><br><span class="line">System.out.println( engine.getClass().getName() );</span><br><span class="line">System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; ) );</span><br></pre></td></tr></table></figure>

<p>这个代码的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdk.nashorn.api.scripting.NashornScriptEngine</span><br><span class="line">Result: 2</span><br></pre></td></tr></table></figure>

<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.base64;</span><br><span class="line"></span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Base64s &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final String text = &quot;Base64 finally in Java 8!&quot;;</span><br><span class="line">        </span><br><span class="line">        final String encoded = Base64</span><br><span class="line">            .getEncoder()</span><br><span class="line">            .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</span><br><span class="line">        System.out.println( encoded );</span><br><span class="line">        </span><br><span class="line">        final String decoded = new String( </span><br><span class="line">            Base64.getDecoder().decode( encoded ),</span><br><span class="line">            StandardCharsets.UTF_8 );</span><br><span class="line">        System.out.println( decoded );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==</span><br><span class="line">Base64 finally in Java 8!</span><br></pre></td></tr></table></figure>
<p>新的Base64API也支持URL和MINE的编码解码。<br><code>(Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder())</code>。</p>
<p>4.6 并行数组<br>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是<code>parallelSort()</code>，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.parallel.arrays;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">public class ParallelArrays &#123;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">        long[] arrayOfLong = new long [ 20000 ];        </span><br><span class="line">        </span><br><span class="line">        Arrays.parallelSetAll( arrayOfLong, </span><br><span class="line">            index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );</span><br><span class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach( </span><br><span class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        Arrays.parallelSort( arrayOfLong );     </span><br><span class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach( </span><br><span class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述这些代码使用<code>parallelSetAll()</code>方法生成20000个随机数，然后使用<code>parallelSort()</code>方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 </span><br><span class="line">Sorted: 39 220 263 268 325 607 655 678 723 793</span><br></pre></td></tr></table></figure>
<h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>基于新增的lambda表达式和steam特性，为Java 8中为<code>java.util.concurrent.ConcurrentHashMap</code>类添加了新的方法来支持聚焦操作；另外，也为<code>java.util.concurrentForkJoinPool</code>类添加了新的方法来支持通用线程池操作（更多内容可以参考我们的并发编程课程）。</p>
<p>Java 8还添加了新的<code>java.util.concurrent.locks.StampedLock</code>类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是<code>java.util.concurrent.locks.ReadWriteLock</code>的替代者）。</p>
<p>在<code>java.util.concurrent.atomic</code>包中也新增了不少工具类，列举如下：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h1 id="新的Java工具"><a href="#新的Java工具" class="headerlink" title="新的Java工具"></a>新的Java工具</h1><p>Java 8提供了一些新的命令行工具，这部分会讲解一些对开发者最有用的工具。</p>
<h2 id="Nashorn引擎：jjs"><a href="#Nashorn引擎：jjs" class="headerlink" title="Nashorn引擎：jjs"></a>Nashorn引擎：jjs</h2><p>jjs是一个基于标准Nashorn引擎的命令行工具，可以接受js源码并执行。例如，我们写一个func.js文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f() &#123; </span><br><span class="line">     return 1; </span><br><span class="line">&#125;; </span><br><span class="line">print( f() + 1 );</span><br></pre></td></tr></table></figure>
<p>可以在命令行中执行这个命令：<code>jjs func.js</code>，控制台输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>如果需要了解细节，可以参考官方文档。</p>
<h2 id="类依赖分析器：jdeps"><a href="#类依赖分析器：jdeps" class="headerlink" title="类依赖分析器：jdeps"></a>类依赖分析器：jdeps</h2><p>jdeps是一个相当棒的命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以.class文件、目录或者Jar文件为输入，然后会把依赖关系输出到控制台。</p>
<p>我们可以利用jedps分析下Spring Framework库，为了让结果少一点，仅仅分析一个JAR文件：<code>org.springframework.core-3.0.5.RELEASE.jar</code>。</p>
<p><code>jdeps org.springframework.core-3.0.5.RELEASE.jar</code><br>这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在classpath上找不到依赖，则显示”not found”.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.core-3.0.5.RELEASE.jar -&gt; C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar</span><br><span class="line">   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)</span><br><span class="line">      -&gt; java.io                                            </span><br><span class="line">      -&gt; java.lang                                          </span><br><span class="line">      -&gt; java.lang.annotation                               </span><br><span class="line">      -&gt; java.lang.ref                                      </span><br><span class="line">      -&gt; java.lang.reflect                                  </span><br><span class="line">      -&gt; java.util                                          </span><br><span class="line">      -&gt; java.util.concurrent                               </span><br><span class="line">      -&gt; org.apache.commons.logging                         not found</span><br><span class="line">      -&gt; org.springframework.asm                            not found</span><br><span class="line">      -&gt; org.springframework.asm.commons                    not found</span><br><span class="line">   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)</span><br><span class="line">      -&gt; java.lang                                          </span><br><span class="line">      -&gt; java.lang.annotation                               </span><br><span class="line">      -&gt; java.lang.reflect                                  </span><br><span class="line">      -&gt; java.util</span><br></pre></td></tr></table></figure>
<p>更多的细节可以参考官方文档。</p>
<h1 id="JVM的新特性"><a href="#JVM的新特性" class="headerlink" title="JVM的新特性"></a>JVM的新特性</h1><p>使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>
<h1 id="常用举例"><a href="#常用举例" class="headerlink" title="常用举例"></a>常用举例</h1><h2 id="List对象多条件排序"><a href="#List对象多条件排序" class="headerlink" title="List对象多条件排序"></a>List对象多条件排序</h2><p>一个List 先按照名字的拼音排序，然后按照年龄排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Person&gt; persons = getPersons();</span><br><span class="line">        </span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        // 方法一：方法引用方式</span><br><span class="line">//        List&lt;Person&gt; result = persons.stream().sorted(Comparator.comparing(Person::getNamePinyin).thenComparing(Person::getAge)).collect(Collectors.toList());</span><br><span class="line">        List&lt;Person&gt; result = persons.stream()</span><br><span class="line">                .sorted(Comparator.comparing((Person p) -&gt; p.getNamePinyin())</span><br><span class="line">                        .thenComparing((Person p) -&gt; p.getAge()).collect(Collectors.toList());</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;duration time:&quot; + (end-start) + &quot;ms&quot;);</span><br><span class="line">        for(Person p: result) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static List&lt;Person&gt; getPersons() &#123;</span><br><span class="line">        List&lt;Person&gt; persons = new ArrayList&lt;&gt;();</span><br><span class="line">        persons.add(new Person(&quot;中国&quot;, 24));</span><br><span class="line">        persons.add(new Person(&quot;中国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;中国&quot;, 78));</span><br><span class="line">        persons.add(new Person(&quot;美国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;泰国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;韩国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;日本&quot;, 23));</span><br><span class="line">        return persons;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="flatMap-用法举例"><a href="#flatMap-用法举例" class="headerlink" title="flatMap 用法举例"></a>flatMap 用法举例</h2><h3 id="将两个List转换为一个Stream"><a href="#将两个List转换为一个Stream" class="headerlink" title="将两个List转换为一个Stream"></a>将两个List<T>转换为一个Stream<T></h3><p>e.g. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream.of(requestTaskVo.getEverydayTasks(),requestTaskVo.getNoviceTasks()).flatMap(Collection::stream).forEach(appTask -&gt; checkTaskState(userId,appTask));</span><br></pre></td></tr></table></figure>
<h3 id="将两层list转换为一个Stream"><a href="#将两层list转换为一个Stream" class="headerlink" title="将两层list转换为一个Stream"></a>将两层list转换为一个Stream</h3><p>e.g.<br>有一个List<A> aList，A 中有成员变量 List<B> bList，要将aList中的所有B提取出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aList.stream().flatMap(a -&gt; a.getBList().stream())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized和ReentrantLock的区别</title>
    <url>/p/49153.html</url>
    <content><![CDATA[<p>🔐 在 Java 中，常用的锁有两种：synchronized（内置锁）和 ReentrantLock（可重入锁，re+entrant）。</p>
<span id="more"></span>
<p>二者的功效都是相同的，但又有很多不同点，所以我们今天就来聊聊。</p>
<h2 id="区别1：用法不同"><a href="#区别1：用法不同" class="headerlink" title="区别1：用法不同"></a>区别1：用法不同</h2><p><code>synchronized</code> 可用来修饰普通方法、静态方法和代码块，而 <code>ReentrantLock</code> 只能用在代码块上。</p>
<h3 id="synchronized-基础使用"><a href="#synchronized-基础使用" class="headerlink" title="synchronized 基础使用"></a><code>synchronized</code> 基础使用</h3><p>使用<code>synchronized</code>修饰代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">    // 加锁代码</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-基础使用"><a href="#ReentrantLock-基础使用" class="headerlink" title="ReentrantLock 基础使用"></a>ReentrantLock 基础使用</h3><p><code>ReentrantLock</code> 在使用之前需要先创建 <code>ReentrantLock</code> 对象，然后使用 <code>lock</code> 方法进行加锁，使用完之后再调用 <code>unlock</code> 方法释放锁，具体使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LockExample &#123;</span><br><span class="line">    // 创建锁对象</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        // 加锁操作</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区别2：获取锁和释放锁方式不同"><a href="#区别2：获取锁和释放锁方式不同" class="headerlink" title="区别2：获取锁和释放锁方式不同"></a>区别2：获取锁和释放锁方式不同</h2><p><code>synchronized</code> 会自动加锁和释放锁，当进入 <code>synchronized</code> 修饰的代码块之后会自动加锁，当离开 <code>synchronized</code> 的代码段之后会自动释放锁，如下图所示：</p>
<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230626144848.png"
                      
                >

<p>而 ReentrantLock 需要手动加锁和释放锁，如下图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230626145001.png"
                     
                ></p>
<p>PS：在使用<code>ReentrantLock</code> 时要特别小心，<code>unlock</code>释放锁的操作一定要放在<code>finally</code>中，否者有可能会出现锁一直被占用，从而导致其他线程一直阻塞的问题。</p>
<h2 id="区别3：锁类型不同"><a href="#区别3：锁类型不同" class="headerlink" title="区别3：锁类型不同"></a>区别3：锁类型不同</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p>
<p>优点：所有的线程都能得到资源，不会饿死在队列中。<br>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<p>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。<br>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p>
<p><code>synchronized</code> 属于非公平锁，而<code>ReentrantLock</code>既可以是公平锁也可以是非公平锁。默认情况下<code>ReentrantLock</code>为非公平锁，这点查看源码可知：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230626150546.png"
                      
                ><br>使用new ReentrantLock(true)可以创建公平锁，查看源码可知：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230626151001.png"
                      
                ></p>
<h2 id="区别4：响应中断不同"><a href="#区别4：响应中断不同" class="headerlink" title="区别4：响应中断不同"></a>区别4：响应中断不同</h2><p><code>ReentrantLock</code> 可以使用<code>lockInterruptibly</code>获取锁并响应中断指令，而<code>synchronized</code>不能响应中断，也就是如果发生了死锁，使用 <code>synchronized</code>会一直等待下去，而使用<code>ReentrantLock</code>可以响应中断并释放锁，从而解决死锁的问题，比如以下<code>ReentrantLock</code>响应中断的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 线程 1：先获取 lockA 再获取 lockB</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 先获取 LockA</span></span><br><span class="line">                lockA.lockInterruptibly();</span><br><span class="line">                <span class="comment">// 休眠 10 毫秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// 获取 LockB</span></span><br><span class="line">                lockB.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应中断指令&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lockA.unlock();</span><br><span class="line">                lockB.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 1 执行完成。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程 2：先获取 lockB 再获取 lockA</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 先获取 LockB</span></span><br><span class="line">                lockB.lockInterruptibly();</span><br><span class="line">                <span class="comment">// 休眠 10 毫秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// 获取 LockA</span></span><br><span class="line">                lockA.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;响应中断指令&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lockB.unlock();</span><br><span class="line">                lockA.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 2 执行完成。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 线程1：执行中断</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果如下所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230626153851.png"
                      
                ></p>
<h3 id="区别5：底层实现不同"><a href="#区别5：底层实现不同" class="headerlink" title="区别5：底层实现不同"></a>区别5：底层实现不同</h3><p><code>synchronized</code> 是 JVM 层面通过监视器（Monitor）实现的，而 <code>ReentrantLock</code> 是通过 <code>AQS（AbstractQueuedSynchronizer）</code>程序级别的 API 实现。<code>synchronized</code> 通过监视器实现，可通过观察编译后的字节码得出结论，如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized (&quot;锁&quot;)&#123;</span><br><span class="line">            System.out.println(&quot;这里很安全&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230626160911.png"
                       
                >

<p>其中 <code>monitorenter</code> 表示进入监视器，相当于加锁操作，而 <code>monitorexit</code> 表示退出监视器，相当于释放锁的操作。<br><code>ReentrantLock</code> 是通过 AQS 实现，可通过观察 <code>ReentrantLock</code> 的源码得出结论，核心实现源码如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230626161523.png"
                       
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中提供的可重入锁，二者的主要区别有以下 5 个：</p>
<ul>
<li>用法不同：synchronized 可以用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用于代码块。</li>
<li>获取锁和释放锁的机制不同：synchronized 是自动加锁和释放锁的，而 ReentrantLock 需要手动加锁和释放锁。</li>
<li>锁类型不同：synchronized 是非公平锁，而 ReentrantLock 默认为非公平锁，也可以手动指定为公平锁。</li>
<li>响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。</li>
<li>底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。</li>
</ul>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字的作用</title>
    <url>/p/7735.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Java中，关键字 <code>volatile</code> 用来修饰变量，它的作用是保证多线程环境下该变量的<strong>可见性</strong>和<strong>顺序性</strong>。</p>
<p>当一个变量被声明为 <code>volatile</code> 时，在每次访问该变量时，都会直接从主内存中读取最新的值，并且每次修改该变量后，都会立即将修改后的值刷新回主内存，而不是仅仅保存在当前线程的工作内存中。这样可以确保不同线程之间对于该变量的读写操作是可见的。</p>
<p>在多线程环境中，如果一个共享变量不使用 <code>volatile</code> 关键字进行修饰，那么可能会出现某个线程对该变量的修改对其他线程不可见的情况，造成数据不一致的问题。而使用 <code>volatile</code> 关键字能够强制所有线程都去主内存中读取变量的最新值，避免了数据不一致的情况。</p>
<p>需要注意的是，<code>volatile</code> 修饰符只能保证变量的可见性和顺序性，并不能保证原子性。如果要保证原子性操作，需要使用 <code>synchronized</code> 或者 <code>java.util.concurrent</code> 包下的原子类来进行处理。</p>
<h3 id="内存屏障（Memory-Barrier）"><a href="#内存屏障（Memory-Barrier）" class="headerlink" title="内存屏障（Memory Barrier）"></a>内存屏障（Memory Barrier）</h3><p>内存屏障（Memory Barrier），也称为内存栅栏，是一种硬件或软件机制，用于控制处理器和内存之间的数据访问顺序和可见性。</p>
<p>在多线程编程中，由于处理器和内存之间存在缓存等机制，可能导致不同线程之间的数据读写顺序与程序代码中的逻辑顺序不一致，从而引发各种并发问题，比如数据竞争、死锁等。内存屏障正是为了解决这些问题而引入的。</p>
<p>内存屏障可以分为两种类型：读屏障和写屏障。</p>
<ul>
<li>读屏障（Read Barrier）：它保证一个线程在读取某个变量的值时，能够看到其他线程对该变量所做的最新修改。读屏障之前的读操作会先于读屏障之后的读操作完成。</li>
<li>写屏障（Write Barrier）：它保证一个线程在修改某个变量的值后，将修改的结果立即刷新到主内存中，以便其他线程能够读取到最新的值。写屏障之前的写操作会先于写屏障之后的写操作完成。</li>
</ul>
<p>通过在适当的位置插入内存屏障指令，可以显式地控制内存操作的顺序和可见性，从而保证程序的正确性。</p>
<p>在Java中，使用 <code>volatile</code> 关键字和 <code>synchronized</code> 关键字也会隐式地插入内存屏障，以确保变量的可见性和顺序性。此外，Java还提供了 <code>java.util.concurrent</code> 包中的各种并发工具，如锁、原子类、倒计数器等，这些工具内部也使用了内存屏障来保证线程安全和数据一致性。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>你不得不掌握的线程池</title>
    <url>/p/46324.html</url>
    <content><![CDATA[<h2 id="线程池的类型"><a href="#线程池的类型" class="headerlink" title="线程池的类型"></a>线程池的类型</h2><p>在Java中，线程池的类型主要有以下几种：</p>
<ol>
<li><p>FixedThreadPool（固定大小线程池）：该类型的线程池固定了线程的数量，适用于一些稳定且长期执行的任务。当线程池中的线程都处于忙碌状态时，新的任务会在队列中等待执行。</p>
</li>
<li><p>CachedThreadPool（缓存线程池）：该类型的线程池会根据需要自动创建新的线程，适用于短期的异步任务。当线程池中有空闲线程时，新的任务会被立即执行；当所有线程都忙碌时，会创建新的线程来处理任务。</p>
</li>
<li><p>SingleThreadPool（单线程池）：该类型的线程池只有一个线程，适用于需要保证任务顺序执行的场景。所有的任务按照提交的顺序依次执行，如果线程因异常终止，会创建一个新线程继续执行后续任务。</p>
</li>
<li><p>ScheduledThreadPool（定时任务线程池）：该类型的线程池用于定时或延迟执行任务。可以按照特定的时间间隔或者指定的延迟时间来执行任务。</p>
</li>
</ol>
<p>除了以上几种常见的线程池类型，还可以通过ThreadPoolExcuter创建线程池，可灵活的控制核心线程数量、最大线程数量，阻塞队列以及拒绝策略，不建议使用无界队列；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建线程池</span><br><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="line">    5,  // corePoolSize 核心线程数，即线程池中始终保持活动状态的线程数量。</span><br><span class="line">    10, // maximumPoolSize 最大线程数，即线程池中允许存在的最大线程数量，当阻塞队列满的情况下，才会增加新的线程直到最大。</span><br><span class="line">    60, // keepAliveTime 线程空闲时间，当线程池中的线程数大于 corePoolSize 时，多余的空闲线程最大存活时间。</span><br><span class="line">    TimeUnit.SECONDS, // unit keepAliveTime 的时间单位。</span><br><span class="line">    new ArrayBlockingQueue&lt;&gt;(100), // workQueue 任务队列，保存等待执行的任务的阻塞队列。</span><br><span class="line">    Executors.defaultThreadFactory(), // threadFactory 线程工厂，用于创建新线程。</span><br><span class="line">    new ThreadPoolExecutor.AbortPolicy() // handler 拒绝策略，当线程池和任务队列都满了之后，新任务的处理方式。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>当线程池已满无法接受新的任务时，可以采用以下几种常见的拒绝策略：</p>
<ol>
<li>AbortPolicy（默认）：直接抛出RejectedExecutionException异常，阻止系统接受新的任务提交。</li>
<li>CallerRunsPolicy：将任务退回给调用者，由调用线程执行该任务。这样可以降低任务提交速度，但可能会影响调用线程的性能。</li>
<li>DiscardPolicy：默默地丢弃无法处理的任务，不抛出异常也不通知任务提交者。</li>
<li>DiscardOldestPolicy：丢弃最早提交的任务，并尝试重新提交当前任务。</li>
<li>自定义拒绝策略：根据业务需求自定义一个实现了RejectedExecutionHandler接口的拒绝策略。</li>
</ol>
<p>选择合适的拒绝策略需要根据具体情况和业务需求来确定。可以根据线程池的负载情况、任务优先级等因素进行综合考虑，以提供最适合的处理方式。</p>
<h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p>初始化线程池时，未添加线程任务，线程池中是不会创建任何线程，存活线程为0，工作队列为0。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231213155617.png"
                      alt="执行流程"
                ></p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器的晴雨表——top命令</title>
    <url>/p/35755.html</url>
    <content><![CDATA[<blockquote>
<p> 虽然之前一直在使用top命令，但是并没有像今天这样认真细致总结每条数据代表的含义。</p>
</blockquote>
<span id="more"></span>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Liunx系统下输入下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>日常开发中熟悉的视图再次映入眼底：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200807152926.png"
                     
                ></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>视图前五行是当前系统情况整体的统计信息区。</p>
<h3 id="统计信息区"><a href="#统计信息区" class="headerlink" title="统计信息区"></a>统计信息区</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200807152503.png"
                      alt="统计信息区"
                ></p>
<h4 id="第一行-任务队列信息"><a href="#第一行-任务队列信息" class="headerlink" title="第一行: 任务队列信息"></a>第一行: 任务队列信息</h4><p>同<code>uptime</code> 命令的执行结果相同，具体参数说明情况如下：</p>
<ul>
<li><p><strong>14:04:16</strong> — 当前系统时间</p>
</li>
<li><p><strong>up 145 days</strong>, 14:24 — 系统已经运行了145天14小时24分钟（在这期间系统没有重启过）</p>
</li>
<li><p><strong>1 user</strong> — 当前有1个用户登录系统</p>
</li>
<li><p><strong>load average: 1.15, 1.42, 1.44</strong> — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
</li>
<li><p><strong>load average</strong>数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
</li>
</ul>
<h4 id="第二行-Tasks-—-任务（进程）"><a href="#第二行-Tasks-—-任务（进程）" class="headerlink" title="第二行: Tasks — 任务（进程）"></a>第二行: Tasks — 任务（进程）</h4><p>系统现在共有447个进程，其中处于运行中的有1个，445个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有1个。</p>
<h4 id="第三行-cpu状态信息"><a href="#第三行-cpu状态信息" class="headerlink" title="第三行: cpu状态信息"></a>第三行: cpu状态信息</h4><ul>
<li>*<em>40.1%us **— 用户空间占用CPU的百分比（</em>user cpu time*）。</li>
<li><strong>9.7% sy</strong> — 内核空间占用CPU的百分比（<em>system cpu time</em>）。</li>
<li><strong>0.0% ni</strong> — 改变过优先级的进程占用CPU的百分比（<em>user nice cpu time</em>）</li>
<li><strong>48.9% id</strong> — 空闲CPU百分比（<em>idle cpu time</em>）</li>
<li><strong>0.2% wa</strong> — IO等待占用CPU的百分比（<em>io wait cpu time</em>）</li>
<li><strong>0.0% hi</strong> — 硬中断占用CPU的百分比（<em>hardware irq</em>）</li>
<li><strong>1.0% si</strong> — 软中断占用CPU的百分比（<em>software irq</em>）</li>
<li><strong>0.0% st</strong> — “窃取时间”仅与虚拟化环境相关。它表示真正的CPU对当前虚拟机不可用的时间-虚拟机管理程序从该VM“偷走”了该CPU（用于运行另一个VM，或用于其自身需求）（<em>steal time</em>）<blockquote>
<p> 备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p>
</blockquote>
</li>
</ul>
<h4 id="第四行-内存状态"><a href="#第四行-内存状态" class="headerlink" title="第四行: 内存状态"></a>第四行: 内存状态</h4><ul>
<li><p><strong>13175904+ total</strong> — 物理内存总量（130GB）</p>
</li>
<li><p><strong>52304008 free</strong> — 空闲内存总量（52GB）</p>
</li>
<li><p><strong>78647840 used</strong> — 使用中的内存总量（78GB）</p>
</li>
<li><p><strong>807188 buffer/cache</strong> — 缓存的内存量 （807M）</p>
<h4 id="第五行-swap交换分区信息"><a href="#第五行-swap交换分区信息" class="headerlink" title="第五行: swap交换分区信息"></a>第五行: swap交换分区信息</h4><blockquote>
<p> 在Linux中，内存一共分为两块：物理内存 和 交换区。物理内存是真正的内存，而内存资源毕竟有限，因此当物理内存不够的时候，根据LRU置换算法，那些很长时间没被使用的数据将会被存入交换区。交换区其实是硬盘，并非内存。当交换区存在数据时说明物理内存不够了。</p>
</blockquote>
</li>
<li><p><strong>10485756 total</strong> — 交换区总量（10GB）</p>
</li>
<li><p><strong>6848920 free</strong> — 空闲交换区总量（6GB）</p>
</li>
<li><p><strong>3636836 used</strong> — 使用的交换区总量（3GB）</p>
</li>
<li><p><strong>52299332k avail Mem</strong> — 虚拟内存总量（3.6GB）</p>
</li>
</ul>
<p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。<br>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的avail Mem，按这个公式此台服务器的可用内存。<br>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>
<h3 id="进程状态监控"><a href="#进程状态监控" class="headerlink" title="进程状态监控"></a>进程状态监控</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200807164905.png"
                     
                ></p>
<ul>
<li><strong>PID</strong> — 进程id</li>
<li><strong>USER</strong> — 进程所有者</li>
<li><strong>PR</strong> — 进程优先级</li>
<li><strong>NI</strong> — nice值。负值表示高优先级，正值表示低优先级</li>
<li><strong>VIRT</strong> — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li>
<li><strong>RES</strong> — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li>
<li><strong>SHR</strong> — 共享内存大小，单位kb</li>
<li><strong>S</strong> — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li>
<li><strong>%CPU</strong> — 上次更新到现在的CPU时间占用百分比</li>
<li><strong>%MEM</strong> — 进程使用的物理内存百分比</li>
<li><strong>TIME+</strong> — 进程使用的CPU时间总计，单位1/100秒</li>
<li><strong>COMMAND</strong> — 进程名称（命令名/命令行）<h3 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h3><h4 id="多U多核CPU监控"><a href="#多U多核CPU监控" class="headerlink" title="多U多核CPU监控"></a>多U多核CPU监控</h4></li>
<li>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况。再按数字键1，就会返回到top基本视图界面。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200807172205.png"
                     
                ><br>可以看到，服务器有40个逻辑CPU，但实际上是2个物理cpu。我们通过如下命令查看物理CPU个数：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq</span><br></pre></td></tr></table></figure>
<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200807172539.png"
                     
                ><br>有几个不一样的<strong>physical id</strong>就代表有几个物理cpu。<h4 id="显示完整命令"><a href="#显示完整命令" class="headerlink" title="显示完整命令"></a>显示完整命令</h4>使用如下命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure>
即可显示命令名称和完整命令行<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>可以看出，<strong>top</strong>虽然简短（容易记住），却“神通广大”，可以帮助我们迅速掌握当前Linux系统运行状况，是一个不可多得的命令，大家日常开发中可以将其作为随身利器乘风破浪，披荆斩棘。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决SSH登录Linux长时间不操作就会自动断开的问题</title>
    <url>/p/45615.html</url>
    <content><![CDATA[<p>接个咖啡的功夫就给我断断网？</p>
<span id="more"></span>
<p>问题描述：<br>在使用SSH Secure Shell Client的过程中，经常会遇到当用SSH Secure Shell连接登录Linux时，如果几分钟没有任何操作，连接就会自动断开，提示Server responded “Connection closed.” ，必须重新登录才可以。</p>
<p>解决办法：<br>编辑修改/etc/ssh/sshd_config文件，找到下面2个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ClientAliveInterval 0</span><br><span class="line">#ClientAliveCountMax 3</span><br></pre></td></tr></table></figure>

<p>去掉前面的注释，并修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClientAliveInterval 60</span><br><span class="line">ClientAliveCountMax 3</span><br></pre></td></tr></table></figure>

<p>保存后，记得重启sshd服务，使配置生效，然后退出再登录就发现不会自动断开了。</p>
<p>[root@localhost ~]# service sshd restart<br>复制<br>参数说明：<br>ClientAliveInterval：指定了服务器端向客户端请求响应的时间间隔, 默认是0, 不发送请求；改为60秒，则60秒发送一次请求，客户端自动响应，这样就保持长连接不会自动断开了。<br>ClientAliveCountMax：指定了服务器发出请求后客户端没有响应的次数达到一定值, 就会自动断开，使用默认值3次即可，正常情况下, 客户端都会自动响应。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux centos如何安装docker</title>
    <url>/p/4169.html</url>
    <content><![CDATA[<h1 id="CentOS-Docker-安装"><a href="#CentOS-Docker-安装" class="headerlink" title="CentOS Docker 安装"></a>CentOS Docker 安装</h1><p>Docker支持以下的CentOS版本：</p>
<ul>
<li>CentOS 7 (64-bit)</li>
<li>CentOS 6.5 (64-bit) 或更高的版本<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</li>
</ul>
<h2 id="使用-yum-安装（CentOS-7下）"><a href="#使用-yum-安装（CentOS-7下）" class="headerlink" title="使用 yum 安装（CentOS 7下）"></a>使用 yum 安装（CentOS 7下）</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p>
<p>通过 <code>uname -r </code>命令查看你当前的内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM_0_9_centos ~]# uname -r</span><br><span class="line">3.10.0-514.26.2.el7.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。<br>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。<br>本文介绍 Docker CE 的安装使用。</p>
<p>移除旧的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>安装一些必要的系统工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>添加软件源信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>更新 yum 缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>安装 Docker-ce：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure>
<p>启动 Docker 后台服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>测试运行 hello-world</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@coderxm ~]# docker run hello-world</span><br></pre></td></tr></table></figure>

<p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。</p>
<h2 id="使用脚本安装-Docker"><a href="#使用脚本安装-Docker" class="headerlink" title="使用脚本安装 Docker"></a>使用脚本安装 Docker</h2><ol>
<li>使用 sudo 或 root 权限登录 Centos。</li>
<li>确保 yum 包更新到最新。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li>
<li>执行 Docker 安装脚本。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>执行这个脚本会添加 docker.repo 源并安装 Docker。</p>
<ol start="4">
<li>启动 Docker 进程。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li>验证 docker 是否安装成功并在容器中执行一个测试的镜像。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
可以看出来控制台有输出“Hello from Docker!“等字样，到此，Docker 在 CentOS 系统的安装完成。</li>
</ol>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a class="link"   href="http://hub-mirror.c.163.com./" >http://hub-mirror.c.163.com。<i class="fas fa-external-link-alt"></i></a></p>
<p>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。</p>
<p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查加速器是否生效<br>执行 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p>如果从结果中看到了如下内容，说明配置成功。<br>Registry Mirrors:<br> <a class="link"   href="https://hub-mirror.c.163.com/" >https://hub-mirror.c.163.com/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h2><h3 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。<h3 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h3>通过<code>yum</code>安装组件变得都很方便，比如compose<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install docker-compose</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="删除-Docker-CE"><a href="#删除-Docker-CE" class="headerlink" title="删除 Docker CE"></a>删除 Docker CE</h2><p>执行以下命令来删除 Docker CE：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令（持续更新）</title>
    <url>/p/c01e.html</url>
    <content><![CDATA[<h2 id="查看系统磁盘空间"><a href="#查看系统磁盘空间" class="headerlink" title="查看系统磁盘空间"></a>查看系统磁盘空间</h2><h3 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -h </span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.9G     0  7.9G   0% /dev</span><br><span class="line">tmpfs           1.6G  3.6M  1.6G   1% /run</span><br><span class="line">/dev/vda1        99G   61G   33G  65% /</span><br><span class="line">tmpfs           7.9G  2.6G  5.3G  33% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vdb1       493G   57G  411G  13% /media</span><br><span class="line">tmpfs           1.6G     0  1.6G   0% /run/user/1000</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table>
<thead>
<tr>
<th>Filesystem</th>
<th>Size</th>
<th>Used</th>
<th>Avail</th>
<th>use</th>
<th>Mounted on</th>
</tr>
</thead>
<tbody><tr>
<td>文件系统</td>
<td>分区大小</td>
<td>已使用容量</td>
<td>还可以使用容量</td>
<td>已用百分比</td>
<td>挂载点</td>
</tr>
</tbody></table>
<h3 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h3><p>*<em>“df”**可以理解为：</em>disk filesystem*，意为”磁盘文件系统”，我们就是为了查看磁盘占用情况；</p>
<p>**”-h”**我们通过<code>df --help</code>会发现，这个参数表示查询磁盘占用空间会以K，M，G为单位，提高信息的可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)</span><br></pre></td></tr></table></figure>

<h2 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h2><h3 id="推荐使用-1"><a href="#推荐使用-1" class="headerlink" title="推荐使用"></a>推荐使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure>

<p>进入到你想查看的文件夹下，运行即可</p>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">28M	.</span><br></pre></td></tr></table></figure>

<h3 id="命令解释-1"><a href="#命令解释-1" class="headerlink" title="命令解释"></a>命令解释</h3><p><strong>du</strong> 的英文原义为 <strong>disk usage</strong>，含义为显示磁盘空间的使用情况，用于查看当前目录的总大小。</p>
<p>运行<strong>du –help</strong> 查看解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s, --summarize       display only a total for each argument</span><br><span class="line">-h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)</span><br></pre></td></tr></table></figure>

<p><strong>-s</strong>表示展示总数</p>
<p><strong>-h</strong>同样是提高信息的可读性</p>
<h3 id="未完，待续……"><a href="#未完，待续……" class="headerlink" title="未完，待续……"></a>未完，待续……</h3><h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>快速优雅的在linux服务器上安装jdk8</title>
    <url>/p/5a53.html</url>
    <content><![CDATA[<blockquote>
<p>对于开发者来说，安装jdk按理说是非常简单的事，但在linux下安装着实费了我这个一直玩windows的小白不少劲。这里简单把步骤梳理下，希望能帮助像我这样的纯小白人士少踩点坑。</p>
</blockquote>
<p>这里介绍两种安装方式：</p>
<ul>
<li>yum安装（力荐）</li>
<li>从官网下载包安装</li>
</ul>
<h1 id="获得一台linux服务器"><a href="#获得一台linux服务器" class="headerlink" title="获得一台linux服务器"></a>获得一台linux服务器</h1><p>要在linux下安装jdk，首先你得先有一台linux服务器，作为小白，手头的机器肯定都是windows的，搞个虚拟机安装对我这种小白简直是折磨人；这里使用最简单的方式获得一台linux服务器，就是从阿里云或者腾讯云上租一台。镜像选择CentOS7.3 64位。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhECpn.png"
                     
                ></p>
<h1 id="yum安装jdk"><a href="#yum安装jdk" class="headerlink" title="yum安装jdk"></a>yum安装jdk</h1><p>在linux上使用yum安装是非常粗暴无脑的，但仍然有需要注意的点，不然会掉坑里。这里说一下步骤。</p>
<ul>
<li>执行命令<code>yum -y list java*</code>查看可安装java版本。执行成功后可以看见如下的结果</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhAzkQ.png"
                     
                ></p>
<ul>
<li><p>选择一个java版本进行安装，这里我们希望安装java1.8，因为我们的机器是64位的，所以选择安装<strong>java-1.8.0-openjdk-devel.x86_64</strong>。<br>这里有个地方要注意，上图中我用红框圈起来的两个java版本，要选择-devel的安装，因为这个安装的是jdk，而那个不带-devel的安装完了其实是jre。</p>
</li>
<li><p>执行命令<code>yum install -y java-1.8.0-openjdk-devel.x86_64</code>。执行完后会看见控制台刷出很多输出。<br>耐心等待至自动安装完成</p>
</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhAvTg.png"
                     
                ></p>
<ul>
<li>输入<code>java -version</code>查看已安装的jdk版本，当出现如下输出表示安装成功。</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhAj0S.png"
                     
                ></p>
<ul>
<li>你可能好奇，yum安装的jdk，被安装到哪里去了？可以执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ql java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<p>获取安装目录，你发现在<code>/usr/lib/jvm</code>目录下可以找到他们。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhAXm8.png"
                     
                ></p>
<p>至此，yum安装jdk完成。</p>
<h1 id="从官网下载包安装jdk"><a href="#从官网下载包安装jdk" class="headerlink" title="从官网下载包安装jdk"></a>从官网下载包安装jdk</h1><p>如果你不喜欢yum安装的方式，想要使用官方提供的安装包进行传统方式的安装，可以使用如下步骤。</p>
<ul>
<li>执行命令<code>useradd java</code>，新建用户java</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhEpfs.png"
                     
                ></p>
<ul>
<li><p>执行命令<code>passwd java</code>，设置java用户密码<br><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhMEFK.png"
                     
                ></p>
</li>
<li><p>进入oracle官网，java8下载页面<a class="link"   href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html%E3%80%82" >http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html。<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhESYj.png"
                     
                ></p>
<ul>
<li><p>选择<strong>Accept License Agreement</strong>，点击<strong>jdk-8u131-linux-x64.tar.gz</strong>，获取到下载链接。注意，获取到的下载链接有时效（具体有效多久不清楚，反正隔天肯定不能用），请尽快复制到linux上进行下载。</p>
</li>
<li><p>进入到<code>/home/java</code>目录下，输入wget +地址，即可开始下载<br><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhEE0U.png"
                     
                ></p>
</li>
</ul>
<ul>
<li>等待下载成功<br><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhEPlq.png"
                     
                ></li>
</ul>
<ul>
<li>查看文件，发现下载后的文件名有奇怪的后缀，重命名下载文件</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhEi60.png"
                     
                ></p>
<ul>
<li>输入命令<code>tar zxvf jdk-8u131-linux-x64.tar.gz</code>解压安装包<br>如果提示没有<code>tar</code>命令，输入<code>yum install -y tar</code>先安装tar。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhEV7F.png"
                     
                ></li>
</ul>
<ul>
<li>输入命令<code>vim /etc/profile</code>，打开环境变量配置文件<br>在文件底部输入以下信息，并保存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/home/java/jdk1.8.0_131</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export JRE_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure>

<ul>
<li>输入命令<code>source /etc/profile</code>，刷新环境变量配置文件使其立刻生效；输入<code>java -version</code>查看已安装的jdk版本</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/13/VhEAmT.png"
                     
                ></p>
<p>你要以为这就完成了，那就掉坑里了。虽然大部分时候这就够了，但还有一步操作最好做一下。建一个<code>/usr/bin/java</code>的java的超链接。<br><code>ln -s /home/java/jdk1.8.0_131/bin/java /usr/bin/java</code></p>
<p>为什么要建这个超链接，因为一些自己注册的linux服务（如springboot的jar注册的服务），默认情况下从<code>/usr/bin/java</code>路径使用java，yum安装的时候，这个超链接会自动创建，如果你自己下载包安装的话，这个超链接就需要你手动创建了。<br>至此，从官网下载包安装jdk完成。</p>
<h2 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>通过shell脚本一键安装JDK8</title>
    <url>/p/63927.html</url>
    <content><![CDATA[<blockquote>
<p>难得闲下来，总结一下了最近的脚本，本文主要是给大家介绍一下快速安装jdk的方法</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>作为一只老鸟，每次项目运行环境搭建，都需要安装JDK，配置环境变量等，做一些重复的工作。这样的事情可能对于刚接触Linux的人来说是很乐意做的，但是接触多了，总是觉得做这样的事情没有多大意义。因此，写一个自动执行的脚本势在必行，不仅可以省时省力，还可以顺带锻炼一下自己的shell脚本编程能力。</p>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>安装前我们需要准备一个安装包，拿Linux 64位举个例子，安装包也可以从官网下载。<br>链接:<a class="link"   href="https://pan.baidu.com/s/1Ps8GC8XPSsu6utW9nV3QAQ" >https://pan.baidu.com/s/1Ps8GC8XPSsu6utW9nV3QAQ<i class="fas fa-external-link-alt"></i></a><br>密码:9wfy</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">JAVA_HOME=&#x27;&#x27;</span><br><span class="line">jdkDir=/usr/local/jdk/</span><br><span class="line"> </span><br><span class="line">#校验解压JDK的文件夹</span><br><span class="line">if [ -e $jdkDir ]</span><br><span class="line">then </span><br><span class="line">	echo &quot;$jdkDir文件夹已存在,执行被迫终止!&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line">echo &quot;检查压缩包是否存在...&quot;</span><br><span class="line">if [ -f $1 ]</span><br><span class="line">then</span><br><span class="line">	mkdir $jdkDir</span><br><span class="line">	echo &quot;开始解压...&quot;</span><br><span class="line">	tar -zxvf $1 -C $jdkDir</span><br><span class="line">	for file in $jdkDir*</span><br><span class="line">	do</span><br><span class="line">		if [ -d $file ]</span><br><span class="line">		then</span><br><span class="line">			JAVA_HOME=$file</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line">	echo &quot;JAVA_HOME=$JAVA_HOME&quot;	</span><br><span class="line"> </span><br><span class="line">else</span><br><span class="line">	echo 文件不存在:$1</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line">#修改环境变量</span><br><span class="line"> </span><br><span class="line">echo &quot;export JAVA_HOME=$JAVA_HOME&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo &quot;export PATH=\$PATH:\$JAVA_HOME/bin&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo &quot;export CLASSPATH=.:\$JAVA_HOME/lib/dt.jar:\$JAVA_HOME/lib/tools.jar&quot; &gt;&gt; /etc/profile</span><br><span class="line"> </span><br><span class="line">echo &quot;jdk 安装配置完成&quot;</span><br><span class="line">echo `java -version`</span><br></pre></td></tr></table></figure>

<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>上面脚本可以用<code>vi</code>保存脚本文件<code>installj8.sh</code>，然后执行如下命令，参数只需传递一个，就是你要解压的jdk压缩包的存放路径:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh ./installj8.sh ./jdk-8u281-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>


<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>脚本正常执行后，我们可以执行以下命令进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>如果提示没有该命令，可以执行如下命令，刷新配置后再进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>一键安装python3</title>
    <url>/p/62773.html</url>
    <content><![CDATA[<blockquote>
<p> 本文主要介绍python3的安装，通过python3.6.4源码安装，并且兼容python2， 实现python2与python3共存。文中包括python3的安装介绍以及安装脚本。</p>
</blockquote>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>因为红帽系列默认没有安装python3，而debian早就已经自带了python3。在centos服务器上安装python3，因此写了一个一键安装脚本供大家参考。</p>
<span id="more"></span>
<h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><p>一键安装python3脚本，脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y wget epel-release xz gcc zlib zlib-devel openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel</span><br><span class="line">if [[ ! -s /usr/bin/python3 ]]; then</span><br><span class="line">        wget http://file.aionlife.xyz/source/download?id=5b9e7227dc72d90ebb47023a -O Python-3.6.4.tar.xz  #https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz(这个地址国内下载比较慢，所以这里换成另一个地址 )</span><br><span class="line">        tar -Jxvf Python-3.6.4.tar.xz</span><br><span class="line">        cd Python-3.6.4</span><br><span class="line">        ./configure --prefix=/usr/python3.6</span><br><span class="line">        make&amp;&amp;make install</span><br><span class="line">        ln -s /usr/python3.6/bin/python3 /usr/bin/python3</span><br><span class="line">        mkdir ~/.pip</span><br><span class="line">        echo -e &quot;[global]\nindex-url = http://mirrors.aliyun.com/pypi/simple/\n[install]\ntrusted-host = mirrors.aliyun.com&quot; &gt; ~/.pip/pip.conf</span><br><span class="line">        ln -s /usr/python3.6/bin/pip3 /usr/bin/pip3  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<blockquote>
<p> tips: 也可以根据所安装的版本更换安装包的下载链接，注意脚本中的文件名也要同步修改。</p>
</blockquote>
<p>上面脚本可以用<code>vi</code>保存脚本文件<code>installpy3.sh</code>，然后执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh installpy3.sh</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>经过大约几分钟的等待，脚本执行安装完毕，我们就可以分别执行<code>python3</code>和<code>pip3</code>进行验证，如出现命令提示即表示安装成功。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="提示ModuleNotFoundError-No-module-named-‘distutils-cmd’"><a href="#提示ModuleNotFoundError-No-module-named-‘distutils-cmd’" class="headerlink" title="提示ModuleNotFoundError: No module named ‘distutils.cmd’"></a>提示ModuleNotFoundError: No module named ‘distutils.cmd’</h3><p>需要安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install python3-distutils</span><br></pre></td></tr></table></figure>


<h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h2><h3 id="仓库注册"><a href="#仓库注册" class="headerlink" title="仓库注册"></a>仓库注册</h3><p>Centos-release-scl软件集的使用<br>scl：(Software Collections)软件集，是为了给RHEL/CentOS用户提供一种以方便，安全地安装、使用应用程序和运行时环境的多个版本方式，同时避免把系统搞乱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y centos-release-scl  </span><br></pre></td></tr></table></figure>

<h3 id="搜索python版本"><a href="#搜索python版本" class="headerlink" title="搜索python版本"></a>搜索python版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum search python</span><br></pre></td></tr></table></figure>
<p>可以看到最新的是3.8版本</p>
<h3 id="安装python3-8"><a href="#安装python3-8" class="headerlink" title="安装python3.8"></a>安装python3.8</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y rh-python38</span><br></pre></td></tr></table></figure>

<h3 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /opt/rh/rh-python38/root/usr/bin/python3 /usr/bin/python3</span><br><span class="line"> </span><br><span class="line">ln -s /opt/rh/rh-python38/root/usr/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>
<h3 id="确认版本"><a href="#确认版本" class="headerlink" title="确认版本"></a>确认版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -V </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ分布式事务原理</title>
    <url>/p/59086.html</url>
    <content><![CDATA[<p>⛅ 分布式事务常见的方案有TCC（Try-Confirm-Cancel），XA两阶段提交方案，<strong>可靠消息最终一致性方案</strong>，最大努力通知方案等等。</p>
<span id="more"></span>
<p>其中可靠消息最终一致性方案主要就可以依靠RocketMQ来做，因为RocketMQ支持消息事务。先上一张图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230530142401.png"
                     
                ><br>RocketMQ 事务消息的实现步骤如下：</p>
<ul>
<li>Producer发送half message给RocketMQ</li>
<li>RocketMQ返回half message success（half message发送成功之后RocketMQ的消费者并不能消费这条消息，因为消息存储在Topic为 RMQ_SYS_TRANS_HALF_TOPIC 的消息消费队列中，而不是原先的Topic）</li>
<li>执行核心交易链路</li>
<li>返回执行交易链路的结果，如果失败则回滚</li>
<li>如果执行成功，则Producer返回一个COMMIT状态给RocketMQ</li>
<li>如果RocketMQ迟迟收不到Producer的返回结果，即这条消息的状态为UNKNOWN，则会回调服务接口，查询这条消息到底是commit还是rollback</li>
<li>RocketMQ确认消息为commit，则Consumer可以消费到这条消息</li>
<li>Consumer操作数据库，执行自己的事务</li>
<li>Consumer成功消费之后返回一个ACK消息给RocketMQ，如果成功消费则显示消费成功，否则RocketMQ会重发消息给Consumer继续消费</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RocketMQ 事务消息的实现原理基于两阶段提交和定时事务状态回查来决定消息最终是提交还是回滚，RocketMQ 先执行第一部分的事务，如果失败则回滚，如果成功则定时任务会去回查到事务执行成功，这个时候通知消费者执行第二阶段的事务，如果失败则不断重发消息给消费者消费，如果成功则整个流程走完，保证了事务的原子性。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ消息丢失场景及解决办法</title>
    <url>/p/21838.html</url>
    <content><![CDATA[<p>🚀 既然在项目中使用了MQ，那么就不可避免的需要考虑消息丢失问题。</p>
<span id="more"></span>

<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>在一些涉及到了金钱交易的场景下，消息丢失还是很致命的。那么在RocketMQ中存在哪几种消息丢失的场景呢？<br>先来一张最简单的消费流程图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230530173934.png"
                     
                ></p>
<p>上图中大致包含了这么几种场景：</p>
<ul>
<li>生产者产生消息发送给RocketMQ</li>
<li>RocketMQ接收到了消息之后，必然需要存到磁盘中，否则断电或宕机之后会造成数据的丢失</li>
<li>消费者从RocketMQ中获取消息消费，消费成功之后，整个流程结束</li>
</ul>
<p>这三种场景都可能会产生消息的丢失，如下图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230530173903.png"
                     
                ></p>
<p>1、场景1中生产者将消息发送给Rocket MQ的时候，如果出现了网络抖动或者通信异常等问题，消息就有可能会丢失</p>
<p>2、场景2中消息需要持久化到磁盘中，这时会有两种情况导致消息丢失</p>
<ul>
<li>RocketMQ为了减少磁盘的IO，会先将消息写入到os cache中，而不是直接写入到磁盘中，消费者从os cache中获取消息类似于直接从内存中获取消息，速度更快，过一段时间会由os线程异步的将消息刷入磁盘中，此时才算真正完成了消息的持久化。在这个过程中，如果消息还没有完成异步刷盘，RocketMQ中的Broker宕机的话，就会导致消息丢失</li>
<li>如果消息已经被刷入了磁盘中，但是数据没有做任何备份，一旦磁盘损坏，那么消息也会丢失<br>3、消费者成功从RocketMQ中获取到了消息，还没有将消息完全消费完的时候，就通知RocketMQ我已经将消息消费了，然后消费者宕机，但是RocketMQ认为消费者已经成功消费了数据，所以数据依旧丢失了。<br>那么如何保证消息的零丢失呢？<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230530174115.png"
                     
                >

</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>1、场景1中保证消息不丢失的方案是使用RocketMQ自带的事务机制来发送消息，大致流程为：</p>
<ul>
<li>首先生产者发送half消息到RocketMQ中，此时消费者是无法消费half消息的，若half消息就发送失败了，则执行相应的回滚逻辑</li>
<li>half消息发送成功之后，且RocketMQ返回成功响应，则执行生产者的核心链路</li>
<li>如果生产者自己的核心链路执行失败，则回滚，并通知RocketMQ删除half消息</li>
<li>如果生产者的核心链路执行成功，则通知RocketMQ commit half消息，让消费者可以消费这条数据</li>
<li>其中还有一些RocketMQ长时间没有收到生产者是要commit/rollback操作的响应，回调生产者接口的细节，感兴趣的可以参考<a href="https://mynamecoder.com/p/59086.html">《 RocketMQ分布式事务原理》</a><br>在使用了RocketMQ事务将生产者的消息成功发送给RocketMQ，就可以保证在这个阶段消息不会丢失</li>
</ul>
<p>2、在场景2中要保证消息不丢失，首先需要将os cache的异步刷盘策略改为同步刷盘，这一步需要修改Broker的配置文件，将flushDiskType改为SYNC_FLUSH同步刷盘策略，默认的是ASYNC_FLUSH异步刷盘。<br>一旦同步刷盘返回成功，那么就一定保证消息已经持久化到磁盘中了；为了保证磁盘损坏不会丢失数据，我们需要对RocketMQ采用主从机构，集群部署，Leader中的数据在多个Follower中都存有备份，防止单点故障。</p>
<p>3、在场景3中，消息到达了消费者，RocketMQ在代码中就能保证消息不会丢失</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注册消息监听器处理消息</span><br><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">   @Override</span><br><span class="line">    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)&#123;                                  </span><br><span class="line">        //对消息进行处理</span><br><span class="line">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，RocketMQ在消费者中注册了一个监听器，当消费者获取到了消息，就会去回调这个监听器函数，去处理里面的消息<br>当你的消息处理完毕之后，才会返回ConsumeConcurrentlyStatus.CONSUME_SUCCESS 只有返回了CONSUME_SUCCESS，消费者才会告诉RocketMQ我已经消费完了，此时如果消费者宕机，消息已经处理完了，也就不会丢失消息了<br>如果消费者还没有返回CONSUME_SUCCESS时就宕机了，那么RocketMQ就会认为你这个消费者节点挂掉了，会自动故障转移，将消息交给消费者组的其他消费者去消费这个消息，保证消息不会丢失<br>为了保证消息不会丢失，在consumeMessage方法中就直接写消息消费的业务逻辑就可以了，如果非要搞一些骚操作，比如下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注册消息监听器处理消息</span><br><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">   @Override</span><br><span class="line">    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)&#123; </span><br><span class="line">     //开启子线程异步处理消息</span><br><span class="line">     new Thread() &#123;</span><br><span class="line">   public void run() &#123;</span><br><span class="line">    //对消息进行处理</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;.start();                                 </span><br><span class="line">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果新开子线程异步处理消息的话，就有可能出现消息还没有被消费完，消费者告诉RocketMQ消息已经被消费了，结果宕机丢失消息的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用上面一整套的方案就可以在使用RocketMQ时保证消息零丢失，但是性能和吞吐量也将大幅下降</p>
<ul>
<li>使用事务机制传输消息，会比普通的消息传输多出很多步骤，耗费性能</li>
<li>同步刷盘相比异步刷盘，一个是存储在磁盘中，一个存储在内存中，速度完全不是一个数量级</li>
<li>主从机构的话，需要Leader将数据同步给Follower</li>
<li>消费时无法异步消费，只能等待消费完成再通知RocketMQ消费完成</li>
</ul>
<p>消息零丢失是一把双刃剑，要想用好，还是要视具体的业务场景而定，选择合适的方案才是最好的。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的几个消息组件</title>
    <url>/p/5d3b.html</url>
    <content><![CDATA[<h2 id="MQ背景-amp-选型"><a href="#MQ背景-amp-选型" class="headerlink" title="MQ背景&amp;选型"></a>MQ背景&amp;选型</h2><p>消息队列作为高并发系统的核心组件之一，能够帮助业务系统解构提升开发效率和系统稳定性。主要具有以下优势：</p>
<ul>
<li>削峰填谷（主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题）</li>
<li>系统解耦（解决不同重要程度、不同能力级别系统之间依赖导致一死全死）</li>
<li>提升性能（当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统）</li>
<li>蓄流压测（线上有些链路不好压测，可以通过堆积一定量消息再放开来压测）</li>
</ul>
<p>目前主流的MQ主要是Rocketmq、kafka、Rabbitmq，Rocketmq相比于Rabbitmq、kafka具有主要优势特性有：</p>
<ul>
<li>支持事务型消息（消息发送和DB操作保持两方的最终一致性，rabbitmq和kafka不支持）</li>
<li>支持结合rocketmq的多个系统之间数据最终一致性（多方事务，二方事务是前提）</li>
<li>支持18个级别的延迟消息（rabbitmq和kafka不支持）</li>
<li>支持指定次数和时间间隔的失败消息重发（kafka不支持，rabbitmq需要手动确认）</li>
<li>支持consumer端tag过滤，减少不必要的网络传输（rabbitmq和kafka不支持）</li>
<li>支持重复消费（rabbitmq不支持，kafka支持）<br>Rocketmq、kafka、Rabbitmq的详细对比，请参照下表格：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/n7mLmNY/12619159-ebd12b24d5ae33d9.png"
                      alt="三个mq的对比"
                ><h2 id="RocketMQ集群概述"><a href="#RocketMQ集群概述" class="headerlink" title="RocketMQ集群概述"></a>RocketMQ集群概述</h2><h3 id="RocketMQ集群部署结构"><a href="#RocketMQ集群部署结构" class="headerlink" title="RocketMQ集群部署结构"></a>RocketMQ集群部署结构</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/xfC6HKh/12619159-a858d38e0b38c406.png"
                      alt="RocketMQ集群部署结构"
                ></li>
</ul>
<h4 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h4><p>Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的Broker Name，不同的Broker Id来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。<br>每个Broker与Name Server集群中的所有节点建立长连接，定时(每隔30s)注册Topic信息到所有Name Server。Name Server定时(每隔10s)扫描所有存活broker的连接，如果Name Server超过2分钟没有收到心跳，则Name Server断开与Broker的连接。</p>
<h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>Producer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。<br>Producer每隔30s（由ClientConfig的pollNameServerInterval）从Name server获取所有topic队列的最新情况，这意味着如果Broker不可用，Producer最多30s能够感知，在此期间内发往Broker的所有消息都会失败。<br>Producer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s中扫描所有存活的连接，如果Broker在2分钟内没有收到心跳数据，则关闭与Producer的连接。</p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>Consumer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。<br>Consumer每隔30s从Name server获取topic的最新队列情况，这意味着Broker不可用时，Consumer最多最需要30s才能感知。<br>Consumer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s扫描所有存活的连接，若某个连接2分钟内没有发送心跳数据，则关闭连接；并向该Consumer Group的所有Consumer发出通知，Group内的Consumer重新分配队列，然后继续消费。<br>当Consumer得到master宕机通知后，转向slave消费，slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是一旦master恢复，未同步过去的消息会被最终消费掉。<br>消费者队列是消费者连接之后（或者之前有连接过）才创建的。我们将原生的消费者标识由 {IP}@{消费者group}扩展为 {IP}@{消费者group}{topic}{tag}，（例如xxx.xxx.xxx.xxx@mqtest_producer-group_2m2sTest_tag-zyk）。任何一个元素不同，都认为是不同的消费端，每个消费端会拥有一份自己消费队列（默认是broker队列数量*broker数量）。新挂载的消费者队列中拥有commitlog中的所有数据。<br>如果有需要，可以查看Rocketmq更多源码解析</p>
<h2 id="Rocketmq如何支持分布式事务消息"><a href="#Rocketmq如何支持分布式事务消息" class="headerlink" title="Rocketmq如何支持分布式事务消息"></a>Rocketmq如何支持分布式事务消息</h2><p><strong>场景</strong><br>A（存在DB操作）、B（存在DB操作）两方需要保证分布式事务一致性，通过引入中间层MQ，A和MQ保持事务一致性（异常情况下通过MQ反查A接口实现check），B和MQ保证事务一致（通过重试），从而达到最终事务一致性。<br>原理：大事务 = 小事务 + 异步</p>
<h3 id="MQ与DB一致性原理（两方事务）"><a href="#MQ与DB一致性原理（两方事务）" class="headerlink" title="MQ与DB一致性原理（两方事务）"></a>MQ与DB一致性原理（两方事务）</h3><p><strong>流程图</strong><br><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/mHVYNLt/12619159-6f4f6754d6f02058.png"
                      alt="流程图"
                ><br>上图是RocketMQ提供的保证MQ消息、DB事务一致性的方案。<br>MQ消息、DB操作一致性方案：</p>
<ul>
<li>发送消息到MQ服务器，此时消息状态为SEND_OK。此消息为consumer不可见。</li>
<li>执行DB操作；DB执行成功Commit DB操作，DB执行失败Rollback DB操作。</li>
<li>如果DB执行成功，回复MQ服务器，将状态为COMMIT_MESSAGE；如果DB执行失败，回复MQ服务器，将状态改为ROLLBACK_MESSAGE。注意此过程有可能失败。</li>
<li>MQ内部提供一个名为“事务状态服务”的服务，此服务会检查事务消息的状态，如果发现消息未COMMIT，则通过Producer启动时注册的TransactionCheckListener来回调业务系统，业务系统在checkLocalTransactionState方法中检查DB事务状态，如果成功，则回复COMMIT_MESSAGE，否则回复ROLLBACK_MESSAGE。<br>说明：<br>上面以DB为例，其实此处可以是任何业务或者数据源。<br>以上SEND_OK、COMMIT_MESSAGE、ROLLBACK_MESSAGE均是client jar提供的状态，在MQ服务器内部是一个数字。</li>
</ul>
<p>TransactionCheckListener 是在消息的commit或者rollback消息丢失的情况下才会回调（上图中灰色部分）。这种消息丢失只存在于断网或者rocketmq集群挂了的情况下。当rocketmq集群挂了，如果采用异步刷盘，存在1s内数据丢失风险，异步刷盘场景下保障事务没有意义。所以如果要核心业务用Rocketmq解决分布式事务问题，建议选择同步刷盘模式。</p>
<h2 id="多系统之间数据一致性（多方事务）"><a href="#多系统之间数据一致性（多方事务）" class="headerlink" title="多系统之间数据一致性（多方事务）"></a>多系统之间数据一致性（多方事务）</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/KmFwTpZ/moreside.png"
                      alt="多方事务"
                ></p>
<p>当需要保证多方（超过2方）的分布式一致性，上面的两方事务一致性（通过Rocketmq的事务性消息解决）已经无法支持。这个时候需要引入TCC模式思想（Try-Confirm-Cancel，不清楚的自行百度）。<br>以上图交易系统为例：</p>
<ul>
<li>交易系统创建订单（往DB插入一条记录），同时发送订单创建消息。通过RocketMq事务性消息保证一致性</li>
<li>接着执行完成订单所需的同步核心RPC服务（非核心的系统通过监听MQ消息自行处理，处理结果不会影响交易状态）。执行成功更改订单状态，同时发送MQ消息。</li>
<li>交易系统接受自己发送的订单创建消息，通过定时调度系统创建延时回滚任务（或者使用RocketMq的重试功能，设置第二次发送时间为定时任务的延迟创建时间。在非消息堵塞的情况下，消息第一次到达延迟为1ms左右，这时可能RPC还未执行完，订单状态还未设置为完成，第二次消费时间可以指定）。延迟任务先通过查询订单状态判断订单是否完成，完成则不创建回滚任务，否则创建。 PS：多个RPC可以创建一个回滚任务，通过一个消费组接受一次消息就可以；也可以通过创建多个消费组，一个消息消费多次，每次消费创建一个RPC的回滚任务。  回滚任务失败，通过MQ的重发来重试。<br>以上是交易系统和其他系统之间保持最终一致性的解决方案。<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3></li>
</ul>
<h4 id="单机环境下的事务示意图"><a href="#单机环境下的事务示意图" class="headerlink" title="单机环境下的事务示意图"></a>单机环境下的事务示意图</h4><p>如下为A给B转账的例子。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>锁定B的账户</td>
</tr>
<tr>
<td>2</td>
<td>锁定B的账户</td>
</tr>
<tr>
<td>3</td>
<td>检查A账户是否有1元</td>
</tr>
<tr>
<td>4</td>
<td>A的账户扣减1元</td>
</tr>
<tr>
<td>5</td>
<td>给B的账户加1元</td>
</tr>
<tr>
<td>6</td>
<td>解锁B的账户</td>
</tr>
<tr>
<td>7</td>
<td>解锁A的账户</td>
</tr>
</tbody></table>
<p>以上过程在代码层面甚至可以简化到在一个事物中执行两条sql语句。</p>
<h4 id="分布式环境下事务"><a href="#分布式环境下事务" class="headerlink" title="分布式环境下事务"></a>分布式环境下事务</h4><p>和单机事务不同，A、B账户可能不在同一个DB中，此时无法像在单机情况下使用事物来实现。此时可以通过一下方式实现，将转账操作分成两个操作。</p>
<ul>
<li>A账户</li>
</ul>
<table>
<thead>
<tr>
<th>步骤</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>锁定A的账户</td>
</tr>
<tr>
<td>2</td>
<td>检查A账户是否有1元</td>
</tr>
<tr>
<td>3</td>
<td>A的账户扣减1元</td>
</tr>
<tr>
<td>4</td>
<td>解锁A的账户</td>
</tr>
</tbody></table>
<ul>
<li>MQ消息</li>
</ul>
<p>A账户数据发生变化时，发送MQ消息，MQ服务器将消息推送给转账系统，转账系统来给B账号加钱。</p>
<ul>
<li>B账户</li>
</ul>
<table>
<thead>
<tr>
<th>步骤</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>锁定B的账户</td>
</tr>
<tr>
<td>2</td>
<td>给B的账户加1元</td>
</tr>
<tr>
<td>3</td>
<td>解锁B的账户</td>
</tr>
</tbody></table>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><h3 id="顺序消息缺陷"><a href="#顺序消息缺陷" class="headerlink" title="顺序消息缺陷"></a>顺序消息缺陷</h3><p>发送顺序消息无法利用集群<code>Fail Over</code>特性消费，顺序消息的并行度依赖于队列数量，存在队列热点问题，个别队列由于哈希不均导致消息过多，消费速度跟不上，产生消息堆积问题遇到消息失败的消息，无法跳过，当前队列消费暂停。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>produce在发送消息的时候，把消息发到同一个队列（<code>queue</code>）中,消费者注册消息监听器为<code>MessageListenerOrderly</code>，这样就可以保证消费端只有一个线程去消费消息。<br>注意：把消息发到同一个队列（<code>queue</code>），不是同一个<code>topic</code>，默认情况下一个<code>topic</code>包括4个<code>queue</code></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>可以通过实现发送消息的队列选择器方法，实现部分顺序消息。<br>举例：比如一个数据库通过MQ来同步，只需要保证每个表的数据是同步的就可以。解析<code>binlog</code>，将表名作为队列选择器的参数，这样就可以保证每个表的数据到同一个队列里面，从而保证表数据的顺序消费。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="Producer-1"><a href="#Producer-1" class="headerlink" title="Producer"></a>Producer</h3><ul>
<li><p>  Topic<br>一个应用尽可能用一个<code>Topic</code>，消息子类型用tags来标识，tags可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用<code>tags</code> 在<code>broker</code>做消息过滤。</p>
</li>
<li><p>  key<br>每个消息在业务层面的唯一标识码，要设置到 <code>keys</code> 字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引(哈希索引)，应用可以通过 <code>topic</code>，key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证<code>key</code> 尽可能唯一，这样可以避免潜在的哈希冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//订单Id</span><br><span class="line">String orderId= &quot;20034568923546&quot;;</span><br><span class="line">message.setKeys(orderId);</span><br></pre></td></tr></table></figure></li>
<li><p>  日志<br>消息发送成功或者失败，要打印消息日志，务必要打印 <code>send result</code> 和<code>key</code> 字段。</p>
</li>
<li><p> <code>send</code><br><code>send</code>消息方法，只要不抛异常，就代表发送成功。但是发送成功会有多个状态，在<code>sendResult</code>里定义。<br><code>SEND_OK</code>：消息发送成功<br><code>FLUSH_DISK_TIMEOUT</code>：消息发送成功，但是服务器刷盘超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失<br><code>FLUSH_SLAVE_TIMEOUT</code>：消息发送成功，但是服务器同步到Slave时超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失<br><code>SLAVE_NOT_AVAILABLE</code>：消息发送成功，但是此时slave不可用，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</p>
<h3 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h3></li>
<li><p> 幂等<br>RocketMQ使用的消息原语是<code>At Least Once</code>，所以<code>consumer</code>可能多次收到同一个消息，此时务必做好幂等。</p>
</li>
<li><p>  日志<br>消费时记录日志，以便后续定位问题。</p>
</li>
<li><p>  批量消费<br>尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2></li>
<li><p> 博客<br>分布式开放消息系统(RocketMQ)的原理与实践<br><a class="link"   href="http://www.jianshu.com/p/453c6e7ff81c" >http://www.jianshu.com/p/453c6e7ff81c<i class="fas fa-external-link-alt"></i></a><br>RocketMQ事务消费和顺序消费详解<br><a class="link"   href="http://www.cnblogs.com/520playboy/p/6750023.html" >http://www.cnblogs.com/520playboy/p/6750023.html<i class="fas fa-external-link-alt"></i></a><br>ZeroCopy<br><a class="link"   href="http://www.linuxjournal.com/article/6345" >http://www.linuxjournal.com/article/6345<i class="fas fa-external-link-alt"></i></a><br>IO方式的性能数据<br><a class="link"   href="http://stblog.baidu-tech.com/?p=851" >http://stblog.baidu-tech.com/?p=851<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是幂等性?又如何保证?</title>
    <url>/p/20864.html</url>
    <content><![CDATA[<h2 id="什么是幂等性？"><a href="#什么是幂等性？" class="headerlink" title="什么是幂等性？"></a>什么是幂等性？</h2><p>幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。<br>在增删改查4个操作中，尤为注意就是增加或者修改，因为查询只是读的操作，所以对于结果是不会有改变的；<br>删除只会进行一次，大部分情况下根据主键删除时，用户多次点击产生的结果也是一样的；<br>而修改和增加在重复提交的场景下会非常容易出现幂等性的问题。</p>
<h2 id="如何保证幂等性"><a href="#如何保证幂等性" class="headerlink" title="如何保证幂等性"></a>如何保证幂等性</h2><ul>
<li>唯一索引，防止新增脏数据。如新增用户数据，一般用户名是唯一的，所以，我们可以设置用户名字段唯一索引</li>
<li>token机制，防止页面重复提交。<ul>
<li>分为两个阶段，获取token和使用token。<br>1、每次接口请求前先获取一个token，返回给前端；<br>2、然后再下次请求的时候在请求的header中加上这个token后端进行验证，如果验证通过就删除token，这时，如果其他请求过来，则验证会不通过，就达到了防止重复提交的问题。</li>
</ul>
</li>
<li>悲观锁（并发高的话慎用） Synchronized(单机环境适用)/数据库悲观锁</li>
<li>乐观锁 （可能循环时间长开销大） Lock(单机环境适用)/数据库乐观锁</li>
<li>分布式锁（适用分布式系统）<ul>
<li>推荐使用第三方组件Redission实现</li>
</ul>
</li>
</ul>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>安利一个Mac下好用的抓包工具-Charles</title>
    <url>/p/46863.html</url>
    <content><![CDATA[<!-- ![](https://img.mynamecoder.com/20220814130111.png) -->
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814130200.png"
                     
                ><br>Charles：让天底下没有难抓的包。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天给大家推荐一个我所使用过的抓包工具中最好用的抓包工具-Charles（音译：查尔斯），它可以抓各端发起的网络请求，我主要用来抓移动设备上的请求，上次小明就通过这种方式找到了一款付费App课程的漏洞，咳咳，不展开说了，毕竟web端的浏览器网络请求，打开开发者工具就能看到（滑稽）。</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ul>
<li>方式一：官网下载</li>
</ul>
<p>链接：<a class="link"   href="https://www.charlesproxy.com/download/" >https://www.charlesproxy.com/download/<i class="fas fa-external-link-alt"></i></a></p>
<p>期限：试用30天</p>
<ul>
<li>方式二：百度网盘（推荐）</li>
</ul>
<p>链接: <a class="link"   href="https://pan.baidu.com/s/1p7GJKKfFL4NHgy47Hm_5ng" >https://pan.baidu.com/s/1p7GJKKfFL4NHgy47Hm_5ng<i class="fas fa-external-link-alt"></i></a></p>
<p>期限: 没有使用限制，附带安装说明文档（你懂的），推荐使用正版软件。</p>
<p>密码: 关注微信公众号“程序员小明”，回复“查尔斯”即可获取。</p>
<h2 id="配置及使用"><a href="#配置及使用" class="headerlink" title="配置及使用"></a>配置及使用</h2><p>第一次启动的时候会提示自动配置，点击同意即可，当然也可以自定义配置。主要配置全部在Proxy这里，端口号默认8888，也可以自己调整。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814123924.png"
                     
                ><br>接下来，给大家分别介绍一下使用Charles抓取浏览器和移动端网络请求的方法。</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>拿Mac举例（如题），需要将当前你连接的网络配置网页代理（http）、网页安全代理（https），默认Charles会自动配置好，如下所示<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814170205.png"
                     
                ><br>当然，如果你看到的不是这样，也可以手动配置，其中127.0.0.1表示本地地址，端口号根据自己的配置指定。确认好以上配置以后，这时我们打开百度，却提示：您的连接不是私密连接！<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814162657.png"
                     
                ></p>
<p>此时一定要沉着冷静，这是表示当前https代理证书不被信任，解决方法如下：</p>
<ul>
<li><p>打开Charles，选择Help -&gt; SSL Proxy -&gt; Install Charles Root Certificate<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814163000.png"
                     
                ></p>
</li>
<li><p>在弹出的证书窗口中，可以看到该证书已成功添加，但是此时该证书图标有<strong>叉号</strong>，表示仍然不被信任<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814163123.png"
                     
                ></p>
</li>
<li><p>双击此证书，在弹出的Charles Proxy CA窗口中，点击“信任“按钮 -&gt; 使用此证书 -&gt; 选择”始终信任“后关闭窗口，使用账号和密码授权后，即可看到此证书<strong>叉号</strong>消失，表示已经被信任。</p>
</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814163830.png"
                     
                ></p>
<ul>
<li>再次打开百度，我们就可以正常访问<br>如果此时Charles弹出弹窗提示是否allow，选择allow即可。当然，我们也可以设置全部https网络请求都允许抓取<br>选择Proxy -&gt; SSL Proxying Settings，增加一个Location</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: *</span><br><span class="line">Port: 443</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814170559.png"
                     
                ></p>
<h2 id="移动端（本文重点）"><a href="#移动端（本文重点）" class="headerlink" title="移动端（本文重点）"></a>移动端（本文重点）</h2><h3 id="抓取http请求"><a href="#抓取http请求" class="headerlink" title="抓取http请求"></a>抓取http请求</h3><ul>
<li>同样在电脑上打开Charles</li>
<li>现在需要在手机上配置代理<br>wifi设置-网络代理，输入电脑的ip、端口号（默认8888），可通过<code>ifconfig</code>查看本机电脑ip</li>
<li>保存后，Charles会弹出弹窗提示是否allow，选择allow即可。<br>如果你使用的手机系统是Android，此时，Charles就可以抓取http和https的网络请求，而如果你使用的是iPhone的ios系统，则目前只能抓取http网络请求，接下来我们看一下ios系统的手机如何抓取https的网络请求。</li>
</ul>
<h3 id="抓取-ios-https请求"><a href="#抓取-ios-https请求" class="headerlink" title="抓取 ios https请求"></a>抓取 ios https请求</h3><p>众所周知，ios是一个很讲究的系统，首先我们需要安装证书<br>选择Charles－&gt; Help －&gt; SSL Proxying－&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser，我们可以看到如下提示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814172702.png"
                     
                ><br>小明翻译一下：</p>
<ul>
<li>为你的手机配置http代理<br>打开手机设置的无线局域网（确保手机和电脑在同一WiFi下：），点击右边的<strong>i</strong>，拉到最下面，选择“配置代理”，代理地址就是弹窗的地址。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814173040.png"
                     
                ></li>
<li>打开手机浏览器，一定要用<strong>Safari</strong>，其他浏览器不识别这个证书，输入chls.pro/ssl，下载并安装证书<br>ios的证书下载后需要到 设置 -&gt; 通用 -&gt; 描述文件 下去安装证书</li>
<li>注意！还没有结束！（多少英雄好汉跌倒在这里）<br>安装成功后，实际上我们并未<strong>授信证书</strong>, 选择 设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置 对证书开启完全信任！<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/IMG_EE1785880387-1.jpeg"
                     
                ></li>
</ul>
<h2 id="可以设置不代理计算机的请求（可选择）"><a href="#可以设置不代理计算机的请求（可选择）" class="headerlink" title="可以设置不代理计算机的请求（可选择）"></a>可以设置不代理计算机的请求（可选择）</h2><p>选择Proxy -&gt; macOS 取消勾选则表示不抓取计算机的请求<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814124458.png"
                     
                ></p>
<p>同理，选择Proxy -&gt; Mozilla Firefox 不勾选则不抓取计算机上 Mozilla Firefox浏览器的请求<br>这个应用场景主要是只针对移动端数据抓取时，则这两项就可以不勾选。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="https协议，使用Charles抓包时，request和respond都出现乱码"><a href="#https协议，使用Charles抓包时，request和respond都出现乱码" class="headerlink" title="https协议，使用Charles抓包时，request和respond都出现乱码"></a>https协议，使用Charles抓包时，request和respond都出现乱码</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231212100809.png"
                      alt="请求乱码"
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231212100901.png"
                      alt="响应乱码"
                ></p>
<p>1、全局设置：</p>
<p>Proxy&gt;SSL Proxying Settings&gt;SSL Proxying，添加Host：*，Port：443，问题解决。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231212100912.png"
                      alt="解决"
                ></p>
<p>2、针对目标网站设置：</p>
<p>Structure tab页，选中某个网址，右键，点击选中“Enable SSL Proxying”，同样可以是request和response中的乱码问题得以解决。</p>
<p>Charles的操作使用今天就介绍到这里，恭喜你！已经掌握了它的80%功能，已经足够日常开发使用，是不是感觉自己又变厉害啦！当然，它还有高端的玩法，比如打断点，修改请求、返回的参数，本次暂不介绍，以后有机会小明再来补充。</p>
<h2 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>Mac</tag>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac使用iTerm2 一键免密登录</title>
    <url>/p/4298.html</url>
    <content><![CDATA[<blockquote>
<p>iTerm是mac平台很好用的ssh管理工具，今天给大家介绍一种使用iTerm一键登陆服务器优雅的方式，这样就不需要每次连接服务器时都需要输入端口号、用户名、ip地址、密码（为了安全，服务器密码都好长好长）。</p>
</blockquote>
<span id="more"></span>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>我们先准备一个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">set timeout 30</span><br><span class="line">spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]</span><br><span class="line">expect &#123;</span><br><span class="line">        &quot;(yes/no)?&quot;</span><br><span class="line">        &#123;send &quot;yes\n&quot;;exp_continue&#125;</span><br><span class="line">        &quot;password:&quot;</span><br><span class="line">        &#123;send &quot;[lindex $argv 3]\n&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>这个脚本需要传入服务器的四个参数：端口号、服务器用户名、服务器地址 、对应用户名的密码 。</p>
<blockquote>
<p>当我们看懂这个脚本后，其实就可以简化一下，比如服务器ssh端口号默认为22，因此有时候不需要指定端口的情况下，就可以在脚本中删除<code>-p [lindex $argv 0]</code>,同时记得修改后面argv的索引，比如argv1 改为 argv0，以此类推，不过为了保证脚本的通用性，不推荐大家这样做，因为为了服务器安全，避免被暴力破解，服务器是不使用默认的22端口号的。</p>
</blockquote>
<p>接下来我们把这个脚本放到<code>$PATH</code> 下，这样就可以直接使用这个脚本（不用通过文件路径就可以直接使用，像<code>/usr/local/bin/</code>、<code>/usr/bin</code>下面的命令），因此小明建议直接放<code>/usr/local/bin</code>下面，也可以通过命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p>查看一下你自己的<strong>PATH</strong>路径，小明的<strong>PATH</strong>路径如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br></pre></td></tr></table></figure>

<p>然后我们使用<code>chmod</code>让文件变成可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod +x login.exp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：最新Mac os 可能对这些目录权限限制比较严格，因此需要sudo 才能成功</p>
</blockquote>
<h2 id="配置iTerm2"><a href="#配置iTerm2" class="headerlink" title="配置iTerm2"></a>配置iTerm2</h2><p>我们打开iTerm2-&gt;菜单Profiles-&gt;Open Profiles-&gt;Edit Profiles，如下所示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/11/26/MzRGr9.png"
                      alt="配置profile"
                ></p>
<p>红色标注的命令就是我们要连接服务器的配置信息，按着顺序输入即可。下次我们就可以在<strong>Profiles</strong>下面一键连接自己的服务器啦。另外，我们可以使用<strong>Tags</strong>标注该服务器，在服务器比较多的场景下（小明公司的服务器就比较多）就能很快找到自己想要的服务器。今天的Mac 使用 iTerm2文章就分享到这里啦，小伙伴们有什么问题都可以在下方留言！</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title>Mac安装Homebrew的那些事儿</title>
    <url>/p/75a0.html</url>
    <content><![CDATA[<blockquote>
<p>最近小明刚换置了一个 Mac 本，想搭建一个属于自己的博客网站，需要用到 Node.js 环境，而Node.js 在 MacOS 中是由 Homebrew 进行安装管理的……因此，便有了Homebrew的安装历程。</p>
</blockquote>
<h2 id="什么是Homebrew"><a href="#什么是Homebrew" class="headerlink" title="什么是Homebrew?"></a>什么是Homebrew?</h2><p>简而言之，Homebrew是Mac Os的包管理工具，相当于Redhat Linux(Centos/RHEL/Fedora)的<code>yum</code>或者Debian Linux(Debian/Ubuntu)的<code>apt-get</code>。</p>
<h2 id="如何安装Homebrew？"><a href="#如何安装Homebrew？" class="headerlink" title="如何安装Homebrew？"></a>如何安装Homebrew？</h2><p>我们使用官网提供的统一安装方法，只需执行下面的命令即可</p>
<blockquote>
<p>因为这个链接随时可能会更新，所以还是建议去<a class="link"   href="https://brew.sh/index_zh-cn" >官网首页<i class="fas fa-external-link-alt"></i></a>确认一下这个命令，如果显示超时，可以尝试将脚本下载到本地，再执行命令。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>Ruby</em> 是一种开源的面向对象程序设计的服务器端脚本语言，Mac上默认已经给我们安装好了。一段漫长的时间过后，当出现**Installation successful!**提示时就表示已经安装成功。</p>
<p>如果文章到此结束，那这篇文章的价值也太低了吧。接下来给大家扩展一下。</p>
<h2 id="安装时可能遇到的问题"><a href="#安装时可能遇到的问题" class="headerlink" title="安装时可能遇到的问题"></a>安装时可能遇到的问题</h2><h3 id="读写权限不够"><a href="#读写权限不够" class="headerlink" title="读写权限不够"></a>读写权限不够</h3><p>小明安装的时候遇到一个问题就是出现如下的提示，表明当前用户权限不够：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch: /Users/xiaoming/Library/Caches/Homebrew/.cleaned: Permission denied</span><br></pre></td></tr></table></figure>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要超级管理员（root）赋予权限，执行以下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown -R $&#123;USER&#125; /Users/xiaoming/Library/Caches/Homebrew/</span><br></pre></td></tr></table></figure>

<p>根据提示输入密码即可。</p>
<blockquote>
<p><code>chown</code>指令是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。表示使用root用户赋予当前用户对该目录的操作权限。</p>
</blockquote>
<h2 id="如何提高brew安装软件的速度？"><a href="#如何提高brew安装软件的速度？" class="headerlink" title="如何提高brew安装软件的速度？"></a>如何提高brew安装软件的速度？</h2><p>当我们一路披荆斩棘或者顺风顺水安装成功brew过后，即可执行自己为所欲为安装自己想要的软件，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>

<p>但是好像有点不妙，执行命令过后，下载安装的速度怎么这么感人？发现问题是一个很好的开始，有强迫症的小明第一时间就在网上搜集各种资料，一边享受着互联网时代的福祉，一边自己不停的踩坑，经历过数次<strong>下载-安装-卸载</strong>过后终于从坑里成功爬出。</p>
<h3 id="更换Bottles源"><a href="#更换Bottles源" class="headerlink" title="更换Bottles源"></a>更换Bottles源</h3><p>Homebrew 安装的软件默认都在以下目录中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Cellar</strong>意为酒窖、地窖，⽽Homebrew官⽅预先编译好的⼀个软件叫做⼀个 Bottle(酒瓶⼦)，Bottles就是很多酒瓶⼦(即软件)，Homebrew把安装⼀个软件叫做把⼀个酒瓶⼦放到酒窖(地窖)⾥（不过其实是pour，即倒到酒窖⾥）。</p>
</blockquote>
<p>Homebrew官⽅的软件（即Bottles）是放在 <a class="link"   href="https://bintray.com/" >bintray<i class="fas fa-external-link-alt"></i></a>⽹站中的，因为是国外⽹站及众所周知的原因，如果直接从这⾥下载是⾮常慢的，所以我们还是要把它换成国内的源（由中科⼤提供）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>该命令执行过后，我们就可以体验一下飞一般的速度了～嗖嗖嗖～</p>
<p>等一下（尔康表情包），顺便再提一嘴，明哥经常用到的几个命令吧。</p>
<h2 id="brew几个基本使用命令"><a href="#brew几个基本使用命令" class="headerlink" title="brew几个基本使用命令"></a>brew几个基本使用命令</h2><ul>
<li><p>查询软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew search 软件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install 软件名</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>启动|停止|重启软件</p>
<p>对于需要在后台运行的软件，大部分可用以下方式启动|停止|重启（它的原理是用launchctl+plist，用这种方式启动的软件重启电脑后也会自动启动）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew services start|stop|restart 软件名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>关于brew services的原理及详细用法，大家可以查看：Mac服务管理 – launchd、launchctl、LaunchAgent、LaunchDaemon、brew services详解。</p>
</blockquote>
<ul>
<li><p>卸载软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew uninstall 软件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看软件的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew info 软件名</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查看安装了哪些软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew list 软件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看安装了哪些软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew list 软件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew help</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以上就是brew常用的几个命令，最后的最后再说一下，再多提一嘴，如何和优雅地和brew说分手。</p>
<h2 id="我用brew干什么"><a href="#我用brew干什么" class="headerlink" title="我用brew干什么"></a>我用brew干什么</h2><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>mac解压zip毫无压力，但是总是有些同事会发给你一些rar文件，我们就可以通过使用<strong>urar</strong>这个工具解压文件</p>
<h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install unrar</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>打开终端，cd到要解压文件的目录下，然后在终端输入下列命令即可，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unrar x 压缩文件.rar</span><br></pre></td></tr></table></figure>

<p>此时 .rar 文件与 解压的文件夹在同一目录下（解压出来的文件所在目录和命令行执行目录一致）。</p>
<h2 id="卸载brew"><a href="#卸载brew" class="headerlink" title="卸载brew"></a>卸载brew</h2><p>因为一开始我们使用的是官方安装方式，因此好聚好散，我们还是使用官方的卸载方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://mirrors.aliyun.com/homebrew/brew/install/master/uninstall)&quot;  </span><br></pre></td></tr></table></figure>

<p>执行过后，一切宛如初见～</p>
<p>各位，祝好。有什么问题记得留言哈。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装破解Navicat</title>
    <url>/p/2246.html</url>
    <content><![CDATA[<blockquote>
<p>本文目的如题，navicat 优点不再赘述。如有侵权，请联系我立即删除。</p>
</blockquote>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>Mac版 Navicat Premium 12 v12.0.23.0 官网下载地址：</p>
<p>英文64位 <a class="link"   href="http://download.navicat.com/download/navicat120_premium_en.dmg" >http://download.navicat.com/download/navicat120_premium_en.dmg<i class="fas fa-external-link-alt"></i></a><br>中文简体64位 <a class="link"   href="http://download.navicat.com/download/navicat120_premium_cs.dmg" >http://download.navicat.com/download/navicat120_premium_cs.dmg<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p><strong>注意</strong>：我没有下载最新版本的navicat，因为上面那个版本比较稳定，而且我用起来挺舒服的。当然最主要的原因是：本文的破解方式也只是针对该版本，并不支持最新版本（后续待更新）。</p>
</blockquote>
<h2 id="生成自己的RSA公钥私钥对"><a href="#生成自己的RSA公钥私钥对" class="headerlink" title="生成自己的RSA公钥私钥对"></a>生成自己的RSA公钥私钥对</h2><p>为了节省时间，大家可以使用我提供的一对密钥。</p>
<h3 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQB8vXG0ImYhLHvHhpi5FS3g</span><br><span class="line">d2QhxSQiU6dQ04F1OHB0yRRQ3NXF5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJX</span><br><span class="line">HtQVLXMRms+chomsQCwkDi2jbgUa4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEF</span><br><span class="line">h0N89FV4yGLyDLr+TLqpRecg9pkPnOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZS</span><br><span class="line">I69sPD9xZRt+EciXVQfybI/2SYeAdXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd</span><br><span class="line">+03NU3wvEmLBvGOmNGudocWIF/y3VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/p</span><br><span class="line">AgMBAAE=</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<h3 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIEogIBAAKCAQB8vXG0ImYhLHvHhpi5FS3gd2QhxSQiU6dQ04F1OHB0yRRQ3NXF</span><br><span class="line">5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJXHtQVLXMRms+chomsQCwkDi2jbgUa</span><br><span class="line">4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEFh0N89FV4yGLyDLr+TLqpRecg9pkP</span><br><span class="line">nOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZSI69sPD9xZRt+EciXVQfybI/2SYeA</span><br><span class="line">dXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd+03NU3wvEmLBvGOmNGudocWIF/y3</span><br><span class="line">VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/pAgMBAAECggEAK5qZbYt8wenn1uZg</span><br><span class="line">6onRwJ5bfUaJjApL+YAFx/ETtm83z9ByVbx4WWT7CNC7fK1nINy20/mJrOTZkgIx</span><br><span class="line">x6otiNC4+DIsACJqol+RLoo8I9pk77Ucybn65ZteOz7hVZIU+8j6LzW0KDt6yowX</span><br><span class="line">e75r7G/NEpfibNc3Zz81+oDd2x+bHyGbzc9QcePIVuEzkof6jgpbWrQZU14itx9l</span><br><span class="line">VxEgj/fbMccvBx8brR/l9ClmDZd9Y6TWsF1rfJpF3+DPeqFkKCiD7PGz3bs4O/Zd</span><br><span class="line">ZrfV21ZNVusBW49G6bU63gQVKsOf1qGo3efbAW1HVxgTQ/lExVdcMvdenZm+ADKp</span><br><span class="line">L4/wUQKBgQDOfBjn3OC2IerUFu18EgCS7pSjTSibXw+TeX3D5zwszLC091G2rGlT</span><br><span class="line">5DihBUhMfesNdpoZynrs4YB6Sz9C3wSGAB8AM/tNvPhtSVtbMHmrdT2DEEKCvLkO</span><br><span class="line">RNBnt+8aTu2hGRanw9aL1189gzwrmXK5ZuuURfgLrB9ihrvjo4VznQKBgQCapx13</span><br><span class="line">dEA1MwapBiIa3k8hVBCoGPsEPWqM33RBdUqUsP33f9/PCx00j/akwmjgQNnBlAJo</span><br><span class="line">Y7LOqPCyiwOkEf40T4IlHdzYntWQQvHhfBwqSgdkTE9tKj43Ddr7JVFRL6yMSbW3</span><br><span class="line">9qAp5UX/+VzOLGAlfzJ8CBnkXwGrnKPCVbnZvQKBgQCd+iof80jlcCu3GteVrjxM</span><br><span class="line">LkcAbb8cqG1FWpVTNe4/JFgqDHKzPVPUgG6nG2CGTWxxv4UFKHpGE/11E28SHYjb</span><br><span class="line">cOpHAH5LqsGy84X2za649JkcVmtclUFMXm/Ietxvl2WNdKF1t4rFMQFIEckOXnd8</span><br><span class="line">y/Z/Wcz+OTFF82l7L5ehrQKBgFXl9m7v6e3ijpN5LZ5A1jDL0Yicf2fmePUP9DGb</span><br><span class="line">ZTZbbGR46SXFpY4ZXEQ9GyVbv9dOT1wN7DXvDeoNXpNVzxzdAIt/H7hN2I8NL+4v</span><br><span class="line">EjHG9n4WCJO4v9+yWWvfWWA/m5Y8JqusV1+N0iiQJ6T4btrE4JSVp1P6FSJtmWOK</span><br><span class="line">W/T9AoGAcMhPMCL+N+AvWcYt4Y4mhelvDG8e/Jj4U+lwS3g7YmuQuYx7h5tjrS33</span><br><span class="line">w4o20g/3XudPMJHhA3z+d8b3GaVM3ZtcRM3+Rvk+zSOcGSwn3yDy4NYlv9bdUj/4</span><br><span class="line">H+aU1Qu1ZYojFM1Gmbe4HeYDOzRsJ5BhNrrV12h27JWkiRJ4F/Q=</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<h2 id="安装程序，并替换应用包内容目录中rpk文件的公钥"><a href="#安装程序，并替换应用包内容目录中rpk文件的公钥" class="headerlink" title="安装程序，并替换应用包内容目录中rpk文件的公钥"></a>安装程序，并替换应用包内容目录中rpk文件的公钥</h2><p>安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录 /Contents/Resources，编辑<strong>rpk</strong>文件，将<strong>公钥</strong>替换并保存。</p>
<h2 id="解密请求码，生成激活码"><a href="#解密请求码，生成激活码" class="headerlink" title="解密请求码，生成激活码"></a>解密请求码，生成激活码</h2><ol>
<li><p>打开应用，<strong>断网</strong>，点击注册，输入密钥 <code>NAVH-T4PX-WT8W-QBL5</code>，然后选择手动激活。</p>
</li>
<li><p>复制请求码，根据私钥解密请求码（弹框显示），得到激活码明文<br>注意必须自己解密，因为解密后得到的“DI”是不同的<br>激活码明文示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;K&quot; : &quot;NAVHT4PXWT8WQBL5&quot;,</span><br><span class="line">  &quot;P&quot; : &quot;Mac 10.13&quot;,</span><br><span class="line">  &quot;DI&quot; : &quot;ODQ2Yjg2ZDBjMTEzMjhh&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上在线RSA私钥解密网址：<a class="link"   href="http://tool.chacuo.net/cryptrsaprikey" >http://tool.chacuo.net/cryptrsaprikey<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>将得到的激活码明文进行修改，修改后格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;K&quot;:&quot;NAVHT4PXWT8WQBL5&quot;, &quot;N&quot;:&quot;xiaoming&quot;, &quot;O&quot;:&quot;xiaoming&quot;, &quot;DI&quot;:&quot;ODQ2Yjg2ZDBjMTEzMjhh&quot;, &quot;T&quot;:1516939200&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：上面的<code>&quot;P&quot;</code>没有了，激活码明文格式最好复制我的，改变 ” ” 内的字符即可，在同一行哦，不要换行，否则激活失败！！！ <code>“K”</code> <code>“DI”</code> 都替换成自己机器解密的信息，<code>”N”</code> <code>“O”</code> 可以自己定义（比如，小明为了表明是自己整理的，就填上了xiaoming）。<code>&quot;T&quot;</code> 这个Unix时间戳一定要使用当天的。比如你激活那一天是2018/08/19，你就需要去生成一个2018/08/19 00:00:00（时分秒无所谓）的时间戳，替换那个<code>&quot;T&quot;</code>之后，再去加密，即可顺利激活。</p>
<p>附上转换时间戳的的地址：<a class="link"   href="http://tool.chinaz.com/Tools/unixtime.aspx" >http://tool.chinaz.com/Tools/unixtime.aspx<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>加密激活码明文，使用私钥加密激活码明文。</p>
<p>再次附上在线RSA私钥解密网址：<a class="link"   href="http://tool.chacuo.net/cryptrsaprikey" >http://tool.chacuo.net/cryptrsaprikey<i class="fas fa-external-link-alt"></i></a></p>
<p>复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活！</p>
<p><strong>大家有什么问题都可以随时留言哈～</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac系统下Datagrip打不开、点击没反应？</title>
    <url>/p/2207.html</url>
    <content><![CDATA[<p>有没有可能是因为你从网上下载了一些破解软件导致的？</p>
<span id="more"></span>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Mac系统下JB公司家的IDEA、 Datagrip、PyCharm 或 Goland 打不开点击没反应……</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>大概率是之前安装过 汉化插件、激活插件导致</p>
<h3 id="查看方式"><a href="#查看方式" class="headerlink" title="查看方式"></a>查看方式</h3><p>在 terminal 执行 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/DataGrip.app/Contents/MacOS/datagrip</span><br></pre></td></tr></table></figure>

<h3 id="查看报错日志"><a href="#查看报错日志" class="headerlink" title="查看报错日志"></a>查看报错日志</h3><p>（此处偷懒，省略截图，看最后一行）<br>由此报错信息可以得知，启动时，是在加载该文件时出错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/Library/Application Support/JetBrains/DataGrip2020.1/datagrip.vmoptions </span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>找到 <code>datagrip.vmoptions</code> 文件最后面 将 -javaagent 开头的删除掉<br>然后重新启动 软件。</p>
<p>ps：这多数都是破解激活留下的坑，建议支持正版。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>DataGrip连接Mysql报08S01解决方案</title>
    <url>/p/22588.html</url>
    <content><![CDATA[<p>以前正常使用的GataGrip，突然在某天报下面的错误提示:08S01</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[08S01]</span><br><span class="line">    Communications link failure</span><br><span class="line"></span><br><span class="line">    The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.</span><br><span class="line">No appropriate protocol (protocol is disabled or cipher suites are inappropriate).</span><br></pre></td></tr></table></figure>

<p>从提示的英文能看出来，是 protocol的问题，打开数据库连接设置：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220814194312.png"
                     
                ><br>将useSsl设置为false，完美解决。</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>Mac</tag>
        <tag>DataGrip</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql中金融字段的设计</title>
    <url>/p/14341.html</url>
    <content><![CDATA[<p>一般同财务相关的金额类数据必须使用 decimal 类型 ，由于 float 和 double 都是非精准的浮点数类型，而 decimal 是精准的浮点数类型。所以一般在设计用户余额，商品价格等金融类字段一般都是使用 decimal 类型，可以精确到分。</p>
<p><strong>但是</strong>，在海量互联网业务的设计标准中，并不推荐用 DECIMAL 类型，而是更推荐将 DECIMAL 转化为整型类型。 也就是说，金融类型更推荐使用用分单位存储，而不是用元单位存储。如1元在数据库中用整型类型 100 存储。</p>
<p>下面是 bigint 类型的优点：<br>decimal 是通过二进制实现的一种编码方式，计算效率不如 bigint<br>使用 bigint 的话，字段是定长字段，存储高效，而 decimal 根据定义的宽度决定，在数据设计中，定长存储性能更好<br>使用 bigint 存储分为单位的金额，也可以存储千兆级别的金额，完全够用，它的范围仅受限于可用内存的大小。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从复制原理及流程图</title>
    <url>/p/27605.html</url>
    <content><![CDATA[<p>🐕 一张图明白整体流程</p>
<span id="more"></span>
<blockquote>
<p>两个log文件，3个线程</p>
</blockquote>
<p>(1) Master的更新事件(update、insert、delete)会按照顺序写入<code>bin-log</code>中。<br>当Slave连接到Master的后，Master机器会为Slave开启<code>binlog dump</code>线程,该线程会去读取<code>bin-log</code>日志<br>(2) Slave连接到Master后,Slave库有一个<code>I/O</code>线程 通过请求<code>binlog dump</code> 线程读取bin-log日志，然后写入从库的<code>relay log</code>日志中。<br>(3) Slave还有一个 <code>SQL</code>线程,实时监控<code>relay-log</code>日志内容是否有更新，解析文件中的SQL语句，在Slave数据库中去执行。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231213160912.png"
                     
                ></p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务隔离级别是怎么实现的？</title>
    <url>/p/41447.html</url>
    <content><![CDATA[<p>💿 看了这么多文章，这篇文章是真正的深入浅出</p>
<span id="more"></span>

<blockquote>
<p>摘自<a class="link"   href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html" >小林coding<i class="fas fa-external-link-alt"></i></a>，有所调整</p>
</blockquote>
<p>这是我的钱包，共有 100 万元。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223110151.png"
                      alt="20240223110151"
                ></p>
<p>今天我心情好，我决定给你的转账 100 万，最后的结果肯定是我的余额变为 0 元，你的余额多了 100 万元，是不是想到就很开心？</p>
<p>转账这一动作在程序里会涉及到一系列的操作，假设我向你转账 100 万的过程是有下面这几个步骤组成的：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223110235.png"
                      alt="20240223110235"
                ></p>
<p>可以看到这个转账的过程涉及到了两次修改数据库的操作。</p>
<p>假设在执行第三步骤之后，服务器忽然掉电了，就会发生一个蛋疼的事情，我的账户扣了 100 万，但是钱并没有到你的账户上，也就是说这 <strong>100 万消失了</strong></p>
<p>要解决这个问题，就要保证转账业务里的<strong>所有数据库的操作是不可分割的，要么全部执行成功 ，要么全部失败，不允许出现中间状态的数据</strong>。</p>
<p>数据库中的 <strong>「事务（Transaction）」</strong> 就能达到这样的效果。</p>
<p>我们在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。</p>
<p>没错，今天就来图解 MySQL 事务啦，开车！</p>
<h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p>
<p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，<strong>所以大多数 MySQL 的引擎都是用 InnoDB</strong>。</p>
<p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p>
<ul>
<li><p>原子性（Atomicity）<br>一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</p>
</li>
<li><p>隔离性（Isolation）<br>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时，由于交叉执行而导致数据的不一致。因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</p>
</li>
<li><p>持久性（Durability）<br>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
<li><p>一致性（Consistency）<br>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。<br>比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</p>
</li>
</ul>
<p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p>
<ul>
<li>原子性是通过 undo log（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>持久性是通过 redo log （重做日志）来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>
<p>这次将重点介绍事务的<strong>隔离性</strong>，这也是面试时最常问的知识的点。</p>
<p>为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。</p>
<h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p>
<p>那么在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。</p>
<p>接下来，通过举例子给大家说明，这些问题是如何发生的。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p>
<p>举个栗子。</p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223111032.png"
                      alt="20240223111032"
                ></p>
<p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p>
<p>举个栗子。</p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223111116.png"
                      alt="20240223111116"
                ></p>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p>
<p>举个栗子。</p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223111157.png"
                      alt="20240223111157"
                ></p>
<p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p>
<p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</p>
<h2 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h2><p>前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p>
<p>脏读：读到其他事务未提交的数据；<br>不可重复读：前后读取的数据不一致；<br>幻读：前后读取的记录数量不一致。<br>这三个现象的严重性排序如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223111417.png"
                      alt="20240223111417"
                ></p>
<p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p>
<ul>
<li>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li>可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p>按隔离水平高低排序如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223111425.png"
                      alt="20240223111425"
                ></p>
<p>针对不同的隔离级别，并发事务时<strong>可能</strong>发生的现象也会不同。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223111514.png"
                      alt="20240223111514"
                ></p>
<p>也就是说：</p>
<ul>
<li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li>
<li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li>
<li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li>
<li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li>
<li>所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。</li>
</ul>
<p>不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别，我们讨论的 MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入。</p>
<p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（<strong>注意是很大程度避免，并不是彻底避免</strong>），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。解决的方案有两种：</p>
<ul>
<li><p>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
</li>
<li><p>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</p>
</li>
</ul>
<p>接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223111709.png"
                      alt="20240223111709"
                ></p>
<p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p>
<ul>
<li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li>
<li>在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li>
<li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li>
<li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li>
</ul>
<p>这四种隔离级别具体是如何实现的呢？</p>
<ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View</strong> 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</li>
<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
</ul>
<p><strong>注意</strong>，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，这两种开启事务的命令，事务的启动时机是不同的：</p>
<ul>
<li><p>第一种：begin/start transaction 命令；<br>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；</p>
</li>
<li><p>第二种：start transaction with consistent snapshot 命令；<br>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</p>
</li>
</ul>
<p>接下来详细说下，Read View 在 MVCC 里如何工作的？</p>
<h2 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h2><p>我们需要了解两个知识：</p>
<ul>
<li>Read View 中四个字段作用；</li>
<li>聚簇索引记录中两个跟事务有关的隐藏列；</li>
</ul>
<p>那 Read View 到底是个什么东西？</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223112159.png"
                      alt="20240223112159"
                ></p>
<p>Read View 有四个重要的字段：</p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li>
<li>creator_trx_id ：指的是创建该 Read View 的事务的事务 id。</li>
<li>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</li>
</ul>
<p>假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223112212.png"
                      alt="20240223112212"
                ></p>
<p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，以链表的形式指向每一个旧版本记录，于是就可以通过它找到修改前的记录。</li>
</ul>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li>如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。</li>
<li>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：<ul>
<li>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。</li>
<li>如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。</li>
</ul>
</li>
</ul>
<p>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</p>
<h3 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h3><p>接下来，我们一起了解下实际是如何工作的，可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</p>
<p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223112552.png"
                      alt="20240223112552"
                ></p>
<p>事务 A 和 事务 B 的 Read View 具体内容如下：</p>
<ul>
<li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li>
<li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，活跃的事务 id 中最小的事务 id 是事务 A，下一个事务 id 应该是 53。</li>
</ul>
<p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p>
<ul>
<li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li>
<li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li>
<li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li>
<li>事务 A 提交事务；</li>
<li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li>
</ul>
<p>接下来，跟大家具体分析下。</p>
<p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的，也就是事务 B 可以获取到这条记录。</p>
<p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223112711.png"
                      alt="20240223112711"
                ></p>
<p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。</p>
<p>然后事务 B 第二次去读取该记录，发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id <strong>「小于」</strong>事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p>
<p>最后，当事物 A 提交事务后，由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录。</p>
<p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p>
<h3 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h3><p>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。</p>
<p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p>
<p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：</p>
<ul>
<li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li>
<li>事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；</li>
<li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li>
<li>事务 A 提交事务；</li>
<li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li>
</ul>
<p>那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223112959.png"
                      alt="20240223112959"
                ></p>
<p>我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？</p>
<p>事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p>
<p>我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？<br>与隔离级别为可重复读不同的是，读已提交会在事务 A 提交后，事务 B 在每次读数据的时候，会重新创建 Read View，此时事务 B 第三次读取数据时创建的 Read View 如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240223113136.png"
                      alt="20240223113136"
                ></p>
<p>事务 B 在找到小林这条记录时，会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的。</p>
<p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<p>以上就是Mysql事务隔离级别的理解。</p>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql使用索引的优缺点</title>
    <url>/p/23407.html</url>
    <content><![CDATA[<p>📖 Mysql索引总结一览</p>
<span id="more"></span>

<p><strong>创建索引的优点：</strong></p>
<ol>
<li>提高系统性能。</li>
<li>保证数据唯一性。</li>
<li>加快数据检索速度。</li>
<li>加速表间连接，有助于数据参考完整性。</li>
<li>减少排序和分组操作时间。</li>
</ol>
<p><strong>索引的缺点：</strong></p>
<ol>
<li>创建和维护索引耗费时间，随数据量增加而增加。</li>
<li>占用额外物理空间。</li>
<li>数据增删改时需动态维护索引，降低维护速度。</li>
</ol>
<p><strong>创建索引的准则：</strong></p>
<ul>
<li><p>应创建索引的列：</p>
<ol>
<li>经常需要搜索的列。</li>
<li>作为主键的列。</li>
<li>经常用于连接的列（如外键）。</li>
<li>需要根据范围搜索的列。</li>
<li>经常需要排序的列。</li>
<li>经常用于WHERE子句的列。</li>
</ol>
</li>
<li><p>不应创建索引的列：</p>
<ol>
<li>很少使用的列。</li>
<li>取值很少的列。</li>
<li>定义为text, image和bit数据类型的列。</li>
<li>修改性能远大于检索性能的情况。</li>
</ol>
</li>
</ul>
<p><strong>创建索引的方法：</strong></p>
<ol>
<li>直接创建，如使用CREATE INDEX语句或索引向导。</li>
<li>间接创建，通过定义主键约束或唯一性键约束时自动创建。</li>
</ol>
<p><strong>索引的特征：</strong></p>
<ul>
<li>唯一性索引：保证索引列数据唯一。</li>
<li>复合索引：在两个或多个列上创建的索引。</li>
</ul>
<p><strong>索引的类型：</strong></p>
<ul>
<li>聚簇索引：数据表物理顺序与索引顺序相同。</li>
<li>非聚簇索引：数据表物理顺序与索引顺序不相同。</li>
</ul>
<p><strong>聚簇索引体系结构：</strong></p>
<ul>
<li>类似树状结构，顶部为叶级，其余为非叶级。数据页是叶级，索引页是非叶级。</li>
</ul>
<p><strong>系统如何访问表中的数据：</strong></p>
<ul>
<li>表扫描：逐页扫描直至找到符合条件的记录。</li>
<li>索引查找：沿索引树状结构查找符合条件的记录。</li>
</ul>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql：用覆盖索引解决回表查询</title>
    <url>/p/26485.html</url>
    <content><![CDATA[<p>先要从 InnoDB 的索引实现说起，InnoDB 有两大类索引：</p>
<ul>
<li>聚集索引 (clustered index)</li>
<li>普通索引 (secondary index)</li>
</ul>
<span id="more"></span>

<h2 id="InnoDB-聚集索引和普通索引有什么差异？"><a href="#InnoDB-聚集索引和普通索引有什么差异？" class="headerlink" title="InnoDB 聚集索引和普通索引有什么差异？"></a>InnoDB 聚集索引和普通索引有什么差异？</h2><p>InnoDB 普通索引的叶子节点存储主键值。</p>
<blockquote>
<p>注意：只有 InnoDB 普通索引才存储主键值，MyISAM 的二级索引都是直接指向数据块的。</p>
</blockquote>
<p>InnoDB 聚集索引 的叶子节点存储行记录，因此，InnoDB 必须要有，且只有一个聚集索引：</p>
<ul>
<li>如果表定义了主键，则主键就是聚集索引；</li>
<li>如果表没有定义主键，则第一个 not null 的 unique 列是聚集索引；</li>
<li>否则，InnoDB 会创建一个隐藏的 row-id 作为聚集索引；</li>
</ul>
<blockquote>
<p>注意：所以主键查询非常快，直接定位行记录。</p>
</blockquote>
<p>举个例子，简单设置一张表，设置几条数据进去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE `user`  (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,</span><br><span class="line">  `sex` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,</span><br><span class="line">  `flag` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  INDEX `idx_name`(`name`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">INSERT INTO `user` VALUES (1, &#x27;shenjian&#x27;, &#x27;m&#x27;, &#x27;A&#x27;);</span><br><span class="line">INSERT INTO `user` VALUES (3, &#x27;zhangsan&#x27;, &#x27;m&#x27;, &#x27;A&#x27;);</span><br><span class="line">INSERT INTO `user` VALUES (5, &#x27;lisi&#x27;, &#x27;m&#x27;, &#x27;A&#x27;);</span><br><span class="line">INSERT INTO `user` VALUES (9, &#x27;wangwu&#x27;, &#x27;f&#x27;, &#x27;B&#x27;);</span><br></pre></td></tr></table></figure>


<ul>
<li>id 为主键，聚集索引，叶子节点存储行记录；</li>
<li>name 为索引，普通索引，叶子节点存储主键值，即 id；</li>
</ul>
<p>两个 B+ 树索引分别如图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230529110705.png"
                      width = "550"  align=center 
                ></p>
<p>通常情况下，需要扫码两遍索引树。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE name = &#x27;lisi&#x27;;</span><br></pre></td></tr></table></figure>
<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230529111524.png"
                      width = "550"  align=center 
                >

<p>如粉红色路径，需要扫码两遍索引树：</p>
<ul>
<li>先通过普通索引定位到主键值 id=5；</li>
<li>再通过聚集索引定位到行记录；<br>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><blockquote>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
</blockquote>
<p>我们知道 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h3 id="如何实现索引覆盖？"><a href="#如何实现索引覆盖？" class="headerlink" title="如何实现索引覆盖？"></a>如何实现索引覆盖？</h3><p>常见的方法是：将被查询的字段，建立到联合索引里去（或者说 查询的字段都已经建立了索引）。还是用上边的例子 user 表，我们用 EXPLAIN 关键词分析来看下结果。<br>第一个SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, name FROM user WHERE name=&#x27;shenjian&#x27;;</span><br></pre></td></tr></table></figure>
<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230529112550.png"
                     
                >
能够命中 name 索引，索引叶子节点存储了主键 id，通过 name 的索引树即可获取 id 和 name，无需回表，符合索引覆盖，效率较高。

<p>第二个SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, name, sex FROM user WHERE name=&#x27;shenjian&#x27;;</span><br></pre></td></tr></table></figure>
<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230529113151.png"
                     
                >

<p>能够命中 name 索引，索引叶子节点存储了主键 id，但 sex 字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过 id 值扫码聚集索引获取 sex 字段，效率会降低。<br>如果把 (name) 单列索引升级为联合索引 (name, sex) 就不同了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `user` </span><br><span class="line">DROP INDEX `idx_name`,</span><br><span class="line">ADD INDEX `idx_name`(`name`, `sex`) USING BTREE;</span><br></pre></td></tr></table></figure>
<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230529113530.png"
                     
                >

<p>再次执行，第二个SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, name, sex FROM user WHERE name=&#x27;shenjian&#x27;;</span><br></pre></td></tr></table></figure>
<img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230529113624.png"
                     
                >
能够命中联合索引，索引叶子节点存储了主键 id，通过联合索引的索引树即可获取`name` 和 `sex`，无需回表，符合索引覆盖，效率较高。

<h2 id="MySQL-回表优化"><a href="#MySQL-回表优化" class="headerlink" title="MySQL 回表优化"></a>MySQL 回表优化</h2><p>场景举例：如果按照下边的写法（普遍大家公认写法），当页数达到一个比较大的量级后，可能会变得非常卡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT o1.* FROM orders WHERE sn=&#x27;XD12345678&#x27; LIMIT 10000,10</span><br></pre></td></tr></table></figure>
<p>因为数据表是 InnoDB，根据 InnoDB 索引的结构，查询过程为：</p>
<p>通过二级索引查到主键值（找出所有 sn=’XD12345678’ 的 id)。<br>再根据查到的主键值通过主键索引找到相应的数据块（根据 id 找出对应的数据块内容）。<br>根据 offset 的值，查询 10010 次主键索引的数据，最后将之前的 10000 条丢弃，取出最后 10 条。<br>因为我们要查询 o1.*，前边丢弃的 10000 条数据，经过大量回表操作，造成了大量的 I/O 消耗，浪费了很多性能，导致查询时间变得很长。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT o1.* FROM orders o1</span><br><span class="line">INNER JOIN (SELECT id FROM orders WHERE sn=&#x27;XD12345678&#x27; LIMIT 10000,10) o2</span><br><span class="line">ON o1.id = o2.id;</span><br></pre></td></tr></table></figure>

<p>而这样的写法在 o2 分页查询时根本无需回表只查询 id，最后再做一个内连接根据主键取出数据，虽然增加了 SQL 语句的复杂度，但是性能非常好。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引失效的原因有哪些？</title>
    <url>/p/11477.html</url>
    <content><![CDATA[<p>📚 避免索引失效是一种常见的SQL优化</p>
<span id="more"></span>
<p>MySQL是一种关系型数据库，它可以通过建立索引来提高查询效率。索引是一种数据结构，它可以让数据库快速地找到满足条件的记录，而不需要扫描整张表。但是，并不是所有的查询都能利用索引，有时候索引会失效，导致查询性能下降。那么，MySQL索引失效的原因有哪些呢？如何避免或解决索引失效的问题呢？本文将从以下七个方面来介绍：</p>
<ol>
<li>数据类型不匹配。</li>
</ol>
<p>如果查询条件中的数据类型和索引列的数据类型不一致，MySQL会进行隐式类型转换，这会导致索引失效。例如，如果索引列是varchar类型，而查询条件是数字类型，MySQL会将索引列转换为数字类型进行比较，这样就无法使用索引了。解决方法是保持数据类型的一致性，或者在查询条件中使用显式类型转换。</p>
<ol start="2">
<li>模糊查询以%开头。</li>
</ol>
<p>如果查询条件中使用了like关键字，并且模糊匹配的字符串以%开头，那么也会导致索引失效。这是因为以%开头的模糊匹配无法确定索引列的起始位置，所以无法利用索引进行快速查找。解决方法是尽量避免使用以%开头的模糊匹配，或者使用覆盖索引（只包含索引列的查询）。</p>
<ol start="3">
<li>索引列使用了函数或运算。</li>
</ol>
<p>如果查询条件中对索引列进行了函数调用或运算，那么也会导致索引失效。这是因为函数或运算会改变索引列的值，使得原来的索引无法使用。解决方法是尽量避免对索引列使用函数或运算，或者建立基于函数或运算的索引（MySQL 5.7及以上版本支持）。</p>
<ol start="4">
<li>索引列包含空值。</li>
</ol>
<p>如果索引列中包含空值（NULL），那么在查询条件中使用IS NULL或IS NOT NULL也会导致索引失效。这是因为MySQL在建立索引时不会存储空值，所以无法通过索引来判断是否为空。解决方法是尽量避免让索引列包含空值，或者在建立索引时指定NOT NULL约束。</p>
<ol start="5">
<li>查询条件中使用了OR关键字。</li>
</ol>
<p>如果查询条件中使用了OR关键字，并且OR两边的条件涉及到不同的索引列，那么也会导致索引失效。这是因为MySQL无法同时使用多个索引来进行查询优化，所以只能选择全表扫描。解决方法是尽量避免使用OR关键字，或者将OR两边的条件分别用括号括起来，并且在括号内部使用相同的索引列。</p>
<ol start="6">
<li>联合索引违反了最左前缀原则。</li>
</ol>
<p>如果建立了联合索引（多个列组成的索引），那么在查询条件中必须遵循最左前缀原则，即从左到右依次使用联合索引中的列，不能跳过任何一列。否则，也会导致索引失效。例如，如果建立了（name, age, gender）的联合索引，那么在查询条件中可以使用name，或者name和age，或者name，age和gender，但是不能只使用age或gender，也不能只使用age和gender。解决方法是尽量按照最左前缀原则来使用联合索引，并且将区分度高的列放在前面。</p>
<ol start="7">
<li>全表扫描比使用索引更快。</li>
</ol>
<p>有时候，即使查询条件中完全符合索引的使用条件，MySQL也可能不会使用索引，而是选择全表扫描。这是因为MySQL有一个优化器，它会根据表中的数据量和分布情况，预估使用索引和全表扫描的代价，选择一个更快的方案。例如，如果表中的数据量很小，或者查询条件中的过滤条件很宽松，导致命中的记录很多，那么全表扫描可能比使用索引更快。解决方法是根据实际情况调整查询条件或索引设计，或者强制使用索引（使用FORCE INDEX或USE INDEX提示）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MySQL索引失效是一个常见的性能问题，它会导致查询效率下降，甚至影响整个系统的稳定性。因此，我们需要了解索引失效的原因和解决方法，避免在编写SQL语句时犯一些低级错误。同时，我们也需要定期检查和优化索引的设计和使用情况，确保索引能够发挥最大的作用。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql隔离级别都使用什么锁</title>
    <url>/p/61915.html</url>
    <content><![CDATA[<p>链接：<a class="link"   href="https://zhuanlan.zhihu.com/p/562435658" >https://zhuanlan.zhihu.com/p/562435658<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/sunlong88/p/17523827.html" >https://www.cnblogs.com/sunlong88/p/17523827.html<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="说透-MySQL-锁机制"><a href="#说透-MySQL-锁机制" class="headerlink" title="说透 MySQL 锁机制"></a>说透 MySQL 锁机制</h2><p>在深入探讨不同隔离级别的锁内容之前，我们需要先回顾一下关于 MySQL 锁的本质以及一些基础内容，这样有利于我们后续的理解。<br>对于 MySQL 来说，如果只支持串行访问的话，那么其效率会非常低。因此，为了提高数据库的运行效率，MySQL 需要支持并发访问。而在并发访问的情况下，会发生各种各样的问题，例如：脏读、不可重复读、幻读等问题。为了解决这些问题，就出现了事务隔离级别。<br>本质上，事务隔离级别就是为了解决并发访问下的数据一致性问题的。不同的事务隔离级别，解决了不同程度的数据一致性。而我们所说的全局锁、表锁、行级锁等等，其实都是事务隔离级别的具体实现。而 MVCC、意向锁，则是一些局部的性能优化。</p>
<p>上面这段话，基本上就是对 MySQL 锁机制很透彻的理解。当我们懂了这些概念之间的关系之后，我们才能更加清晰地理解知识点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结<br>看到这里，我想我们可以对文章开头提出的问题做个解答了：MySQL 不同隔离级别，都使用了什么样的锁？<br>对于任何隔离级别，表级别的表锁、元数据锁、意向锁都是会使用的，但对于行级别的锁则会有些许差别。</p>
<ul>
<li>在「读未提交」和「读已提交」隔离级别下，都只会使用<strong>记录锁</strong>，不会用间隙锁，当然也不会有 Next-Key 锁了。</li>
<li>而对于「可重复读」隔离级别来说，会使用记录锁、间隙锁和 Next-Key 锁。</li>
</ul>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务隔离级别</title>
    <url>/p/20720.html</url>
    <content><![CDATA[<p>类比Mysql的事务隔离级别</p>
<span id="more"></span>

<p>①<code>ISOLATION_DEFAULT</code>：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；<br>②<code>ISOLATION_READ_UNCOMMITTED</code>：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；<br>③<code>ISOLATION_READ_COMMITTED</code>：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；<br>④<code>ISOLATION_REPEATABLE_READ</code>：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；<br>⑤<code>ISOLATION_SERIALIZABLE</code>：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：（有其他事务做了回滚）表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读：在同一个事务中，多次读相同的记录但读到了不同的结果。<br>幻读 ：（对查询n条数据做了新增、删除、变更等）指同一个事务内多次范围查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>left join on &amp; where</title>
    <url>/p/e319.html</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>用 <code>where</code> 是先连接然后再筛选   </li>
<li>用 <code>on</code> 是先筛选再连接</li>
<li>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。在使用<code>left jion</code>时，<code>on</code>和<code>where</code>条件的区别如下：<ul>
<li><code>on</code>条件是在生成临时表时使用的条件，它不管<code>on</code>中的条件是否为真，都会返回左边表中的记录。</li>
</ul>
<ul>
<li><code>where</code>条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有<code>left join</code>的含义（<strong>必须返回左边表的记录</strong>）了，条件不为真的就全部过滤掉。<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="假设有两张表："><a href="#假设有两张表：" class="headerlink" title="假设有两张表："></a>假设有两张表：</h3></li>
</ul>
</li>
<li>tab1:</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
</tr>
</tbody></table>
<ul>
<li>tab2:</li>
</ul>
<table>
<thead>
<tr>
<th>size</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>20</td>
<td>BBB</td>
</tr>
<tr>
<td>20</td>
<td>CCC</td>
</tr>
</tbody></table>
<h3 id="两条SQL"><a href="#两条SQL" class="headerlink" title="两条SQL:"></a>两条SQL:</h3><ol>
<li>select * form tab1 left join tab2 on (tab1.size = tab2.size) where tab2.name=’AAA’</li>
<li>select * form tab1 left join tab2 on (tab1.size = tab2.size and tab2.name=’AAA’)<h3 id="第一条SQL的过程："><a href="#第一条SQL的过程：" class="headerlink" title="第一条SQL的过程："></a>第一条SQL的过程：</h3></li>
<li>中间表<br>on条件:<br>tab1.size = tab2.size</li>
</ol>
<table>
<thead>
<tr>
<th><code>tab1.id</code></th>
<th><code>tab1.size</code></th>
<th><code>tab2.size</code></th>
<th><code>tab2.name</code></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>20</td>
<td>BBB</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>20</td>
<td>CCC</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
<td>(null)</td>
<td>(null)</td>
</tr>
<tr>
<td>2. 再对中间表进行过滤</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>where条件:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>tab2.name</code> = ’AAA’</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>tab1.id</code></th>
<th><code>tab1.size</code></th>
<th><code>tab2.size</code></th>
<th><code>tab2.name</code></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
</tbody></table>
<h3 id="第二条SQL的过程："><a href="#第二条SQL的过程：" class="headerlink" title="第二条SQL的过程："></a>第二条SQL的过程：</h3><ol>
<li>中间表<br>on条件:<br>tab1.size = tab2.size and tab2.name=’AAA’<br>(<em>条件不为真也会返回左表中的记录</em>)</li>
</ol>
<table>
<thead>
<tr>
<th><code>tab1.id</code></th>
<th><code>tab1.size</code></th>
<th><code>tab2.size</code></th>
<th><code>tab2.name</code></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>(null)</td>
<td>(null)</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
<td>(null)</td>
<td>(null)</td>
</tr>
</tbody></table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>其实以上结果的关键原因就是left join,right join,full join的特殊性，<strong>不管on上的条件是否为真都会返回left或right表中的记录</strong>，full则具有left和right的特性的并集。 而inner jion没这个特殊性，则条件放在on中和where中，返回的结果集是相同的。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql误删一张表</title>
    <url>/p/6ca7.html</url>
    <content><![CDATA[<blockquote>
<p>大家开发过程中，难免会存在误删数据库表的情况，可见，数据库的备份机制需要引起大家的重视，本文主要介绍一下，拥有备份文件（.frm 和 .ibd）的情况下，如何快速恢复该表。</p>
</blockquote>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>作者使用的正式数据库是阿里云的rds，一天午后，使用navicat工具误操作删除了一张日志表，但幸运的是，设置了阿里云的备份机制。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li>首先从阿里云备份记录中下载最新的备份tar或者zip文件，然后解压会得到数据库中的文件，找到该日志表对应的.frm和.ibd。<br><a name="back"></a></li>
<li>查看被删除数据库版本和恢复至的数据库版本是否一致，如果一致请继续，如果不一致，请<a href='#fn1b'>查看下面</a>的版本不一致问题如何解决；</li>
<li>新建一个数据库（名称任意），在该数据库中新建一张表（名称与你要恢复的表名称相同），最好结构也有，数据无所谓，引擎必须是innode，然后删除新建的表空间: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除该表的.idb</span><br><span class="line">ALTER TABLE table_name DISCARD TABLESPACE;</span><br></pre></td></tr></table></figure></li>
<li>再将该表对应的 .ibd 备份文件替换新表的.ibd文件（/var/lib/mysql/test  这是test数据库的文件目录），执行如下命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改权限</span><br><span class="line">chown mysql:mysql tablename.ibd</span><br></pre></td></tr></table></figure></li>
<li>重新导入表空间  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table &lt;table name&gt; import tablespace;</span><br></pre></td></tr></table></figure>
<a name='fn1b'></a><br>这一步可能出现版本问题，因为之前版本的数据库是5.6，新的数据库是5.7<ul>
<li>版本的解决办法<br><img  
                     lazyload
                     alt="image"
                     data-src="/images/mysql/version_wrong.png"
                      alt="pic"
                ><br>究其原因是从MySQL5.7版本中innodb_file_format参数（该参数表示innodb文件格式）的默认值发生了变化，在MySQL5.7以前innodb_file_format参数默认是Antelope，而默认的行格式是（ROW_FORMAT）是COMPACT，从MySQL5.7以后版本innodb_file_format默认值为Barracuda，默认的行格式是（ROW_FORMAT）是DYNAMIC，所以需要在创建表结构时指定row_format=compact<br>因此我们需要重新建一张表</li>
</ul>
</li>
</ul>
<ol>
<li>在新库中删除对应的表，并删除新库中存在的数据文件（/var/lib/mysql/test）；</li>
<li>创建新的表结构并指定行格式为compact。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tablename` (</span><br><span class="line">  ...</span><br><span class="line">) ROW_FORMAT=COMPACT</span><br></pre></td></tr></table></figure>
之后的步骤<a href="#back">继续执行上面的步骤</a></li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql函数之FIND_IN_SET()</title>
    <url>/p/f887.html</url>
    <content><![CDATA[<blockquote>
<p><a class="link"   href="https://www.fujieace.com/mysql/functions/find_in_set.html" >详情链接<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>FIND_IN_SET(str,strlist)</p>
<p>第一个参数str是要查找的字符串。<br>第二个参数strlist是要搜索的<strong>逗号分隔</strong>的字符串列表。</p>
<p>假如字符串str 在由N 子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。一个字符串列表就是一个由一些被‘,’符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则 FIND_IN_SET() 函数被优化，使用比特计算。如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。<em>这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</em></p>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>现在有一张users表，如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>user_name</th>
<th>emails</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小张</td>
<td><a class="link"   href="mailto:&#97;&#64;&#102;&#x75;&#x6a;&#x69;&#x65;&#x61;&#99;&#x65;&#x2e;&#x63;&#x6f;&#x6d;" >&#97;&#64;&#102;&#x75;&#x6a;&#x69;&#x65;&#x61;&#99;&#x65;&#x2e;&#x63;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a>,b@fujieace.com,<a class="link"   href="mailto:&#x63;&#64;&#102;&#117;&#106;&#105;&#x65;&#x61;&#99;&#x65;&#x2e;&#x63;&#111;&#x6d;" >&#x63;&#64;&#102;&#117;&#106;&#105;&#x65;&#x61;&#99;&#x65;&#x2e;&#x63;&#111;&#x6d;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>2</td>
<td>小王</td>
<td><a class="link"   href="mailto:&#97;&#x61;&#64;&#102;&#x75;&#106;&#x69;&#101;&#x61;&#x63;&#x65;&#46;&#x63;&#111;&#x6d;" >&#97;&#x61;&#64;&#102;&#x75;&#106;&#x69;&#101;&#x61;&#x63;&#x65;&#46;&#x63;&#111;&#x6d;<i class="fas fa-external-link-alt"></i></a>,bb@fujieace.com,<a class="link"   href="mailto:&#99;&#x63;&#64;&#x66;&#117;&#x6a;&#x69;&#x65;&#x61;&#99;&#101;&#46;&#x63;&#x6f;&#109;" >&#99;&#x63;&#64;&#x66;&#117;&#x6a;&#x69;&#x65;&#x61;&#99;&#101;&#46;&#x63;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>3</td>
<td>李四</td>
<td><a class="link"   href="mailto:&#x61;&#x61;&#64;&#x66;&#117;&#106;&#105;&#x65;&#97;&#x63;&#x65;&#x2e;&#x63;&#x6f;&#109;" >&#x61;&#x61;&#64;&#x66;&#117;&#106;&#105;&#x65;&#97;&#x63;&#x65;&#x2e;&#x63;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a>,b@fujieace.com,<a class="link"   href="mailto:&#100;&#x40;&#102;&#x75;&#106;&#105;&#x65;&#97;&#x63;&#101;&#x2e;&#x63;&#x6f;&#109;" >&#100;&#x40;&#102;&#x75;&#106;&#105;&#x65;&#97;&#x63;&#101;&#x2e;&#x63;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>4</td>
<td>王五</td>
<td><a class="link"   href="mailto:&#x61;&#97;&#x40;&#x66;&#x75;&#x6a;&#x69;&#x65;&#97;&#99;&#x65;&#46;&#x63;&#111;&#109;" >&#x61;&#97;&#x40;&#x66;&#x75;&#x6a;&#x69;&#x65;&#97;&#99;&#x65;&#46;&#x63;&#111;&#109;<i class="fas fa-external-link-alt"></i></a>,e@fujieace.com,<a class="link"   href="mailto:&#x66;&#x40;&#x66;&#x75;&#x6a;&#x69;&#x65;&#x61;&#99;&#x65;&#46;&#99;&#111;&#109;" >&#x66;&#x40;&#x66;&#x75;&#x6a;&#x69;&#x65;&#x61;&#99;&#x65;&#46;&#99;&#111;&#109;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>问：我们如何用sql查找所有“emails”字段中有“<a class="link"   href="mailto:&#97;&#97;&#x40;&#x66;&#x75;&#106;&#105;&#x65;&#97;&#x63;&#x65;&#46;&#x63;&#x6f;&#x6d;" >&#97;&#97;&#x40;&#x66;&#x75;&#106;&#105;&#x65;&#97;&#x63;&#x65;&#46;&#x63;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a>”的用户？</p>
<p>答：用以下sql即可实现；</p>
<p>select * from users where FIND_IN_SET(‘aa@fujieace.com’,emails);</p>
<h2 id="拓展知识："><a href="#拓展知识：" class="headerlink" title="拓展知识："></a>拓展知识：</h2><p>mysql&gt; SELECT FIND_IN_SET(‘b’,’a,b,c,d’);<br>-&gt; 2<br>因为：b 在strlist集合中放在2的位置，计算从1开始，不是从0开始；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select FIND_IN_SET(&#x27;1&#x27;,&#x27;1&#x27;);</span><br></pre></td></tr></table></figure>
<p>返回值：就是1；<br>这时候的strlist集合有点特殊，只有一个字符串，其实就是要求前一个字符串一定要在后一个字符串集合中才返回 大于0的数；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select FIND_IN_SET(&#x27;2&#x27;,&#x27;1，2&#x27;);返回2</span><br><span class="line">select FIND_IN_SET(&#x27;6&#x27;,&#x27;1&#x27;); 返回0</span><br></pre></td></tr></table></figure>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>select * from fujieace where FIND_IN_SET(id,’1,2,3,4,5’);<br>使用find_in_set函数一次返回多条记录,id 是一个表的字段 然后每条记录分别是id等于1，2，3，4，5的时候,有点类似in （集合）,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from fujieace where id in (1,2,3,4,5);</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote>
<p>详情：<a class="link"   href="https://www.cnblogs.com/xiaoxi/p/5942805.html" >根据父id递归查询子列表<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DEFINER=`用户名`@`%` FUNCTION `方法名`(rootId INT) RETURNS varchar(1000) CHARSET utf8</span><br><span class="line">BEGIN </span><br><span class="line">        DECLARE sTemp VARCHAR(1000); </span><br><span class="line">        DECLARE sTempChd VARCHAR(1000); </span><br><span class="line"></span><br><span class="line">        SET sTemp = &#x27;^&#x27;; </span><br><span class="line">        SET sTempChd =cast(rootId as CHAR); </span><br><span class="line"> </span><br><span class="line">        WHILE sTempChd is not null DO </span><br><span class="line">            SET sTemp = concat(sTemp,&#x27;,&#x27;,sTempChd); </span><br><span class="line">            SELECT group_concat(id) INTO sTempChd FROM goods_category c where FIND_IN_SET(c.parent_id,sTempChd)&gt;0; </span><br><span class="line">        END WHILE; </span><br><span class="line">        RETURN sTemp; </span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://blog.csdn.net/dream_broken/article/details/69554303" >问题：组合递归函数数据不全<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用操作</title>
    <url>/p/72bf.html</url>
    <content><![CDATA[<h2 id="查询数据库所有的表"><a href="#查询数据库所有的表" class="headerlink" title="查询数据库所有的表"></a>查询数据库所有的表</h2><p>（用逗号隔开）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT GROUP_CONCAt( table_name ) FROM information_schema.TABLES WHERE table_schema = &#x27;数据库名&#x27; AND table_type = &#x27;base table&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="查询数据库中某张表所有的字段"><a href="#查询数据库中某张表所有的字段" class="headerlink" title="查询数据库中某张表所有的字段"></a>查询数据库中某张表所有的字段</h2><p>（用逗号隔开）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT GROUP_CONCAT( column_name ) FROM information_schema.COLUMNS WHERE table_name = &#x27;表名&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="计算两个经纬度之间的距离-lon经度，lat纬度"><a href="#计算两个经纬度之间的距离-lon经度，lat纬度" class="headerlink" title="计算两个经纬度之间的距离,lon经度，lat纬度"></a>计算两个经纬度之间的距离,lon经度，lat纬度</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DEFINER=`lkhd`@`%` FUNCTION `func_distance`( </span><br><span class="line">lon1 DOUBLE, </span><br><span class="line">lat1 DOUBLE, </span><br><span class="line">lon2 DOUBLE, </span><br><span class="line">lat2 DOUBLE </span><br><span class="line">) RETURNS double</span><br><span class="line">RETURN 6371 * acos( </span><br><span class="line">cos(radians(lat1)) * cos(radians(lat2)) * cos( </span><br><span class="line">radians(lon2) - radians(lon1) </span><br><span class="line">) + sin(radians(lat1)) * sin(radians(lat2)) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql日期相关</title>
    <url>/p/3816.html</url>
    <content><![CDATA[<h2 id="DATE-ADD-date-expr-type"><a href="#DATE-ADD-date-expr-type" class="headerlink" title="DATE_ADD(date,expr,type)"></a>DATE_ADD(date,expr,type)</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><p>函数向日期添加指定的时间间隔</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>date 参数是合法的日期表达式。expr 参数是您希望添加的时间间隔。<br>type 参数可以常用下列值：</p>
<table>
<thead>
<tr>
<th>Type值</th>
</tr>
</thead>
<tbody><tr>
<td>SECOND</td>
</tr>
<tr>
<td>MINUTE</td>
</tr>
<tr>
<td>HOUR</td>
</tr>
<tr>
<td>DAY</td>
</tr>
<tr>
<td>WEEK</td>
</tr>
<tr>
<td>MONTH</td>
</tr>
<tr>
<td>QUARTER</td>
</tr>
<tr>
<td>YEAR</td>
</tr>
</tbody></table>
<h2 id="TIMESTAMPDIFF-interval-datetime-expr1-datetime-expr2"><a href="#TIMESTAMPDIFF-interval-datetime-expr1-datetime-expr2" class="headerlink" title="TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2)"></a>TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2)</h2><h3 id="定义和用法-1"><a href="#定义和用法-1" class="headerlink" title="定义和用法"></a>定义和用法</h3><p>Mysql计算两个日期的时间差函数</p>
<p>其结果的单位由<code>interval</code> 参数给出,该参数必须是以下值的其中一个： <code>FRAC_SECOND</code>、<code>SECOND</code>、 <code>MINUTE</code>、 <code>HOUR</code>、 <code>DAY</code>、 <code>WEEK</code>、 <code>MONTH</code>、 <code>QUARTER</code>或 <code>YEAR</code>。</p>
<h2 id="查询当天、本周，本月，上一个月的数据"><a href="#查询当天、本周，本月，上一个月的数据" class="headerlink" title="查询当天、本周，本月，上一个月的数据"></a>查询当天、本周，本月，上一个月的数据</h2><ul>
<li>今天<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where to_days(时间字段名) = to_days(now());</span><br></pre></td></tr></table></figure></li>
<li>昨天<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) &lt;= 1</span><br></pre></td></tr></table></figure></li>
<li>近7天<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(时间字段名)</span><br></pre></td></tr></table></figure></li>
<li>近30天<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(时间字段名)</span><br></pre></td></tr></table></figure></li>
<li>本月<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, &#x27;%Y%m&#x27; ) = DATE_FORMAT( CURDATE( ) , &#x27;%Y%m&#x27; )</span><br></pre></td></tr></table></figure></li>
<li>上一月<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , &#x27;%Y%m&#x27; ) , date_format( 时间字段名, &#x27;%Y%m&#x27; ) ) =1</span><br></pre></td></tr></table></figure></li>
<li>查询本季度数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from `ht_invoice_information` where QUARTER(create_date)=QUARTER(now());</span><br></pre></td></tr></table></figure></li>
<li>查询上季度数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from `ht_invoice_information` where QUARTER(create_date)=QUARTER(DATE_SUB(now(),interval 1 QUARTER));</span><br></pre></td></tr></table></figure></li>
<li>查询本年数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from `ht_invoice_information` where YEAR(create_date)=YEAR(NOW());</span><br></pre></td></tr></table></figure></li>
<li>查询上年数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from `ht_invoice_information` where year(create_date)=year(date_sub(now(),interval 1 year));</span><br></pre></td></tr></table></figure></li>
<li>查询当前这周的数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,&#x27;%Y-%m-%d&#x27;)) = YEARWEEK(now());</span><br></pre></td></tr></table></figure></li>
<li>查询上周的数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,&#x27;%Y-%m-%d&#x27;)) = YEARWEEK(now())-1;</span><br></pre></td></tr></table></figure></li>
<li>查询上个月的数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,submittime from enterprise where date_format(submittime,&#x27;%Y-%m&#x27;)=date_format(DATE_SUB(curdate(), INTERVAL 1 MONTH),&#x27;%Y-%m&#x27;)</span><br><span class="line"></span><br><span class="line">select * from user where DATE_FORMAT(pudate,&#x27;%Y%m&#x27;) = DATE_FORMAT(CURDATE(),&#x27;%Y%m&#x27;) ; </span><br><span class="line"></span><br><span class="line">select * from user where WEEKOFYEAR(FROM_UNIXTIME(pudate,&#x27;%y-%m-%d&#x27;)) = WEEKOFYEAR(now()) </span><br><span class="line"></span><br><span class="line">select * from user where MONTH(FROM_UNIXTIME(pudate,&#x27;%y-%m-%d&#x27;)) = MONTH(now()) </span><br><span class="line"></span><br><span class="line">select * from user where YEAR(FROM_UNIXTIME(pudate,&#x27;%y-%m-%d&#x27;)) = YEAR(now()) and MONTH(FROM_UNIXTIME(pudate,&#x27;%y-%m-%d&#x27;)) = MONTH(now()) </span><br><span class="line"></span><br><span class="line">select * from user where pudate between  上月最后一天  and 下月第一天 </span><br></pre></td></tr></table></figure></li>
<li>查询当前月份的数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,submittime from enterprise   where date_format(submittime,&#x27;%Y-%m&#x27;)=date_format(now(),&#x27;%Y-%m&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>查询距离当前现在6个月的数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,submittime from enterprise where submittime between date_sub(now(),interval 6 month) and now();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关注获取更多资源<br><img  
                     lazyload
                     alt="image"
                     data-src="https://i.ibb.co/hZ4TbWB/coderxm-qr.jpg"
                      alt="公众号"
                ></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引优化初体验-了解索引</title>
    <url>/p/aab3.html</url>
    <content><![CDATA[<h1 id="Mysql的历史"><a href="#Mysql的历史" class="headerlink" title="Mysql的历史"></a>Mysql的历史</h1><p>简单回顾一下Mysql的历史，Mysql 是一个关系型数据库管理系统，由瑞典 Mysql AB 公司开发，目前属于 Oracle 公司。关系型数据库​将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<span id="more"></span>

<h1 id="Mysql的优势"><a href="#Mysql的优势" class="headerlink" title="Mysql的优势"></a>Mysql的优势</h1><ul>
<li>Mysql 是开源的，所以你不需要支付额外的费用。</li>
<li>Mysql 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>Mysql 使用标准的 SQL 数据语言形式。</li>
<li>Mysql 可以运行于多个系统上，并且支持多种语言。</li>
<li>Mysql 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 Mysql 系统。</li>
</ul>
<h1 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h1><p>索引是在MYSQL的存储引擎层中实现的，而不是在服务层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MYSQL目前提供了一下4种索引。</p>
<h2 id="Normal-普通索引"><a href="#Normal-普通索引" class="headerlink" title="Normal 普通索引"></a>Normal 普通索引</h2><p>基本的索引类型，大多数情况下都可以使用。</p>
<h2 id="Unique-唯一索引"><a href="#Unique-唯一索引" class="headerlink" title="Unique 唯一索引"></a>Unique 唯一索引</h2><p>表示唯一的，不允许重复的索引，如果该字段信息保证不会重复，例如身份证号用作索引时，可设置为unique。Unique和Primary Key为列或列集合提供了唯一性的保证，Primary Key是拥有自动定义的Unique约束，但是每个表中可以有多个Unique约束，但是只能有一个Primary Key约束。</p>
<h2 id="Full-Text-全文索引"><a href="#Full-Text-全文索引" class="headerlink" title="Full Text 全文索引"></a>Full Text 全文索引</h2><p>全文索引可以在varchar、char、text类型的列上创建。MyISAM支持全文索引，InnoDB在mysql5.6之后支持了全文索引。FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。</p>
<h2 id="SPATIAL-空间索引"><a href="#SPATIAL-空间索引" class="headerlink" title="SPATIAL 空间索引"></a>SPATIAL 空间索引</h2><p>空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY(几何)、POINT(点)、LINESTRING(线)、POLYGON(多边形)。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。</p>
<h1 id="我对索引的一些看法"><a href="#我对索引的一些看法" class="headerlink" title="我对索引的一些看法"></a>我对索引的一些看法</h1><ul>
<li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</li>
<li>数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。</li>
<li>最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。</li>
<li>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</li>
<li>当你发现自己的查询速度慢的时候，最快解决问题的方法就是使用索引。索引的使用是影响查询速度的重要因素。在使用索引之前其他的优化查询的动作纯粹是浪费时间，只有合理地使用索引之后，才有必要考虑其他优化方式。</li>
</ul>
<p>索引相关的概念先到这里，后续会针对索引的实际应用和大家一起继续交流。</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引优化初体验-使用索引</title>
    <url>/p/3fc1.html</url>
    <content><![CDATA[<blockquote>
<p>上回介绍了几种常见的索引类型：normal、unique、fulltext、spatial，本次，主要讲解索引的工作原理及针对normal索引的创建、删除进行举例。</p>
</blockquote>
<h1 id="索引是如何工作的"><a href="#索引是如何工作的" class="headerlink" title="索引是如何工作的"></a>索引是如何工作的</h1><span id="more"></span>
<p>首先，我们先创建t_user_action_log表，方便下面进行演示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t_user_action_log` (</span><br><span class="line">  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">  `name` VARCHAR(32) DEFAULT NULL COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `ip_address` VARCHAR(50) DEFAULT NULL COMMENT &#x27;IP地址&#x27;,</span><br><span class="line">  `action` INT4 DEFAULT NULL COMMENT &#x27;操作：1-登录，2-登出，3-购物，4-退货，5-浏览&#x27;,</span><br><span class="line">  `create_time` TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>假如我们要筛选 action为2的所有记录，SQL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id, name, ip_address FROM t_user_action_log WHERE `action`=2;</span><br></pre></td></tr></table></figure>

<p>通过查询分析器explain分析这条查询语句(就在这个语句前面加上<strong>explain</strong>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, name, ip_address FROM t_user_action_log WHERE `action`=2;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user_action_log</td>
<td></td>
<td>ALL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>100.00</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>其中type为ALL表示要进行全表扫描。这样效率无疑是极慢的。</p>
<p>下面为action列添加索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user_action_log ADD INDEX (`action`);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再次执行查询分析，结果如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user_action_log</td>
<td></td>
<td>ref</td>
<td>action</td>
<td>action</td>
<td>5</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td></td>
</tr>
</tbody></table>
<p>我们看到这次查询就使用索引了。加索引前Extra的值是Using Where，type的值为ALL，加索引后Extra的值为空，type的值为ref，表示使用引用。</p>
<p>那么为什么索引会提高查询速度呢？原因是索引会根据索引值进行分类，这样就不用再进行全表扫描了。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/07/04/ZaPAKI.png"
                      alt="示意图"
                ></p>
<p>比如上图，action值为2的索引值分类存储在了索引空间，可以快速地查询到索引值所对应的列。</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>下面介绍一下如何使用SQL创建、查看和删除索引。</p>
<p>创建索引的三种方式：</p>
<h2 id="使用CREATE-INDEX创建，语法如下："><a href="#使用CREATE-INDEX创建，语法如下：" class="headerlink" title="使用CREATE INDEX创建，语法如下："></a>使用CREATE INDEX创建，语法如下：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexName ON tableName (columnName(length));</span><br></pre></td></tr></table></figure>

<p>例如我们对ip_address这一列创建一个长度为16的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_ip_addr ON t_user_action_log (ip_address(16));</span><br></pre></td></tr></table></figure>

<h2 id="使用ALTER语句创建，语法如下："><a href="#使用ALTER语句创建，语法如下：" class="headerlink" title="使用ALTER语句创建，语法如下："></a>使用ALTER语句创建，语法如下：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName ADD INDEX indexName(columnName);</span><br></pre></td></tr></table></figure>

<p>ALTER语句创建索引前面已经有例子了。下面提供一个设置索引长度的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user_action_log ADD INDEX ip_address_idx (ip_address(16));</span><br></pre></td></tr></table></figure>


<h2 id="建表的时候创建索引："><a href="#建表的时候创建索引：" class="headerlink" title="建表的时候创建索引："></a>建表的时候创建索引：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tableName(  </span><br><span class="line">  id INT NOT NULL,   </span><br><span class="line">  columnName  columnType,</span><br><span class="line">  INDEX [indexName] (columnName(length))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><p>可以通过show语句查看索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM t_user_action_log;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Table</th>
<th>Non_unique</th>
<th>Key_name</th>
<th>Seq_in_index</th>
<th>Column_name</th>
<th>Collation</th>
<th>Cardinality</th>
<th>Sub_part</th>
<th>Packed</th>
<th>Null</th>
<th>Index_type</th>
<th>Comment</th>
<th>Index_comment</th>
</tr>
</thead>
<tbody><tr>
<td>t_user_action_log</td>
<td>0</td>
<td>PRIMARY</td>
<td>1</td>
<td>id</td>
<td>A</td>
<td>199,368</td>
<td></td>
<td></td>
<td></td>
<td>BTREE</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t_user_action_log</td>
<td>1</td>
<td>action</td>
<td>1</td>
<td>action</td>
<td>A</td>
<td>4</td>
<td></td>
<td></td>
<td>YES</td>
<td>BTREE</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t_user_action_log</td>
<td>1</td>
<td>index_ip_addr</td>
<td>1</td>
<td>ip_address</td>
<td>A</td>
<td>1</td>
<td>16</td>
<td></td>
<td>YES</td>
<td>BTREE</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>使用ALTER命令可以删除索引，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user_action_log DROP INDEX index_ip_addr;</span><br></pre></td></tr></table></figure>


<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>「日志」Navicat统计的行数竟然和表实际行数不一致？！</title>
    <url>/p/8868.html</url>
    <content><![CDATA[<p>细心的同学应该早已发现这个问题啦！</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近期为了保障线上数据库的稳定性，我决定针对一些大表的历史数据有计划地进行备份迁移，但是呢，发现一个奇特的现象，Navicat统计行数和表自身count统计数竟然不一致！？0.0</p>
<h2 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h2><p>Navicat作为数据库管理工具，在业界广受欢迎，先甭管你电脑上现在正在运行的Navicat是正版还是盗版（你不说我也知道），不可否认的是，在我从事17年从事后端开发以来，尝试了很多同类工具，Navicat在功能上完全碾压其他数据库管理工具，尤其是细节方面，在这里不一一列举了，总之一个字，就是很好用（不接受反驳，除非你说出来一个让我心服口服的工具）。</p>
<h2 id="整个经过"><a href="#整个经过" class="headerlink" title="整个经过"></a>整个经过</h2><p>这次大表迁移备份，我的整体思路是：首先用Navicat对库内所有的表按照行数降序排序，然后选取Top10进行迁移备份。但是一如既往细心的我发现，它界面的统计行数竟然和我自己count这张表行数不一致？！难道要颠覆我对Navicat的认可嘛。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20211201221801.png"
                     
                ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(1) from big_table_name;</span><br></pre></td></tr></table></figure>

<h2 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h2><p>这让我很是诧异，一度以为自己出现了幻觉，再三确认自己没有带VR眼镜后，我踏上了寻找答案的征程。我开始思考，Mysql作为一个数据库，自身肯定就有各个表的统计，而Navicat只是作为一个可视化界面，让数据肉眼可见。</p>
<blockquote>
<p>Navicat：这锅我可不背。</p>
</blockquote>
<p>为了证实我的猜想，我查阅了官方文档及其他相关资料，果然，MySQL 在 <code>information_schema.TABLES</code>表中息存放了所有表的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from information_schema.TABLES;</span><br></pre></td></tr></table></figure>
<p>查看了这张表以后，发现表里统计记录<code>TABLE_ROWS</code>字段的确实与事实count不符……</p>
<h2 id="这又是为什么呢？"><a href="#这又是为什么呢？" class="headerlink" title="这又是为什么呢？"></a>这又是为什么呢？</h2><p>我又陷入了沉思，带着疑惑，继续翻阅着文档，突然，看到MySQL官方文档对<code>TABLE_ROWS</code>的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The number of rows. Some storage engines, such as MyISAM, store the exact count. For other storage engines, such as InnoDB, this value is an approximation, and may vary from the actual value by as much as 40% to 50%. In such cases, use SELECT COUNT(*) to obtain an accurate count.</span><br></pre></td></tr></table></figure>

<p>看了这段话我顿悟啦，你是不是也明白怎么回事啦。什么？你没看太明白？好吧，没关系，你可能需要通过翻译软件的直译+理解，才懂得其中真正的含义。原来，<code>TABLE_ROWS</code>这个字段不同存储引擎的计数规则不一致，比如MyISAM引擎这表存储<code>TABLE_ROWS</code>存储的就是精确的行数，而对于其他的存储引擎，比如 InnoDB，这个值只是一个近似值，与实际值相差40%-50%左右。所以，在这种情况下，我们想要得到一个准确的计数，只能使用 SELECT COUNT(*) 来获得。</p>
<h2 id="那又如何修正呢？"><a href="#那又如何修正呢？" class="headerlink" title="那又如何修正呢？"></a>那又如何修正呢？</h2><p>虽然疑惑得到了解答。但，和我一样有强迫症的朋友肯定会问，如何修正这个值呢？真是知道越多，未知越多，网上说可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Analyze table big_table_name</span><br></pre></td></tr></table></figure>

<p>得以更正这个数据，但是我动手执行之后发现，并不能更正数据，且该操作不仅耗时还会锁表，并不推荐使用……说到这，我的强迫症竟然不治自愈了。<br>朋友，你有更好的办法嘛？欢迎留言。<br>请关注微信公众号：程序员小明！！！<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Navicat</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常用API总结【小白必看】</title>
    <url>/p/10018.html</url>
    <content><![CDATA[<p>☀️ 人生苦短，我用Python</p>
<span id="more"></span>
<h2 id="操作文件夹及文件相关"><a href="#操作文件夹及文件相关" class="headerlink" title="操作文件夹及文件相关"></a>操作文件夹及文件相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">path = &#x27;/your/heart&#x27;</span><br><span class="line"># 不会对父目录创建</span><br><span class="line">os.mkdir(path)</span><br><span class="line"># 会创建父目录</span><br><span class="line">os.makedirs(path)</span><br><span class="line"></span><br><span class="line"># 文件绝对路径</span><br><span class="line">current_file_path = __file__</span><br><span class="line"># 借助dirname()从绝对路径中提取目录</span><br><span class="line">current_file_dir = os.path.dirname(current_file_path)</span><br><span class="line"></span><br><span class="line"># 类似地可以借助basename()从绝对路径中提取文件名</span><br><span class="line">current_filename = os.path.basename(current_file_path)</span><br><span class="line"></span><br><span class="line"># 使用os.path.join()来实现路径拼接，这样不用自己再关注路径分隔符的问题，可以拼接多个参数</span><br><span class="line">current_file_path = os.path.join(current_file_dir, current_filename)</span><br><span class="line"></span><br><span class="line"># 计算绝对路径，比如输入`/pic/../video/xx.mp4`</span><br><span class="line">os.path.abspath(path) # 输出`/video/xx.mp4`</span><br><span class="line"></span><br><span class="line"># 计算某个路径的相对路径</span><br><span class="line">full_path = &#x27;/pic/2022/xx.jpg&#x27;</span><br><span class="line">base_path = &#x27;/pic&#x27;</span><br><span class="line">print(os.path.relpath(full_path, base_path)) #输出 2022/xx.jpg</span><br></pre></td></tr></table></figure>

<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python更换国内镜像源</title>
    <url>/p/57739.html</url>
    <content><![CDATA[<p>更换镜像源之后，包下载飞一般的速度！</p>
<span id="more"></span>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20221215002452.png"
                     
                ></p>
<h2 id="镜像地址替换"><a href="#镜像地址替换" class="headerlink" title="镜像地址替换"></a>镜像地址替换</h2><p>场景：解决包下载慢的问题</p>
<h3 id="永久换源"><a href="#永久换源" class="headerlink" title="永久换源"></a>永久换源</h3><p>清华源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>会提示写入<code>~/.config/pip/pip.conf</code>写入配置(Mac下)</p>
<p>其他源<br>阿里源: <a class="link"   href="https://mirrors.aliyun.com/pypi/simple/" >https://mirrors.aliyun.com/pypi/simple/<i class="fas fa-external-link-alt"></i></a><br>腾讯源: <a class="link"   href="http://mirrors.cloud.tencent.com/pypi/simple" >http://mirrors.cloud.tencent.com/pypi/simple<i class="fas fa-external-link-alt"></i></a><br>豆瓣源: <a class="link"   href="http://pypi.douban.com/simple/" >http://pypi.douban.com/simple/<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="恢复默认源"><a href="#恢复默认源" class="headerlink" title="恢复默认源"></a>恢复默认源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip config unset global.index-url</span><br></pre></td></tr></table></figure>

<h3 id="临时换源"><a href="#临时换源" class="headerlink" title="临时换源"></a>临时换源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install 包名 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下安装chromedriver</title>
    <url>/p/57219.html</url>
    <content><![CDATA[<p>当你要使用网页自动化测试、控制浏览器操作等等，chromedriver就派上用场了</p>
<span id="more"></span>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20221215002452.png"
                     
                ></p>
<ol>
<li><p>在浏览器打开网址：<a class="link"   href="https://chromedriver.chromium.org/downloads" >https://chromedriver.chromium.org/downloads<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>查看自己的浏览器版本<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20221215001637.png"
                     
                ></p>
</li>
<li><p>对应下载<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20221215001717.png"
                     
                ><br>根据自己的系统版本下载<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20221215001600.png"
                     
                ></p>
</li>
<li><p>将解压后的chromedriver放到bin目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open /usr/local/bin</span><br></pre></td></tr></table></figure>
<p>将下载好chromedriver的拖进去</p>
</li>
<li><p>如果在运行的过程中提示：无法打开“chromedriver”，因为无法验证开发者， 是因为mac 不信任我们下载下来的 chromedriver 文件，打开安全隐私模式，添加信任就可以了。<br>进入chromedriver存放目录，我这里是/usr/local/bin<br>在终端输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xattr -d com.apple.quarantine chromedriver</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务管理及失效总结</title>
    <url>/p/5122.html</url>
    <content><![CDATA[<h2 id="Spring-事务管理及失效总结"><a href="#Spring-事务管理及失效总结" class="headerlink" title="Spring 事务管理及失效总结"></a>Spring 事务管理及失效总结</h2><p>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。  </p>
<p>Spring 并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给 Hibernate 或者 JTA 等持久化机制所提供的相关平台框架的事务来实现。  </p>
<p> Spring 事务管理器接口： <code>org.springframework.transaction.PlatformTransactionManager</code> ，通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager) 等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<h3 id="Spring-事务的分类"><a href="#Spring-事务的分类" class="headerlink" title="Spring 事务的分类"></a>Spring 事务的分类</h3><p>Spring 提供了两种事务管理方式：<strong>声明式事务管理</strong>和<strong>编程式事务管理</strong>。对不同的持久层访问技术，编程式事务提供一致的事务编程风格，通过模板化的操作一致性地管理事务；而声明式事务基于 Spring AOP 实现，却并不需要程序开发者成为 AOP 专家，亦可轻易使用 Spring 的声明式事务管理。</p>
<p><strong>声明式事务</strong></p>
<p>Spring 的声明式事务管理是建立在 Spring AOP 机制之上的，其本质是对目标方法前后进行拦截，并在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<p>简单地说，声明式事务是<strong>编程式事务 + AOP 技术</strong>包装，使用注解进行扫包，指定范围进行事务管理。声明式事务管理要优于编程式事务管理，这正是 Spring 倡导的非侵入式的开发方式。  </p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> transactionDemo &#123;</span><br><span class="line">  <span class="comment">// TODO 业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编程式事务</strong></p>
<p>在 Spring 出现以前，编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中显式调用 beginTransaction()、commit()、rollback() 等事务管理相关的方法，这就是编程式事务管理。  </p>
<p>简单地说，编程式事务就是在代码中显式调用开启事务、提交事务、回滚事务的相关方法，因此代码侵入性较大。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">transactionStatus</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TODO 业务代码</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 提交事务</span></span><br><span class="line">          <span class="built_in">this</span>.transactionManager.commit(transactionStatus);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// 回滚事务</span></span><br><span class="line">          <span class="built_in">this</span>.transactionManager.rollback(transactionStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-事务的原理"><a href="#Spring-事务的原理" class="headerlink" title="Spring 事务的原理"></a>Spring 事务的原理</h3><p>使用 AOP <strong>环绕通知</strong> 和 <strong>异常通知</strong>。  </p>
<p>注意： 在使用 Spring 事务时不能使用 <code>try-catch</code> 进行异常捕获，要将异常抛给外层，使其进行异常拦截，触发事务机制。</p>
<h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><p>所谓事务的传播行为是指如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>在 Spring 中有七种事务传播行为， 下面我们就来看看吧。</p>
<p><strong>REQUIRED</strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。@Transactional 注解默认使用就是这个事务传播行为。<br>也就是说：</p>
<ul>
<li>如果外部方法没有开启事务的话，REQUIRED 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务并且被 REQUIRED 的话，所有 REQUIRED 修饰的内部方法和外部方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        classB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 REQUIRED 传播行为修饰的 methodA() 和 methodB() 的话，两者使用的就是同一个事务，只要其中一个方法发生回滚，整个事务都回滚。</p>
<p><strong>REQUIRES_NEW</strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说，不管外部方法是否开启事务，REQUIRES_NEW 修饰的内部方法会开启一个新的事务。如果外部方法开启事务，则两个事务互不干扰，相互独立，并且外部事务会挂起，等待内部事务执行完后，才继续执行。</p>
<p>示列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        classB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 REQUIRED 事务传播行为修饰 methodA()，使用 REQUIRES_NEW 修饰 methodB()。那么，methodA() 发生异常回滚，methodB() 是不会跟着回滚，因为 methodB() 开启了独立的事务。但是，如果 methodB() 发生异常回滚了，并且抛出的异常被 methodA() 的事务管理机制检测到了，methodA() 也会回滚。</p>
<p><strong>SUPPORTS</strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。不常用。</p>
<p><strong>NOT_SUPPORTED</strong></p>
<p>以非事务方式运行，如果当前存在事务，则把当前事务挂起。它可以帮助将事务极可能的缩小，因为一个事务越大，它存在的风险也就越多，所以在处理事务的过程中，要保证尽可能的缩小范围。</p>
<p>示列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        classB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 执行 1000 次非核心业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如 methodB() 执行循环 1000 次的非核心业务逻辑操作，并且它处在 methodA() 的事务中，这样会造成事务太大，导致出现一些难以考虑周全的异常情况。所以，使用 NOT_SUPPORTED 修饰 methodB()，当执行到 methodB() 时，将 methodA() 的事务挂起，等 methodB() 以非事务的状态运行完成后，再继续 methodA() 的事务。</p>
<p><strong>NEVER</strong></p>
<p>以非事务方式运行，如果当前存在事务，则抛出抛出Runtime 异常，强制停止执行。 </p>
<p>如果 methodA() 是使用 REQUIRED 修饰的， 而methodB() 的是使用 NEVER 修饰的。当执行到 methodB() 时，就要抛出异常了。</p>
<p><strong>MANDATORY</strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。也就是说，MANDATORY 要求上下文中必须要存在事务，否则就会抛出异常。</p>
<p>配置 MANDATORY 级别的事务是有效控制上下文调用代码而遗漏添加事务管理的保证手段。比如，一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用 MANDATORY 级别的事务。</p>
<p><strong>NESTED</strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 <strong>REQUIRED</strong>。</p>
<p>也就是说，如果外部方法开启事务的话，NESTED 修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。因为 NESTED 事务它有一个 savepoint，在内部方法执行失败后进行回滚，外部方法也会回滚到 savepoint 点上。此时，如果外部方法将内部方法抛出的异常进行了捕获则会继续往下执行直到完成自己的事务。如果外部方法没有捕获异常，则会根据事务规则进行回滚。</p>
<p>如果外部方法未开启事务，NESTED 和 REQUIRED 作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p>示列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// savepoint</span></span><br><span class="line">			classB.methodB();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// TODO 执行其他业务</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 methodB() 执行失败后进行回滚，methodA() 也会回滚到 savepoint 点上，而 methodA() 捕获了 methodB() 抛出的异常，继续执行自己的业务代码。</p>
<h3 id="基于注解-Transactional-声明事务失效分析"><a href="#基于注解-Transactional-声明事务失效分析" class="headerlink" title="基于注解 @Transactional 声明事务失效分析"></a>基于注解 @Transactional 声明事务失效分析</h3><p>在开发过程中，可能会遇到使用 @Transactional 进行事务管理时出现失效的情况。这里我们的讨论是基于事务的默认传播行为是 <code>REQUIRED</code>。</p>
<p><strong>常见失效场景</strong>  </p>
<ul>
<li><p>如果使用 MySQL 且引擎是 MyISAM，则事务会不起作用，原因是 MyISAM 不支持事务，改成 InnoDB 引擎则支持事务。</p>
</li>
<li><p>注解 @Trasactional 只能加在 <code>public</code> 修饰的方法上事务才起效。如果加在 <code>protect</code>、<code>private</code> 等非 <code>public</code> 修饰的方法上，事务将失效。</p>
</li>
<li><p>如果在开启了事务的方法内，使用了 <code>try-catch</code> 语句块对异常进行了捕获，而没有将异常抛到外层，事务将不起效。</p>
</li>
<li><p>在不同类之间的方法调用中，如果 A 方法开启了事务，B 方法没有开启事务，B 方法调用了 A 方法。</p>
<ul>
<li>如果 B 方法中发生异常，但不是调用的 A 方法产生的，则异常不会使 A 方法的事务回滚，此时事务无效。</li>
<li>如果 B 方法中发生异常，异常是调用的 A 方法产生的，则 A 方法的事务回滚，此时事务有效。</li>
<li>在 B 方法上加上注解 @Trasactional，这样 A 和 B 方法就在同一个事务里了，不管异常产生在哪里，事务都是有效的。   </li>
<li>简单地说，不同类之间方法调用时，异常发生在无事务的方法中，但不是被调用的方法产生的，被调用的方法的事务无效。只有异常发生在开启事务的方法内，事务才有效。</li>
</ul>
</li>
<li><p>在同一个类的方法之间调用中，如果 A 方法调用了 B 方法，不管 A 方法有没有开启事务，由于 Spring 的代理机制 B 方法的事务是无效的。但是，如果 A 方法开启 REQUIRED 事务，由于事务传播机制，B 方法会自动加入到 A 的事务中。</p>
</li>
<li><p>如果使用了 Spring + MVC，则 <code>context:component-scan</code> 重复扫描问题可能会引起事务失效。</p>
</li>
</ul>
<p><strong>原因分析</strong></p>
<p>在应用系统调用声明 @Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，再由这个代理对象来统一管理。  </p>
<p>Spring 事务是使用 AOP 环绕通知和异常通知，就是对方法进行拦截，在方法执行前开启事务，在捕获到异常时进行事务回滚，在方法执行完成后提交事务。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Spring 团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。    </p>
<p>Spring 文档中写到：Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理，如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个CGLIB代理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a class="link"   href="https://juejin.im/post/5b00c52ef265da0b95276091#heading-9" >https://juejin.im/post/5b00c52ef265da0b95276091#heading-9<i class="fas fa-external-link-alt"></i></a> </p>
<p><a class="link"   href="https://blog.csdn.net/rylan11/article/details/76609643" >https://blog.csdn.net/rylan11/article/details/76609643<i class="fas fa-external-link-alt"></i></a>  </p>
<p><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/73733278" >https://blog.csdn.net/justloveyou_/article/details/73733278<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务传播行为</title>
    <url>/p/20097.html</url>
    <content><![CDATA[<p>Spring事务的传播（Transaction Propagation）是指在多个事务边界嵌套执行时，如何管理这些事务的行为和隔离性。Spring框架提供了多种事务传播行为供开发者选择，以适应不同的业务需求。下面是几种常见的事务传播行为：</p>
<ol>
<li><p>REQUIRED（默认）：如果当前存在事务，则加入该事务中执行；如果当前没有事务，则启动一个新事务。这是最常用的传播行为，所有方法都在同一个事务中执行。</p>
</li>
<li><p>REQUIRES_NEW：无论当前是否存在事务，都会暂停当前事务，并启动一个新的事务来执行。即使外部事务失败回滚，新的事务也会继续执行。</p>
</li>
<li><p>NESTED：如果当前存在事务，则在当前事务的嵌套事务中执行；如果当前没有事务，则启动一个新事务。嵌套事务相对于独立的事务有更高的隔离性，且可以独立地进行提交或回滚。</p>
</li>
<li><p>SUPPORTS：如果当前存在事务，则加入该事务中执行；如果当前没有事务，则以非事务方式执行。支持当前事务，但不强制要求存在事务。</p>
</li>
<li><p>NOT_SUPPORTED：暂停当前事务（如果存在），以非事务方式执行。即使外部事务存在，该方法也不会参与到任何事务中。</p>
</li>
<li><p>NEVER：如果当前存在事务，则抛出异常；否则以非事务方式执行。不允许在事务中执行，如果当前存在事务，则会抛出异常。</p>
</li>
<li><p>MANDATORY：要求当前必须存在事务，否则抛出异常。必须在事务中执行，如果没有事务则会抛出异常。</p>
</li>
</ol>
<p>通过使用Spring的事务传播行为，我们可以灵活地控制事务的行为和隔离级别，以满足不同场景下的需求。在配置Spring事务管理时，可以通过在@Transactional注解中指定propagation属性，或者在XML文件中配置<a class="link"   href="tx:advice" >tx:advice<i class="fas fa-external-link-alt"></i></a>元素的propagation属性来设置事务的传播行为。</p>
<p>需要注意的是，事务传播行为只对于被代理的方法有效，非public方法默认不会被Spring的事务代理拦截。</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器创建流程</title>
    <url>/p/9949.html</url>
    <content><![CDATA[<p>参考地址：<a class="link"   href="https://blog.csdn.net/weixin_37607613/article/details/126217559" >https://blog.csdn.net/weixin_37607613/article/details/126217559<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的@Autowire和@Resource注解使用方式推荐</title>
    <url>/p/1621.html</url>
    <content><![CDATA[<p>虽然经常使用，但却很有讲究</p>
<span id="more"></span>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天使用Idea写代码的时候，看到之前的项目中显示有warning的提示，去看了下，是如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowire</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示的警告信息</strong><br>Field injection is not recommended Inspection info: Spring Team recommends: “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.</p>
</blockquote>
<p>这段是Spring工作组的建议，大致翻译一下：</p>
<blockquote>
<p>属性字段注入的方式不推荐，Spring团队建议：“始终在bean中使用基于构造函数的依赖项注入，始终对强制性依赖项使用断言”。</p>
</blockquote>
<h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><p>虽然当前有关Spring Framework（5.0.3）的文档仅定义了两种主要的注入类型，但实际上有三种:</p>
<h3 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> implents UserService&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于Setter的依赖注入"><a href="#基于Setter的依赖注入" class="headerlink" title="基于Setter的依赖注入"></a>基于Setter的依赖注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> implents UserService&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">serUserDao</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于字段的依赖注入"><a href="#基于字段的依赖注入" class="headerlink" title="基于字段的依赖注入"></a>基于字段的依赖注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> implents UserService&#123;</span><br><span class="line">     <span class="meta">@Autowire</span></span><br><span class="line">     <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>基于字段的依赖注入方式会在idea当中吃到黄牌警告，但是这种使用方式使用的也最广泛，因为简洁方便.您甚至可以在一些Spring指南中看到这种注入方法，尽管在文档中不建议这样做(有点知法犯法的感觉)。<br>如图</p>
<h3 id="基于字段的依赖注入缺点"><a href="#基于字段的依赖注入缺点" class="headerlink" title="基于字段的依赖注入缺点"></a>基于字段的依赖注入缺点</h3><h4 id="对于有final修饰的变量不好使"><a href="#对于有final修饰的变量不好使" class="headerlink" title="对于有final修饰的变量不好使"></a>对于有final修饰的变量不好使</h4><p>  <br>Spring的IOC对待属性的注入使用的是set形式，但是final类型的变量在调用class的构造函数的这个过程当中就得初始化完成，这个是基于字段的依赖注入做不到的地方，只能使用基于构造函数的依赖注入的方式</p>
<h4 id="掩盖单一职责的设计思想"><a href="#掩盖单一职责的设计思想" class="headerlink" title="掩盖单一职责的设计思想"></a>掩盖单一职责的设计思想</h4><p>我们都知道在OOP的设计当中有一个单一职责思想，如果你采用的是基于构造函数的依赖注入的方式来使用Spring的IOC的时候，当你注入的太多的时候，这个构造方法的参数就会很庞大，类似于下面.当你看到这个类的构造方法那么多参数的时候，你自然而然的会想一下:这个类是不是违反了单一职责思想?.但是使用基于字段的依赖注入不会让你察觉，你会很沉浸在<code>@Autowire</code>当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerifyServiceImpl</span> implents VerifyService&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line">  <span class="keyword">private</span> IDService idService;</span><br><span class="line">  <span class="keyword">private</span> RoleService roleService;</span><br><span class="line">  <span class="keyword">private</span> PermissionService permissionService;</span><br><span class="line">  <span class="keyword">private</span> EnterpriseService enterpriseService;</span><br><span class="line">  <span class="keyword">private</span> EmployeeService employService;</span><br><span class="line">  <span class="keyword">private</span> TaskService taskService;</span><br><span class="line">  <span class="keyword">private</span> RedisService redisService;</span><br><span class="line">  <span class="keyword">private</span> MQService mqService;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SystemLogDto</span><span class="params">(AccountService accountService, </span></span><br><span class="line"><span class="params">                      UserService userService, </span></span><br><span class="line"><span class="params">                      IDService idService, </span></span><br><span class="line"><span class="params">                      RoleService roleService, </span></span><br><span class="line"><span class="params">                      PermissionService permissionService, </span></span><br><span class="line"><span class="params">                      EnterpriseService enterpriseService, </span></span><br><span class="line"><span class="params">                      EmployeeService employService, </span></span><br><span class="line"><span class="params">                      TaskService taskService, </span></span><br><span class="line"><span class="params">                      RedisService redisService, </span></span><br><span class="line"><span class="params">                      MQService mqService)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.accountService = accountService;</span><br><span class="line">      <span class="built_in">this</span>.userService = userService;</span><br><span class="line">      <span class="built_in">this</span>.idService = idService;</span><br><span class="line">      <span class="built_in">this</span>.roleService = roleService;</span><br><span class="line">      <span class="built_in">this</span>.permissionService = permissionService;</span><br><span class="line">      <span class="built_in">this</span>.enterpriseService = enterpriseService;</span><br><span class="line">      <span class="built_in">this</span>.employService = employService;</span><br><span class="line">      <span class="built_in">this</span>.taskService = taskService;</span><br><span class="line">      <span class="built_in">this</span>.redisService = redisService;</span><br><span class="line">      <span class="built_in">this</span>.mqService = mqService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与Spring的IOC机制紧密耦合"><a href="#与Spring的IOC机制紧密耦合" class="headerlink" title="与Spring的IOC机制紧密耦合"></a>与Spring的IOC机制紧密耦合</h3><p> <br>当你使用基于字段的依赖注入方式的时候，确实可以省略构造方法和<code>setter</code>这些个模板类型的方法，但是，你把控制权全给Spring的IOC了，别的类想重新设置下你的某个注入属性，没法处理(当然反射可以做到).本身Spring的目的就是解藕和依赖反转，结果通过再次与类注入器（在本例中为Spring）耦合，失去了通过自动装配类字段而实现的对类的解耦，从而使类在Spring容器之外无效.
 </p>
<h3 id="隐藏依赖性"><a href="#隐藏依赖性" class="headerlink" title="隐藏依赖性"></a>隐藏依赖性</h3><p>当你使用Spring的IOC的时候，被注入的类应当使用一些public类型(构造方法，和setter类型方法)的方法来向外界表达:我需要什么依赖.但是基于字段的依赖注入的方式，基本都是<code>private</code>形式的，<code>private</code>把属性都给封印到class当中了.</p>
<h3 id="无法对注入的属性进行校验"><a href="#无法对注入的属性进行校验" class="headerlink" title="无法对注入的属性进行校验"></a>无法对注入的属性进行校验</h3><p>基于字段的依赖注入方式，你在程序启动的时候无法拿到这个类，只有在真正的业务使用的时候才会拿到，一般情况下，这个注入的都是非<code>null</code>的，万一要是<code>null</code>怎么办，在业务处理的时候错误才爆出来，时间有点晚了，如果在启动的时候就暴露出来，那么bug就可以很快得到修复(当然你可以加注解校验).如果你想在属性注入的时候，想根据这个注入的对象操作点东西，你无法办到．我碰到过的例子：一些配置信息啊，有些人总是会配错误，等到了自己测试业务阶段才知道配错了，例如线程初始个数不小心配置成了3000，机器真的是狂叫啊!这个时候就需要再某些Value注入的时候做一个检测机制.</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过上面，我们可以看到，基于字段的依赖注入方式有很多缺点,我们应当避免使用基于字段的依赖注入.推荐的方法是使用基于构造函数和基于setter的依赖注入.对于必需的依赖项，建议使用基于构造函数的注入，以使它们成为不可变的，并防止它们为<code>null</code>。对于可选的依赖项，建议使用基于setter的注入</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot:如何优雅地处理全局异常？</title>
    <url>/p/de65.html</url>
    <content><![CDATA[<blockquote>
<p>之前用springboot的时候，只知道捕获异常使用try{}catch，一个接口一个try{}catch，这也是大多数开发人员异常处理的常用方式，虽然屡试不爽，但会造成一个问题，就是一个Controller下面，满屏幕的try{}catch，看着一点都不优雅，一点都不符合小明的气质，憋了这么久，小明今天终于决定对所有异常实施统一处理的方案。</p>
</blockquote>
<h3 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h3><p>JDK8、正常的springboot项目</p>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><h4 id="通用异常处理"><a href="#通用异常处理" class="headerlink" title="通用异常处理"></a>通用异常处理</h4><p>其实Spring系列的项目全局异常处理方式早已存在，只不过我们一直忙于搬砖，很少停下脚步去审视这个日夜与我们相伴的朋友。为了贴合主题，本次主要针对SpringBoot全局异常处理进行举例说明。</p>
<p>SpringBoot中有一个<code>@ControllerAdvice</code>的注解，使用该注解即表示开启全局异常捕获，接下来我们只需在自定义的方法上使用<code>@ExceptionHandler</code>注解，并定义捕获异常的类型，对这种类型的异常进行统一的处理。</p>
<p><strong>举个例子:</strong></p>
<p>假如我们需要针对NullException（空指针异常，是Java程序员最痛恨的异常，没有之一）进行全局处理（如下所示）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">		/**</span><br><span class="line">     * 处理空指针的异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(value =NullPointerException.class)</span><br><span class="line">    public BaseResponseFacade exceptionHandler(HttpServletRequest req, NullPointerException e)&#123;</span><br><span class="line">        log.error(&quot;发生空指针异常！原因是:&quot;,e);</span><br><span class="line">        return ResponseUtil.error(ResponseCode.ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讷，就这么简单。其他可能发生的异常，都可以以这种方式处理快速处理。此处大家应该表现的十分兴奋，但请不要高兴太早，因为接下来，有更令激动人心的事情。</p>
<h4 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h4><h5 id="自定义一个异常"><a href="#自定义一个异常" class="headerlink" title="自定义一个异常"></a>自定义一个异常</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description 自定义异常</span><br><span class="line"> * @Date 2019-08-05 15:49</span><br><span class="line"> * @Created by 程序员小明</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Accessors(chain = true)</span><br><span class="line">public class BizException extends RuntimeException &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 错误码</span><br><span class="line">     */</span><br><span class="line">    protected Integer errorCode;</span><br><span class="line">    /**</span><br><span class="line">     * 错误信息</span><br><span class="line">     */</span><br><span class="line">    protected String errorMsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，这个异常继承了<code>RuntimeException</code>，属于运行时异常。细心的朋友已经发现，我使用了Lombok插件，非常契合今天的主题，给大家简单介绍一下：</p>
<blockquote>
<p>lombok是一个可以帮助我们简化java代码编写的工具类，尤其是简化javabean的编写，即通过采用注解的方式，消除代码中的构造方法，getter/setter等代码，使我们写的类更加简洁（如果使用的IDE是idea，需要安装插件哈）。</p>
</blockquote>
<p>定义过之后，我们就可以和之前处理NullException方式一样处理我们自定义的异常。包括处理其他异常，都是这种方式。直接贴代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理自定义的业务异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(value = BizException.class)</span><br><span class="line">    public BaseResponseFacade bizExceptionHandler(HttpServletRequest req, BizException e)&#123;</span><br><span class="line">        log.error(&quot;发生业务异常！原因是：&#123;&#125;&quot;,e.getErrorMsg());</span><br><span class="line">        return ResponseUtil.error(e.getErrorCode(),e.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理空指针的异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(value =NullPointerException.class)</span><br><span class="line">    public BaseResponseFacade exceptionHandler(HttpServletRequest req, NullPointerException e)&#123;</span><br><span class="line">        log.error(&quot;发生空指针异常！原因是:&quot;,e);</span><br><span class="line">        return ResponseUtil.error(ResponseCode.ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理其他异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(value =Exception.class)</span><br><span class="line">    public BaseResponseFacade exceptionHandler(HttpServletRequest req, Exception e)&#123;</span><br><span class="line">        log.error(&quot;未知异常！原因是:&quot;,e);</span><br><span class="line">        return ResponseUtil.error(ResponseCode.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整个全局异常处理方式核心就是以上介绍这些。下面用一个Demo给大家举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/test&quot;)</span><br><span class="line">public BaseResponseFacade test()&#123;</span><br><span class="line">  if(true)&#123;</span><br><span class="line">  	throw new BizException(1,&quot;error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return ResponseUtil.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址栏请求，进入这个方法后，会抛出异常，此时全局异常生效，就会返回异常处理过后的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errorCode&quot;:1,&quot;errorMsg&quot;:&quot;error&quot;,&quot;data&quot;:null&#125;</span><br></pre></td></tr></table></figure>

<p>到此整个流程都然跑通了。当然，好多地方都可以根据我们自身实际业务情况以此为基础进一步丰富，比如返回数据可以改成跳转某一个具体的页面。这样的出场方式是不是都很优雅？大家有什么问题，期待各位留言。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot启动流程</title>
    <url>/p/39079.html</url>
    <content><![CDATA[<p>👉 不如直接看源码来的直接</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">        // 启动计时器，用于记录整个启动过程的耗时</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        // 定义应用程序上下文和异常报告器列表</span><br><span class="line">        ConfigurableApplicationContext context = null;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 配置 Headless 属性</span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">        // 获取 Spring Boot 启动监听器</span><br><span class="line">        SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">        </span><br><span class="line">        // 执行启动监听器的 starting 方法，通知这些监听器启动过程已经开始</span><br><span class="line">        listeners.starting();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 解析命令行参数</span><br><span class="line">            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">            // 创建应用程序的环境变量</span><br><span class="line">            ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">             // 打印 Banner，可以支持自定义哦</span><br><span class="line">            Banner printedBanner = printBanner(environment);</span><br><span class="line">            // 根据应用程序类型创建应用程序创建上下文对象</span><br><span class="line">            context = createApplicationContext();</span><br><span class="line">            // 初始化异常分析器</span><br><span class="line">            analyzers = new FailureAnalyzers(context);</span><br><span class="line">            // 准备应用程序上下文，扫描 classpath 中的各种配置文件，例如 application.properties、application.yml、META-INF/spring.factories 等，调用 load() 方法加载应用程序的配置。</span><br><span class="line">            prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            // 刷新应用程序上下文</span><br><span class="line">            refreshContext(context);</span><br><span class="line">            // 刷新后操作</span><br><span class="line">            afterRefresh(context, applicationArguments);</span><br><span class="line">            // </span><br><span class="line">            listeners.finished(context, null);</span><br><span class="line">            // 停止计时器</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            // 记录启动日志</span><br><span class="line">            if (this.logStartupInfo) &#123;</span><br><span class="line">                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            // 返回应用程序上下文</span><br><span class="line">            return context;</span><br><span class="line">        &#125;catch (Throwable ex) &#123;</span><br><span class="line">          handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">          throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot配置logback日志</title>
    <url>/p/d0da.html</url>
    <content><![CDATA[<blockquote>
<p>本文主要给大家介绍SpringBoot中如何通过sl4j日志组件优雅地记录日志。其实，我们入门 <strong>JAVA</strong> 的第一行代码就是一行日志，那你现在还在使用<code>System.out.println(&quot;Hello,小明!&quot;)</code>记录日志吗？</p>
</blockquote>
<h2 id="我经历过的日志组件"><a href="#我经历过的日志组件" class="headerlink" title="我经历过的日志组件"></a>我经历过的日志组件</h2><p>我最开始接触的日志组件是<strong>Log4j</strong></p>
<blockquote>
<p><strong>Log4j</strong> 作为Apache的一个开放源代码的项目，通过使用<strong>Log4j</strong>，我们可以控制日志信息输送的目的地是控制台、文件等我们期望它输出到的地方；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p>
</blockquote>
<p>我们可以通过一个配置文件来灵活地进行上面的配置，而不需要修改应用的代码。<strong>Log4j</strong>作为当时作为最先比较流行的日志框架，给我们在应用开发和维护带来了很大的便捷。</p>
<p>但是，如今还是慢慢的走下“神坛”呢，逐渐被<strong>Logback</strong>替代，众里寻她千百度，原来<strong>Logback</strong>是<strong>升级版</strong>，相对<strong>Log4j</strong>而言有了更多的改进，而且开发人员竟然是同班人马（其实就是一个人写的）！</p>
<h2 id="新星Logback"><a href="#新星Logback" class="headerlink" title="新星Logback"></a>新星Logback</h2><p><strong>Logback</strong>主要有下面的特性：</p>
<ol>
<li>更快的执行速度：基于我们先前在<strong>Log4j</strong>上的工作，<strong>Logback</strong> 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证<strong>Logback</strong>的组件更加快速的同时，同时所需的内存更加少；</li>
<li>充分的测试：<strong>Logback</strong> 历经了几年，数不清小时数的测试。尽管<strong>Log4j</strong>也是测试过的，但是<strong>Logback</strong>的测试更加充分，跟<strong>Log4j</strong>不在同一个级别。我们认为，这正是人们选择<strong>Logback</strong>而不是<strong>Log4j</strong>的最重要的原因。谁不希望即使在恶劣的条件下，你的日志框架依然稳定而可靠呢？</li>
</ol>
<ul>
<li>由三个模块组成<ul>
<li>logback-core</li>
<li>logback-classic</li>
<li>logback-access</li>
</ul>
</li>
</ul>
<p><code>logback-core</code>是其它模块的基础设施，其它模块基于它构建，显然，<code>logback-core</code>提供了一些关键的通用机制。<code>logback-classic</code>的地位和作用等同于 <code>Log4J</code>，它也被认为是 <code>Log4J</code>的一个改进版，并且它实现了简单日志门面 <code>SLF4J</code>；而 <code>logback-access</code>主要作为一个与 <code>Servlet</code>容器交互的模块，比如说<code>tomcat</code>或者 <code>jetty</code>，提供一些与 <code>HTTP</code>访问相关的功能。</p>
<h2 id="那Sl4J又是什么？"><a href="#那Sl4J又是什么？" class="headerlink" title="那Sl4J又是什么？"></a>那Sl4J又是什么？</h2><blockquote>
<p><strong>slf4j</strong>:The Simple Logging Facade for Java 即java的简单日志门面</p>
</blockquote>
<p>简答的讲就是<strong>slf4j</strong>是一系列的日志接口，<strong>slf4j</strong>是作为一个日志的抽象行为存在的，但是并没有提供真正的实现。</p>
<p><strong>slf4j</strong>为各种日志框架提供了一个统一的界面，使用户可以用统一的接口记录日志，动态地决定要使用的实现框架，比如<strong>Logback</strong>，<strong>Log4j</strong>，<strong>common-logging</strong>等框架都实现了这些接口。</p>
<h2 id="我是如何配置日志的？"><a href="#我是如何配置日志的？" class="headerlink" title="我是如何配置日志的？"></a>我是如何配置日志的？</h2><p>路人皆知，<strong>Springboot</strong>默认使用的日志框架是<strong>Logback</strong>。顺势而为，在项目中，我们使用<strong>Logback</strong>，其实只需增加一个配置文件（自定义你的配置）即可。</p>
<h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><p>配置文件精简结构如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;  </span><br><span class="line">		 &lt;!-- 属性文件:在properties/yml文件中找到对应的配置项 --&gt;</span><br><span class="line">    &lt;springProperty scope=&quot;context&quot; name=&quot;logging.path&quot; source=&quot;logging.path&quot;/&gt;</span><br><span class="line">    &lt;contextName&gt;程序员小明&lt;/contextName&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;appender&gt;</span><br><span class="line">        //xxxx</span><br><span class="line">    &lt;/appender&gt;   </span><br><span class="line">    </span><br><span class="line">    &lt;logger&gt;</span><br><span class="line">        //xxxx</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;root&gt;             </span><br><span class="line">       //xxxx</span><br><span class="line">    &lt;/root&gt;  </span><br><span class="line">&lt;/configuration&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个文件在springboot中默认叫做<strong>logback-spring.xml</strong>，我们只要新建一个同名文件放在<strong>resources</strong>下面， 配置即可生效。</p>
<p>每个配置的解释如下所示：</p>
<h4 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h4><p>每个<code>logger</code>都关联到<code>logger</code>上下文，默认上下文名称为<code>“default”</code>。但可以使用<code>contextName</code>标签设置成其他名字，用于区分不同应用程序的记录</p>
<h4 id="property"><a href="#property" class="headerlink" title="property"></a>property</h4><p>用来定义变量值的标签，<code>property</code>标签有两个属性，<code>name</code>和<code>value</code>；其中<code>name</code>的值是变量的名称，<code>value</code>的值是变量定义的值。通过<code>property</code>定义的值会被插入到<code>logger</code>上下文中。定义变量后，可以使“${name}”来使用变量。如上面的<code>xml</code>所示。</p>
<h4 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h4><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定<code>appender</code>。</p>
<h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p>根logger，也是一种logger，且只有一个level属性</p>
<h4 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h4><p>负责写日志的组件</p>
<h5 id="appender-的种类"><a href="#appender-的种类" class="headerlink" title="appender 的种类"></a>appender 的种类</h5><ul>
<li>ConsoleAppender：把日志添加到控制台</li>
<li>FileAppender：把日志添加到文件</li>
<li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li>
</ul>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter其实是appender里面的子元素。它作为过滤器存在，执行一个过滤器会有返回DENY，NEUTRAL，ACCEPT三个枚举值中的一个。</p>
<ul>
<li><p>DENY：日志将立即被抛弃不再经过其他过滤器</p>
</li>
<li><p>NEUTRAL：有序列表里的下个过滤器过接着处理日志</p>
</li>
<li><p>ACCEPT：日志会被立即处理，不再经过剩余过滤器</p>
<p>有以下几种过滤器</p>
<h5 id="ThresholdFilter"><a href="#ThresholdFilter" class="headerlink" title="ThresholdFilter"></a>ThresholdFilter</h5><p>临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回<code>NEUTRAL</code>；当日志级别低于临界值时，日志会被拒绝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">    &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure>

<h5 id="LevelFilter"><a href="#LevelFilter" class="headerlink" title="LevelFilter"></a>LevelFilter</h5><p>级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据<code>onMath</code>(用于配置符合过滤条件的操作) 和 <code>onMismatch</code>(用于配置不符合过滤条件的操作)接收或拒绝日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;   </span><br><span class="line">  &lt;level&gt;INFO&lt;/level&gt;   </span><br><span class="line">  &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;   </span><br><span class="line">  &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;   </span><br><span class="line">&lt;/filter&gt; </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>一个简单正常的Springboot项目</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><p>有关日志的简单配置，我们可以直接在<code>application.yml</code>中进行简单的配置，比如指明日志的打印级别和日志的输出位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">  path: ./logs</span><br></pre></td></tr></table></figure>

<p>也可以根据分环境配置指明使用的配置文件，缺省为<strong>logback-spring.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">  path: ./logs</span><br><span class="line">  config: classpath:/logback-dev.xml</span><br></pre></td></tr></table></figure>



<h4 id="logback-spring-xml"><a href="#logback-spring-xml" class="headerlink" title="logback-spring.xml"></a>logback-spring.xml</h4><p>在<strong>resources</strong>目录下新建<strong>logback-spring.xml</strong>文件，举例一个简单的需求，如果在项目中我们如果需要指定日志的输出格式以及根据日志级别输出到不同的文件，可以配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 属性文件:在properties文件中找到对应的配置项 --&gt;</span><br><span class="line">    &lt;springProperty scope=&quot;context&quot; name=&quot;logging.path&quot; source=&quot;logging.path&quot;/&gt;</span><br><span class="line">    &lt;contextName&gt;xiaoming&lt;/contextName&gt;</span><br><span class="line">    &lt;appender name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出（配色）：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span><br><span class="line">            &lt;pattern&gt;%yellow(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %red([%thread]) %highlight(%-5level) %cyan(%logger&#123;50&#125;) - %magenta(%msg) %n</span><br><span class="line">            &lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--根据日志级别分离日志，分别输出到不同的文件--&gt;</span><br><span class="line">    &lt;appender name=&quot;fileInfoLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;/level&gt;</span><br><span class="line">            &lt;onMatch&gt;DENY&lt;/onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            &lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;!--滚动策略--&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--按时间保存日志 修改格式可以按小时、按天、月来保存--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;logging.path&#125;/xiaoming.info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!--保存时长--&gt;</span><br><span class="line">            &lt;MaxHistory&gt;90&lt;/MaxHistory&gt;</span><br><span class="line">            &lt;!--文件大小--&gt;</span><br><span class="line">            &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appender name=&quot;fileErrorLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            &lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;!--滚动策略--&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--路径--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;logging.path&#125;/xiaoming.error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;MaxHistory&gt;90&lt;/MaxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;root level=&quot;info&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;consoleLog&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;fileInfoLog&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;fileErrorLog&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>再比如如果粒度再细一些，根据不同的模块，输出到不同的文件，可以如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--特殊功能单独appender 例如调度类的日志--&gt;</span><br><span class="line">   &lt;appender name=&quot;CLASS-APPENDER&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">       &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">           &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">       &lt;/filter&gt;</span><br><span class="line">       &lt;encoder&gt;</span><br><span class="line">           &lt;pattern&gt;</span><br><span class="line">               %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">           &lt;/pattern&gt;</span><br><span class="line">       &lt;/encoder&gt;</span><br><span class="line">       &lt;!--滚动策略--&gt;</span><br><span class="line">       &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">           &lt;!--路径--&gt;</span><br><span class="line">           &lt;fileNamePattern&gt;$&#123;logging.path&#125;/mkc.class.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">           &lt;MaxHistory&gt;90&lt;/MaxHistory&gt;</span><br><span class="line">       &lt;/rollingPolicy&gt;</span><br><span class="line">   &lt;/appender&gt;</span><br><span class="line">   &lt;!--这里的name和业务类中的getLogger中的字符串是一样的--&gt;</span><br><span class="line">   &lt;logger name=&quot;xiaoming&quot; level=&quot;INFO&quot; additivity=&quot;true&quot;&gt;</span><br><span class="line">       &lt;appender-ref ref=&quot;CLASS-APPENDER&quot; /&gt;</span><br><span class="line">   &lt;/logger&gt;</span><br></pre></td></tr></table></figure>

<p>正常情况下<strong>xiaoming</strong>是指的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Logger xiaoming = LoggerFactory.getLogger(&quot;xiaoming&quot;);</span><br></pre></td></tr></table></figure>

<p>如果我们使用的是<strong>lomok</strong>插件，则<strong>xiaoming</strong>指的是<strong>topic</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j(topic = &quot;xiaoming&quot;)</span><br><span class="line">public class XiaoMingTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们还可以根据环境配置logback，比如开发环境(dev)输出到控制台，生产环境(prod)输出到文件中，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;springProfile name=&quot;dev&quot;&gt;</span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;consoleLog&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br><span class="line"></span><br><span class="line">&lt;springProfile name=&quot;prod&quot;&gt;</span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;fileInfoLog&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br></pre></td></tr></table></figure>


<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>小明目前用到的就这么多啦，更多的日志配置场景，欢迎大家补充～</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/p/29d7.html</url>
    <content><![CDATA[<blockquote>
<p>摘自 <a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483678&idx=1&sn=461d8e3453031337c7599758dceaf675&chksm=ebf6d961dc81507743a0c0b4a830457156536da61508b56d6689ed75ff8242422df3ce4b36e2&scene=21#wechat_redirect"  title="点击查看!">纯洁的微笑<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。</p>
<hr>
<h1 id="使用spring-boot有什么好处"><a href="#使用spring-boot有什么好处" class="headerlink" title="使用spring boot有什么好处"></a>使用spring boot有什么好处</h1><p>其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？</p>
<ul>
<li>配置web.xml，加载spring和spring mvc</li>
<li>配置数据库连接、配置spring事务</li>
<li>配置加载配置文件的读取，开启注解</li>
<li>配置日志文件</li>
<li>…</li>
<li>配置完成之后部署tomcat调试</li>
<li>…</li>
</ul>
<p>现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍!<br>但是如果使用spring boot呢？<br>很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！</p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="maven搭建项目"><a href="#maven搭建项目" class="headerlink" title="maven搭建项目"></a>maven搭建项目</h2><ul>
<li>访问 <a class="link"   href="http://start.spring.io/" >http://start.spring.io/<i class="fas fa-external-link-alt"></i></a></li>
<li>选择构建工具Maven Project、Spring Boot版本1.3.6以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.7</li>
<li>点击Generate Project下载项目压缩包</li>
<li>解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done!<h2 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h2></li>
</ul>
<p>&lt;Spring Boot的基础结构共三个文件:</p>
<ul>
<li>src/main/java  程序开发以及主程序入口</li>
<li>src/main/resources 配置文件</li>
<li>src/test/java  测试程序<br>另外，spingboot建议的目录结果如下：<br>root package结构：<code>com.example.myproject</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- domain</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- controller</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure></li>
<li>Application.java 建议放到跟目录下面,主要用于做一些框架配置</li>
<li>domain目录主要用于实体（Entity）与数据访问层（Repository）</li>
<li>service 层主要是业务类代码</li>
<li>controller 负责页面访问控制<br>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改<br>最后，启动Application main方法，至此一个java项目搭建好了！</li>
</ul>
<h2 id="引入web模块"><a href="#引入web模块" class="headerlink" title="引入web模块"></a>引入web模块</h2><h3 id="pom-xml中添加支持web的模块"><a href="#pom-xml中添加支持web的模块" class="headerlink" title="pom.xml中添加支持web的模块"></a>pom.xml中添加支持web的模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>pom.xml文件中默认有两个模块<br><code>spring-boot-starter</code> ：核心模块，包括自动配置支持、日志和YAML；<br><code>spring-boot-starter-test</code> ：测试模块，包括JUnit、Hamcrest、Mockito。</p>
<h3 id="编写controller内容"><a href="#编写controller内容" class="headerlink" title="编写controller内容"></a>编写controller内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloWorldController &#123;   </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)    </span><br><span class="line">    public String index() &#123; </span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@RestController</code> 的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！<br>启动主程序，打开浏览器访问<a class="link"   href="http://localhost:8080/hello%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%E4%BA%86%EF%BC%8C%E6%9C%89%E6%9C%A8%E6%9C%89%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%81" >http://localhost:8080/hello，就可以看到效果了，有木有很简单！<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h2><p>打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(classes = MockServletContext.class)</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">public class HelloWorldControlerTests &#123;</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception &#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发环境的调试"><a href="#开发环境的调试" class="headerlink" title="开发环境的调试"></a>开发环境的调试</h2><p>热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。</p>
<h1 id="springboot实战"><a href="#springboot实战" class="headerlink" title="springboot实战"></a>springboot实战</h1><h2 id="SpringBoot中获取spring-profiles-active的值（代码级别）"><a href="#SpringBoot中获取spring-profiles-active的值（代码级别）" class="headerlink" title="SpringBoot中获取spring.profiles.active的值（代码级别）"></a>SpringBoot中获取spring.profiles.active的值（代码级别）</h2><blockquote>
<p>源码分析参考链接<a class="link"   href="https://www.cnblogs.com/linzhanfly/p/9056722.html" >月下小魔王<i class="fas fa-external-link-alt"></i></a><br>应用场景：根据环境编写业务代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringContextUtil implements ApplicationContextAware &#123;</span><br><span class="line">    private static ApplicationContext context = null;</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line">        this.context = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取当前环境</span><br><span class="line">    public static String getActiveProfile() &#123;</span><br><span class="line">        return context.getEnvironment().getActiveProfiles()[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于ApplicationContextAware接口的说明"><a href="#关于ApplicationContextAware接口的说明" class="headerlink" title="关于ApplicationContextAware接口的说明"></a>关于ApplicationContextAware接口的说明</h3><p>Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<p>使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。</p>
<p>文中所有的代码 <a class="link"   href="https://github.com/ityouknow/spring-boot-starter" >https://github.com/ityouknow/spring-boot-starter<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot发送邮件</title>
    <url>/p/3735.html</url>
    <content><![CDATA[<blockquote>
<p>在小明经历的多个项目开发中，总会遇到<strong>消息通知</strong>的场景，比如某个广告主提交一个表单，我们要通知提醒运营人员及时查看。</p>
</blockquote>
<p>消息通知的形式也有很多，比如：短信、邮件、app推送等，本文主要给大家描述一下<strong>邮件</strong>通知的形式，因为邮件相比较其他通知渠道更方便实用（免费），除了简单文本邮件（已经满足大多数情形），本文还会重点说一下集成<strong>Thymeleaf</strong>模版引擎，使用<strong>HTML</strong>的形式发送邮件，尽管<strong>HTML</strong>内容不是标准化的消息格式，但是许多邮件客户端至少支持标记语言的子集，这种方式相比较纯文本展现形式更加友好。 </p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>一个普通再也普通不了的SpringBoot项目</p>
<h2 id="简单文本发送"><a href="#简单文本发送" class="headerlink" title="简单文本发送"></a>简单文本发送</h2><p>还是那句老话，在SpringBoot看来一切都是这么便捷。它已经集成邮件发送所必需的库模块，我们只需将以下依赖添加到<code>pom.xml</code>即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="邮箱服务结构"><a href="#邮箱服务结构" class="headerlink" title="邮箱服务结构"></a><strong>邮箱服务结构</strong></h3><p>Spring框架中用于Java邮件支持的接口和类组织如下：</p>
<ol>
<li><p><strong>MailSender interface</strong>：发送简单基础电子邮件的顶级接口；</p>
</li>
<li><p><strong>JavaMailSender interface</strong>：是<code>MailSender</code>的子接口。它支持MIME消息，并且主要与<code>MimeMessageHelper</code>类一起用于创建<code>MimeMessage</code>。建议在此接口实现类<code>JavaMailSenderImpl</code>中使用<code>MimeMessagePreparator</code>机制；</p>
</li>
<li><p><strong>JavaMailSenderImpl class</strong>：实现了<code>JavaMailSender</code> 的接口，它支持<code>MimeMessage</code>和<code>SimpleMailMessage</code>；</p>
</li>
<li><p> <strong>SimpleMailMessage class</strong>：用于创建简单的邮件消息，包括from，to，cc，subject和text字段；</p>
</li>
<li><p><strong>MimeMessagePreparator interface</strong>：提供一个回调接口，用于编写MIME消息；</p>
</li>
<li><p><strong>MimeMessageHelper class</strong>：用于创建MIME消息的帮助类。它为HTML布局中的图像，典型邮件附件和文本内容提供支持。</p>
</li>
</ol>
<p>在以下部分中，我将向大家展示如何使用这些接口和类：</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>下面举例163邮箱（最常用的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    host: smtp.163.com # 发件服务器</span><br><span class="line">    username: coderxm@163.com # 账号</span><br><span class="line">    password: xxxx # 密码（163需要授权第三方登录密码，请查看设置-客户端授权码密码开通）</span><br><span class="line">    port: 465</span><br><span class="line">    protocol: smtp</span><br><span class="line">    default-encoding: utf-8</span><br><span class="line">    # 下面这些配置大家不用深究，主要用于配置ssl</span><br><span class="line">    properties:</span><br><span class="line">      mail:</span><br><span class="line">        imap:</span><br><span class="line">          ssl:</span><br><span class="line">            socketFactory:</span><br><span class="line">              fallback: false</span><br><span class="line">        smtp:</span><br><span class="line">          auth: true</span><br><span class="line">          ssl:</span><br><span class="line">            enable: true</span><br><span class="line">            socketFactory:</span><br><span class="line">              class: com.fintech.modules.base.util.mail.MailSSLSocketFactory</span><br><span class="line">          starttls:</span><br><span class="line">            enable: true</span><br><span class="line">            required: true</span><br><span class="line">      test-connection: false</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h4><p>按照常见的代码结构，我们先定义一个发送邮件的<strong>接口</strong>，负责创建和发送新的邮件消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface EmailService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 发送简单文本内容</span><br><span class="line">     * @param to 发件人</span><br><span class="line">     * @param subject 主题</span><br><span class="line">     * @param text 内容</span><br><span class="line">     */</span><br><span class="line">    void sendSimpleMessage(String to,</span><br><span class="line">                           String subject,</span><br><span class="line">                           String text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将一些常用的配置添加到yml配置文件当中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 邮件配置</span><br><span class="line">xiaoming:</span><br><span class="line">  email:</span><br><span class="line">    subject: &quot;程序员小明&quot;</span><br><span class="line">    from: &quot;coderxm@163.com&quot;</span><br><span class="line">    to: &quot;xiaohong@163.com&quot;</span><br><span class="line">    # 抄送人：类型定义为数组，可以配置多个</span><br><span class="line">    cc:</span><br><span class="line">      - &quot;xiaogang@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>然后再通过注解注入到一个实体类中，这样很优雅，随用随取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;xiaoming.email&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="keyword">private</span> String[] cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再定义一个类去实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> JavaMailSender emailSender;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmailConfig emailConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMessage</span><span class="params">(String to, String subject, String text)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">            message.setTo(to);</span><br><span class="line">            message.setFrom(<span class="string">&quot;coderxm@163.com&quot;</span>);</span><br><span class="line">            message.setSubject(subject);</span><br><span class="line">            message.setText(text);</span><br><span class="line">            emailSender.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MailException exception) &#123;</span><br><span class="line">            log.error(ExceptionUtil.stacktraceToString(exception));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们做一个简单的测试：简单的邮件是否能够发送成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimple</span><span class="params">()</span>&#123;</span><br><span class="line">        emailService.sendSimpleMessage(<span class="string">&quot;ligang@163.com&quot;</span>,<span class="string">&quot;XX篮球&quot;</span>,<span class="string">&quot;你好，我想让周琦代言！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用html作为模版发送邮件"><a href="#使用html作为模版发送邮件" class="headerlink" title="使用html作为模版发送邮件"></a>使用html作为模版发送邮件</h3><p>正在洋洋得意（准备划水）的时候，我们的产品突然对我说，“用简单的文本发送邮件也太简陋了吧，显示不出来我们的产品档次”，然后给我了一个样式，让我以这种形式发送，好啊，什么都难不倒小明。我连忙找到我们的前端，（假装低三下四地）让她帮忙排一个页面给我（这个工作我实在不想做，一是懒，二是人家前端肯定比我专业啊），为了保密，我简化一下，大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    姓 名：&lt;span th:text=&quot;$&#123;userName&#125;&quot;&gt;&lt;/span&gt;</span><br><span class="line">    性 别：&lt;span th:text=&quot;$&#123;gender&#125;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>其实样式很好看的，但是这都不是重点，我们就以此作为模版举个例子，语法使用的都是thymeleaf，在此处就不再赘述，如果有想了解的可以去官网找。</p>
<h4 id="增加Thymeleaf-dependency"><a href="#增加Thymeleaf-dependency" class="headerlink" title="增加Thymeleaf dependency"></a>增加Thymeleaf dependency</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="service层-1"><a href="#service层-1" class="headerlink" title="service层"></a>service层</h4><p>创建另一个服务类，它主要通过读取html模版封装数据准备邮件内容，在我们之前的示例中，这是一个简单的文本消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MailContentBuilder &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MailContentBuilder(TemplateEngine templateEngine) &#123;</span><br><span class="line">        this.templateEngine = templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String build(Map&lt;String, Object&gt; message) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line">        context.setVariables(message);</span><br><span class="line">        return templateEngine.process(&quot;email&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>EmailService</code>增加接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface EmailService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 发送简单文本内容</span><br><span class="line">     * @param to 发件人</span><br><span class="line">     * @param subject 主题</span><br><span class="line">     * @param text 内容</span><br><span class="line">     */</span><br><span class="line">    void sendSimpleMessage(String to,</span><br><span class="line">                           String subject,</span><br><span class="line">                           String text);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传递多个变量，用于动态更换页面模版内容</span><br><span class="line">     * @param emailInfoMap</span><br><span class="line">     */</span><br><span class="line">    void prepareAndSend(Map&lt;String,Object&gt; emailInfoMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>EmailServiceImpl</code>增加发送html形式邮件的实现方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void prepareAndSend(Map&lt;String,Object&gt; emailInfoMap) &#123;</span><br><span class="line">    MimeMessagePreparator messagePreparator = mimeMessage -&gt; &#123;</span><br><span class="line">        MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage);</span><br><span class="line">        messageHelper.setFrom(emailConfig.getFrom());</span><br><span class="line">        messageHelper.setTo(emailConfig.getTo());</span><br><span class="line">        messageHelper.setCc(emailConfig.getCc());</span><br><span class="line">        messageHelper.setSubject(emailConfig.getSubject());</span><br><span class="line">//            messageHelper.setText(message);</span><br><span class="line">        String content = mailContentBuilder.build(info);</span><br><span class="line">        messageHelper.setText(content,true);</span><br><span class="line">    &#125;;</span><br><span class="line">    try &#123;</span><br><span class="line">        emailSender.send(messagePreparator);</span><br><span class="line">    &#125; catch (MailException e) &#123;</span><br><span class="line">        // runtime exception; compiler will not force you to handle it</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EmailTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EmailService emailService;</span><br><span class="line">  </span><br><span class="line">    @Test</span><br><span class="line">    public void testHtml()&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;userName&quot;,&quot;程序员小明&quot;);</span><br><span class="line">        map.put(&quot;gender&quot;,&quot;男&quot;);</span><br><span class="line">        emailService.prepareAndSend(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个Springboot发送邮件的场景已经复盘结束，大家如果有用到的速速体验吧！</p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot快速集成swagger</title>
    <url>/p/e48d.html</url>
    <content><![CDATA[<blockquote>
<p>今天技术总监说：小明，我们本次3.0改造，使用swagger2.0作为前后端分离的接口规范，它可以一键生成前后端的API,一劳永逸……小明：？？？</p>
</blockquote>
<p>Spring Boot 框架是目前非常流行的微服务框架，我们很多情况下使用它来提供 Rest API，而对于 Rest API 来说很重要的一部分内容就是文档，Swagger 为我们提供了一套通过代码和注解自动生成文档的方法，这一点对于保证 API 文档的及时性将有很大的帮助。本文将使用 Swagger 2 规范的 Springfox 实现来了解如何在 Spring Boot 项目中使用 Swagger，主要包含了如何使用 Swagger 自动生成文档、使用 Swagger 文档以及 Swagger 相关的一些高级配置和注解。</p>
<h1 id="Swagger-简介"><a href="#Swagger-简介" class="headerlink" title="Swagger 简介"></a>Swagger 简介</h1><p>Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。Swagger 主要包含了以下三个部分：</p>
<ol>
<li>Swagger Editor：基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范。</li>
<li>Swagger UI：它会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 Rest API。</li>
<li>Swagger Codegen：它可以通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程。</li>
</ol>
<h2 id="为什么要使用-Swagger"><a href="#为什么要使用-Swagger" class="headerlink" title="为什么要使用 Swagger"></a>为什么要使用 Swagger</h2><p>当下很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的 Rest API 文档将会极大的提高我们的工作效率。传统意义上的文档都是后端开发人员手动编写的，相信大家也都知道这种方式很难保证文档的及时性，这种文档久而久之也就会失去其参考意义，反而还会加大我们的沟通成本。而 Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们就来了解一下它的优点：</p>
<ol>
<li><p>代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。</p>
</li>
<li><p>跨语言性，支持 40 多种语言。</p>
</li>
<li><p>Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</p>
</li>
<li><p>还可以将文档规范导入相关的工具（例如 SoapUI）, 这些工具将会为我们自动地创建自动化测试。</p>
</li>
</ol>
<p>以上这些优点足以说明我们为什么要使用 Swagger 了，您是否已经对 Swagger 产生了浓厚的兴趣了呢？下面我们就将一步一步地在 Spring Boot 项目中集成和使用 Swagger，让我们从准备一个 Spring Boot 的 Web 项目开始吧。</p>
<h1 id="准备-Spring-Boot-Web-项目"><a href="#准备-Spring-Boot-Web-项目" class="headerlink" title="准备 Spring Boot Web 项目"></a>准备 Spring Boot Web 项目</h1><p>在这一步我们将准备一个基础的 Spring Boot 的 Web 项目，并且提供后面所需要的所有 API。</p>
<h2 id="创建一个空的-Spring-Boot-项目"><a href="#创建一个空的-Spring-Boot-项目" class="headerlink" title="创建一个空的 Spring Boot 项目"></a>创建一个空的 Spring Boot 项目</h2><p>您可以通过 Spring Initializr 页面生成一个空的 Spring Boot 项目，当然也可以下载 springboot-pom.xml 文件，然后使用 Maven 构建一个 Spring Boot 项目。项目创建完成后，为了方便后面代码的编写您可以将其导入到您喜欢的 IDE 中，我这里选择了 Intelli IDEA 打开。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>由于创建的是一个 Web 项目，所以我们需要依赖 Spring Boot 的 Web 组件，只需要在 pom.xml 增加如下内容即可：</p>
<p>清单 1. 添加 Web 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h2><ol>
<li>首先我们创建三个包：cn.itweknow.sbswagger.controller、cn.itweknow.sbswagger.testcontroller 以及 cn.itweknow.sbswagger.model。</li>
<li>在 controller 包下新建 UserController.java 类，在 testcontroller 包下新建 TestController.java 类，在 model 包下新建 User.java 类。</li>
<li>UserController 提供用户的增、删、改、查四个接口，TestContrller 提供一个测试接口，这里粘上 UserController.java 的代码，其余代码可以查看源码。</li>
</ol>
<p>清单 2. UserController.java 代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;/add&quot;)</span><br><span class="line">    public boolean addUser(@RequestBody User user) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    @GetMapping(&quot;/find/&#123;id&#125;&quot;)</span><br><span class="line">    public User findById(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">    @PutMapping(&quot;/update&quot;)</span><br><span class="line">    public boolean update(@RequestBody User user) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集成-Swagger2"><a href="#集成-Swagger2" class="headerlink" title="集成 Swagger2"></a>集成 Swagger2</h1><p>经过上面的步骤，我们已经拥有了五个接口，分别是:</p>
<ol>
<li>/user/add：新增用户。</li>
<li>/user/find/{id}：根据 id 查询用户。</li>
<li>/user/update：更新用户。</li>
<li>/user/delete/{id}：根据 id 删除用户。</li>
<li>/test/test：测试接口。</li>
</ol>
<p>下面我们将通过集成 Swagger2，然后为这 5 个 Rest API 自动生成接口文档。</p>
<h2 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>首先要做的自然是添加 Swagger2 所需要的依赖包：</p>
<p>清单 3. 添加 Swagger 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h2><p>Springfox 提供了一个 Docket 对象，让我们可以灵活的配置 Swagger 的各项属性。下面我们新建一个 cn.itweknow.sbswagger.conf.SwaggerConfig.java 类，并增加如下内容:</p>
<p>清单 4. Swagger Java 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket api() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: @Configuration 是告诉 Spring Boot 需要加载这个配置类，@EnableSwagger2 是启用 Swagger2，如果没加的话自然而然也就看不到后面的验证效果了。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>至此，我们已经成功的在 Spring Boot 项目中集成了 Swagger2，启动项目后，我们可以通过在浏览器中访问 <a class="link"   href="http://localhost:8080/" >http://localhost:8080/<i class="fas fa-external-link-alt"></i></a> v2/api-docs 来验证，您会发现返回的结果是一段 JSON 串，可读性非常差。幸运的是 Swagger2 为我们提供了可视化的交互界面 SwaggerUI，下面我们就一起来试试吧。</p>
<h1 id="集成-Swagger-UI"><a href="#集成-Swagger-UI" class="headerlink" title="集成 Swagger UI"></a>集成 Swagger UI</h1><h2 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>和之前一样，集成的第一步就是添加相关依赖，在 pom.xml 中添加如下内容即可：</p>
<p>清单 5. 添加 Swagger UI 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="访问验证"><a href="#访问验证" class="headerlink" title="访问验证"></a>访问验证</h2><p>其实就只需要添加一下依赖就可以了，我们重新启动一下项目，然后在浏览器中访问 <a class="link"   href="http://localhost:8080/swagger-ui.html" >http://localhost:8080/swagger-ui.html<i class="fas fa-external-link-alt"></i></a> 就可以看到如下的效果了:</p>
<p>图 1. Swagger UI</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/VdbBqK.png"
                      alt="点击查看大图"
                ></p>
<p>可以看到虽然可读性好了一些，但对接口的表述还不是那么的清楚，接下来我们就通过一些高级配置，让这份文档变的更加的易读。</p>
<h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><h2 id="文档相关描述配置"><a href="#文档相关描述配置" class="headerlink" title="文档相关描述配置"></a>文档相关描述配置</h2><ol>
<li>通过在控制器类上增加@Api 注解，可以给控制器增加描述和标签信息。</li>
</ol>
<p>清单 6. 给 Controller 添加描述信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(tags = &quot;用户相关接口&quot;, description = &quot;提供用户相关的 Rest API&quot;)</span><br><span class="line">public class UserController</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过在接口方法上增加 @ApiOperation 注解来展开对接口的描述，当然这个注解还可以指定很多内容，我们在下面的相关注解说明章节中详细解释。</li>
</ol>
<p>清单 7. 给接口添加描述信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;新增用户接口&quot;)</span><br><span class="line">@PostMapping(&quot;/add&quot;)</span><br><span class="line">public boolean addUser(@RequestBody User user) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实体描述，我们可以通过 @ApiModel 和 @ApiModelProperty 注解来对我们 API 中所涉及到的对象做描述。</li>
</ol>
<p>清单 8. 给实体类添加描述信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @ApiModelProperty(&quot;用户 id&quot;)</span><br><span class="line">private int id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>文档信息配置，Swagger 还支持设置一些文档的版本号、联系人邮箱、网站、版权、开源协议等等信息，但与上面几条不同的是这些信息不是通过注解配置，而是通过创建一个 ApiInfo 对象，并且使用 Docket.appInfo() 方法来设置，我们在 SwaggerConfig.java 类中新增如下内容即可。</li>
</ol>
<p>清单 9. 配置文档信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket api() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.select()</span><br><span class="line">            .apis(RequestHandlerSelectors.any())</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line">private ApiInfo apiInfo() &#123;</span><br><span class="line">return new ApiInfo(</span><br><span class="line">            &quot;Spring Boot 项目集成 Swagger 实例文档&quot;,</span><br><span class="line">            &quot;我的博客网站：https://itweknow.cn，欢迎大家访问。&quot;,</span><br><span class="line">            &quot;API V1.0&quot;,</span><br><span class="line">            &quot;Terms of service&quot;,</span><br><span class="line">            new Contact(&quot;名字想好没&quot;, &quot;https://itweknow.cn&quot;, &quot;gancy.programmer@gmail.com&quot;),</span><br><span class="line">                &quot;Apache&quot;, &quot;http://www.apache.org/&quot;, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的步骤，我们的文档将会变成下图的样子，现在看起来就清楚很多了。</p>
<p>图 2. 补全信息后的 Swagger 文档界面</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/VdqRkF.png"
                      alt="点击查看大图"
                ></p>
<h2 id="接口过滤"><a href="#接口过滤" class="headerlink" title="接口过滤"></a>接口过滤</h2><p>有些时候我们并不是希望所有的 Rest API 都呈现在文档上，这种情况下 Swagger2 提供给我们了两种方式配置，一种是基于 @ApiIgnore 注解，另一种是在 Docket 上增加筛选。</p>
<ol>
<li>@ApiIgnore 注解。</li>
</ol>
<p>如果想在文档中屏蔽掉删除用户的接口（user/delete），那么只需要在删除用户的方法上加上 @ApiIgnore 即可。</p>
<p>清单 10. @ApiIgnore 使用实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiIgnore</span><br><span class="line">public boolean delete(@PathVariable(&quot;id&quot;) int id)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 Docket 上增加筛选。Docket 类提供了 apis() 和 paths()两 个方法来帮助我们在不同级别上过滤接口：</li>
</ol>
<ul>
<li><p>apis()：这种方式我们可以通过指定包名的方式，让 Swagger 只去某些包下面扫描。</p>
</li>
<li><p>paths()：这种方式可以通过筛选 API 的 url 来进行过滤。</p>
</li>
</ul>
<p>在集成 Swagger2 的章节中我们这两个方法指定的都是扫描所有，没有指定任何过滤条件。如果我们在我们修改之前定义的 Docket 对象的 apis() 方法和 paths() 方法为下面的内容，那么接口文档将只会展示 /user/add 和 /user/find/{id} 两个接口。</p>
<p>清单 11. 使用 Docket 配置接口筛选</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;cn.itweknow.sbswagger.controller&quot;))</span><br><span class="line">.paths(Predicates.or(PathSelectors.ant(&quot;/user/add&quot;),</span><br><span class="line">        PathSelectors.ant(&quot;/user/find/*&quot;)))</span><br></pre></td></tr></table></figure>

<p>图 3. 经过筛选过后的 Swagger 文档界面</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/VdqcwT.png"
                      alt="点击查看大图"
                ></p>
<h2 id="自定义响应消息"><a href="#自定义响应消息" class="headerlink" title="自定义响应消息"></a>自定义响应消息</h2><p>Swagger 允许我们通过 Docket 的 globalResponseMessage() 方法全局覆盖 HTTP 方法的响应消息，但是首先我们得通过 Docket 的 useDefaultResponseMessages 方法告诉 Swagger 不使用默认的 HTTP 响应消息，假设我们现在需要覆盖所有 GET 方法的 500 和 403 错误的响应消息，我们只需要在 SwaggerConfig.java 类中的 Docket Bean 下添加如下内容：</p>
<p>清单 12. 自定义响应消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.useDefaultResponseMessages(false)</span><br><span class="line">.globalResponseMessage(RequestMethod.GET, newArrayList(</span><br><span class="line">new ResponseMessageBuilder()</span><br><span class="line">              .code(500)</span><br><span class="line">              .message(&quot;服务器发生异常&quot;)</span><br><span class="line">              .responseModel(new ModelRef(&quot;Error&quot;))</span><br><span class="line">              .build(),</span><br><span class="line">       new ResponseMessageBuilder()</span><br><span class="line">              .code(403)</span><br><span class="line">              .message(&quot;资源不可用&quot;)</span><br><span class="line">              .build()</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>添加如上面的代码后，如下图所示，您会发现在 SwaggerUI 页面展示的所有 GET 类型请求的 403 以及 500 错误的响应消息都变成了我们自定义的内容。</p>
<p>图 4. 自定义响应消息</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/Vdq6mV.png"
                      alt="点击查看大图"
                ></p>
<h1 id="Swagger-UI-的使用"><a href="#Swagger-UI-的使用" class="headerlink" title="Swagger UI 的使用"></a>Swagger UI 的使用</h1><h2 id="接口查看"><a href="#接口查看" class="headerlink" title="接口查看"></a>接口查看</h2><p>SwaggerUI 会以列表的方式展示所有扫描到的接口，初始状态是收缩的，我们只需要点击展开就好，而且会在左边标识接口的请求方式（GET、POST、PUT、DELETE 等等）。</p>
<p>图 5. Swagger 接口列表界面</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/VdqsO0.png"
                      alt="点击查看大图"
                ></p>
<h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>如下图所示，点击接口展开后页面右上角的 Try it out 按钮后，页面会变成如图所示：</p>
<p>图 6. 接口详情界面</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/Vdqryq.png"
                      alt="点击查看大图"
                ></p>
<p>SwaggerUI 会给我们自动填充请求参数的数据结构，我们需要做的只是点击 Execute 即可发起调用</p>
<p>图 7. 接口调用界面</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/VdqgTU.png"
                      alt="点击查看大图"
                ></p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>如下图所示，SwaggerUI 会通过我们在实体上使用的 @ApiModel 注解以及@ApiModelProperty 注解来自动补充实体以及其属性的描述和备注。</p>
<p>图 8. 实体界面</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://s2.ax1x.com/2019/06/06/VdqWY4.png"
                      alt="点击查看大图"
                ></p>
<h1 id="相关注解说明"><a href="#相关注解说明" class="headerlink" title="相关注解说明"></a>相关注解说明</h1><p>在本章节中我将给出一些 Swagger 中常用的注解以及其常用的属性，并对其一一解释，方便您查看。</p>
<h2 id="Controller-相关注解"><a href="#Controller-相关注解" class="headerlink" title="Controller 相关注解"></a>Controller 相关注解</h2><p>@Api: 可设置对控制器的描述。</p>
<p>表 1. @Api 主要属性<br>|注解属性    |类型    |描述|<br>| ——|——–|——–|<br>|tags    |String[]    |控制器标签。|<br>|description    |String    |控制器描述（该字段被申明为过期）。|</p>
<h2 id="接口相关注解"><a href="#接口相关注解" class="headerlink" title="接口相关注解"></a>接口相关注解</h2><ol>
<li>@ApiOperation: 可设置对接口的描述。</li>
</ol>
<p>表 2. @ApiOperation 主要属性<br>|注解属性    |类型    |描述|<br>| ——|——–|——–|<br>|value|    String|    接口说明。|<br>|notes    |String    |接口发布说明。|<br>|tags    |Stirng[]|    标签。|<br>|response    |Class&lt;?&gt;|    接口返回类型。|<br>|httpMethod|    String|    接口请求方式。|<br>2. @ApiIgnore: Swagger 文档不会显示拥有该注解的接口。</p>
<ol start="3">
<li><p>@ApiImplicitParams: 用于描述接口的非对象参数集。</p>
</li>
<li><p>@ApiImplicitParam: 用于描述接口的非对象参数，一般与 @ApiImplicitParams 组合使用。</p>
</li>
</ol>
<p>表 3. @ApiImplicitParam 主要属性<br>| 注解属性        | 描述                                                                                                                               |<br>|————-|———————————————————————————————————————————-|<br>|  paramType  |  查询参数类型，实际上就是参数放在那里。取值：path：以地址的形式提交数据，根据 id 查询用户的接口就是这种形式传参。query：Query string 的方式传参。header：以流的形式提交。form：以 Form 表单的形式提交。 |<br>|  dataType   |  参数的数据类型。取值：Long、String|<br>|  name       |  参数名字。                                                                                                                           |<br>|  value      |  参数意义的描述。                                                                                                                        |<br>|  required   |  是否必填。取值：true：必填参数。false：非必填参数。|</p>
<h2 id="Model-相关注解"><a href="#Model-相关注解" class="headerlink" title="Model 相关注解"></a>Model 相关注解</h2><ol>
<li>@ApiModel: 可设置接口相关实体的描述。</li>
<li>@ApiModelProperty: 可设置实体属性的相关描述。</li>
</ol>
<p>表 4. @ApiModelProperty 主要属性<br>|注解属性|    类型|    描述|<br>|——-|——-|——|<br>|value    |String|    字段说明。|<br>|name    |String    |重写字段名称。|<br>|dataType|    Stirng|    重写字段类型。|<br>|required    |boolean|    是否必填。|<br>|example    |Stirng|    举例说明。|<br>|hidden    |boolean    |是否在文档中隐藏该字段。|<br>|allowEmptyValue|    boolean    |是否允许为空。|<br>|allowableValues|    String    |该字段允许的值，当我们 API 的某个参数为枚举类型时，使用这个属性就可以清楚地告诉 API 使用者该参数所能允许传入的值。|</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>在本教程中，我们学会了如何使用 Swagger 2 来生成 Spring Boot REST API 的文档。我们还研究了如何过滤 API、自定义 HTTP 响应消息以及如何使用 SwaggerUI 直接调用我们的 API。您可以在 Github 上找到本教程的完整实现，这是一个基于 IntelliJ IDEA 的项目，因此它应该很容易导入和运行，当然如果您想对本教程做补充的话欢迎发邮件给我 (<a class="link"   href="mailto:&#109;&#x79;&#110;&#97;&#109;&#x65;&#x63;&#111;&#100;&#101;&#x72;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;" >&#109;&#x79;&#110;&#97;&#109;&#x65;&#x63;&#111;&#100;&#101;&#x72;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a>) 或者直接在 GitHub 上提交 Pull Request。</p>
<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a class="link"   href="https://spring.io/guides" >Spring 指南<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://spring.io/" >Spring 主页<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" >Spring Boot 参考指南<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" >Swagger 主页<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/WhenCoding/spring-tutorial/tree/master/sb-swagger" >本文源码地址<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>vue cli + axios + springboot 实现文件下载</title>
    <url>/p/2366.html</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="install-axios"><a href="#install-axios" class="headerlink" title="install axios"></a>install axios</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install axios --save</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><p>执行的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">downLoadMix() &#123;  </span><br><span class="line">  let params = &#123;&#125;;</span><br><span class="line">  let url = this.$store.state.urlPrefix+&quot;/company/download&quot;;</span><br><span class="line">  let title = null;</span><br><span class="line">    axios(&#123;  </span><br><span class="line">    method: &#x27;post&#x27;, </span><br><span class="line">    url,  </span><br><span class="line">    headers: &#123;  </span><br><span class="line">    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    data: params,  </span><br><span class="line">    responseType: &#x27;arraybuffer&#x27;  </span><br><span class="line">    &#125;).then(res =&gt; &#123;  </span><br><span class="line">        let headers = res.headers;  //后端需要配置Access-Control-Expose-Headers,否则浏览器只能访问到默认的响应头,具体如下</span><br><span class="line">        let blob = new Blob([res.data], &#123;  </span><br><span class="line">          type: headers[&#x27;content-type&#x27;]  </span><br><span class="line">        &#125;);  </span><br><span class="line">        let link = document.createElement(&#x27;a&#x27;);  </span><br><span class="line">        link.href = window.URL.createObjectURL(blob);  </span><br><span class="line">        if (!title) &#123;  </span><br><span class="line">          const fileName = headers[&#x27;content-disposition&#x27;];  </span><br><span class="line">          title = fileName.includes(&#x27;filename=&#x27;) ? fileName.split(&#x27;=&#x27;)[1] : &#x27;下载的表单文件&#x27;;  </span><br><span class="line">        &#125;  </span><br><span class="line">        link.download = title;  </span><br><span class="line">        link.click();  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="后端代码-解决axios获取Http响应头"><a href="#后端代码-解决axios获取Http响应头" class="headerlink" title="后端代码(解决axios获取Http响应头)"></a>后端代码(解决axios获取Http响应头)</h2><p>浏览器默认只能访问以下响应头</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>
<p>因此如果想让浏览器能访问到其他响应头内容的话，比如<code>Content-disposition</code>,需要在服务器上设置 <code>Access-Control-Expose-Headers</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Content-disposition&quot;);</span><br></pre></td></tr></table></figure>
<p>或者完全放开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;*&quot;);</span><br></pre></td></tr></table></figure>
<p>即可允许浏览器访问任意一个响应头，当然除次之外还要设置下载文件相关的响应头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setContentType(&quot;application/octet-stream&quot;);</span><br><span class="line">response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=createList.xls&quot;);//默认Excel名称</span><br></pre></td></tr></table></figure>
<p>后端i/o流照常处理，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/download&quot;, method = &#123;RequestMethod.POST&#125;, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)</span><br><span class="line">public void download(@RequestBody RequestFacade request, HttpServletResponse response) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        //创建工作簿</span><br><span class="line">        XSSFWorkbook wb = new XSSFWorkbook();</span><br><span class="line">        //创建一个sheet</span><br><span class="line">        XSSFSheet sheet = wb.createSheet();</span><br><span class="line"></span><br><span class="line">        // 创建单元格样式</span><br><span class="line">        XSSFCellStyle style = wb.createCellStyle();</span><br><span class="line">        style.setFillForegroundColor(HSSFColor.WHITE.index);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        response.setContentType(&quot;application/octet-stream&quot;);</span><br><span class="line">        response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=createList.xls&quot;);//默认Excel名称</span><br><span class="line">        response.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;*&quot;);</span><br><span class="line">        response.flushBuffer();</span><br><span class="line">        wb.write(response.getOutputStream());</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>「SpringBoot」如何优雅地管理SpringBoot项目</title>
    <url>/p/63677.html</url>
    <content><![CDATA[<p>本文主要讲述一下如何优雅地管理SpringBoot项目。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>课堂上，当小明形如流水地回答完沐芳老师提出来的问题时，却被至今没有对象的胖虎无情嘲讽了？</p>
<blockquote>
<p>沐芳老师：小明，你平时是如何启动、停止你的SpringBoot项目的？</p>
<p>小明（自信满满）：启动时使用<code>java -jar xxxx.jar</code>命令启动，停止服务时，使用<code>ps -ef</code>找到服务的<code>pid</code>，然后再<code>kill</code>掉停止。</p>
<p>胖虎：就这？</p>
</blockquote>
<span id="more"></span>
<p>这让小明很有挫败感，原计划按时放学回去陪隔壁小花打王者荣耀的小明，毅然决然留在教室潜心研究一番到底什么是SpringBoot优雅启动的正确姿势？经过几番挫折，小明终于搜集整理出两种优雅启动SpringBoot项目的方式分享给小明的小伙伴们。</p>
<h3 id="第一种方式：使用SHELL脚本"><a href="#第一种方式：使用SHELL脚本" class="headerlink" title="第一种方式：使用SHELL脚本"></a>第一种方式：使用SHELL脚本</h3><p>As we known 作为一个后端程序猿，每天的工作除了与前端妹子一块连调接口（拌几嘴）以外，就是终日沉浸在黑压压的Linux服务器之中，部署服务、监控服务器状态、分析日志（找bug）……因此，掌握一些常用的SHEEL脚本命令是自然而然地（迫不得已）。</p>
<blockquote>
<p>大胆胡说：什么是SHELL脚本？故名思议，她乐了（她乐你也乐）。</p>
</blockquote>
<p>因此，小明站在巨人的肩膀上，参考了一些圈内资深高级JAVA开发工程师的经验，整理了一份防嘲讽必备的SHELL脚本（Github地址见文末），只是为了自己的SpringBoot服务，只是为了不被单身的胖虎嘲讽。</p>
<p>这一份SHELL脚本很神奇，有多神奇呢？</p>
<p>你只要把这个脚本放到你的SpringBoot项目打好的jar包<strong>同级目录</strong>下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200405175500.png"
                     
                ></p>
<p>在该目录下，简单粗暴地执行下面这个命令，赋予该脚本相应执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 app.sh</span><br></pre></td></tr></table></figure>

<p>就能完成如下功能：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">./app.sh start</td>
<td align="center">启动应用</td>
</tr>
<tr>
<td align="center">./app.sh stop</td>
<td align="center">停止应用</td>
</tr>
<tr>
<td align="center">./app.sh restart</td>
<td align="center">重启应用</td>
</tr>
<tr>
<td align="center">./app.sh status</td>
<td align="center">查看应用状态</td>
</tr>
<tr>
<td align="center">./app.sh stop -f</td>
<td align="center">强制kill应用进程</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：如果一个目录下有多个jar包我们执行一个文件，那就需要指定jar包，比如<code>./app.sh start coder-xiaoming-0.0.1-SNAPSHOT.jar</code></p>
</blockquote>
<p>惊不惊喜？让大家看一下小明实操预览图，过过眼瘾先。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200405180902.png"
                     
                ></p>
<p>我们可以看到，通过运行启动命令，控制台输出提示：正在启动……并且该目录下会根据jar包名称和日期输出一个日志文件（调试bug使用）。</p>
<p>为了走一个流程，我们再查看一下应用状态，并停止应用</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200405183250.png"
                     
                ></p>
<p>篇幅有限，其他几个命令大家可以自己尝试一下。</p>
<p>当然，我们还可以尝试自定义脚本中的内容：</p>
<p>比如，<strong>gc</strong>、<strong>Xms</strong>、<strong>Xmx</strong>等针对当前服务器的实际配置进行修改；</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200405191825.png"
                     
                ></p>
<p>不同大小的项目，正常停止项目的时间也不同，因此我们还可以设置<code>restart</code>应用时的等待时间，确保应用正常停止后再启动，如下所示将等待时间设为5s。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in &#123;5..1&#125;</span><br><span class="line">do</span><br><span class="line">	echo -n &quot;$i &quot;</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>是不是感觉已经很规范很优雅了？但，故事还要继续，远没有完，小明又继续探索下去，发现如果你使用的是<strong>SpringBoot 2.0</strong>及以上的版本，那小明的小伙伴们便有福了，不需要以上的脚本就可以很优雅。接下来，看一下第二种方式。</p>
<h3 id="第二种方式：把SpringBoot以服务形式启动"><a href="#第二种方式：把SpringBoot以服务形式启动" class="headerlink" title="第二种方式：把SpringBoot以服务形式启动"></a>第二种方式：把SpringBoot以服务形式启动</h3><blockquote>
<p>英文名字：Spring Boot Application as a Service Deploying .</p>
</blockquote>
<p>搁在平时，小明在Linux服务器上启动Springboot项目，都是通过<strong>nohup</strong>命令让程序作为后台进程执行的，但是这样，程序并不好管理维护，反而显得小明和小明的伙伴们都很不专业，更好的方法是将<em>SpringBoot</em>作为<em>Service</em>启动。</p>
<p>首先需要更改打包方式，如果你使用的是maven构建的SpringBoot项目，首先将SpringBoot项目中的<strong>pom.xml</strong>中增加一个<strong>plugin</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;executable&gt;true&lt;/executable&gt;</span><br><span class="line">				&lt;/configuration&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>其中“<executable>true</executable>”一定要加，标示该jar为可执行，否则机器启动SpringBoot服务会报错。</p>
<p>如果你使用的是<strong>gradle</strong>构建的<strong>SpringBoot</strong>项目，则相应地需要增加如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">     launchScript()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来拿主要拿maven打包举例：</p>
<p>首先通过package命令打jar包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>

<p>接着，我们需要在Linux服务器上，如下所示，增加一个软连接，就可以将应用注册到Service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /opt/coder-xiaoming.jar /etc/init.d/coder-xiaoming</span><br></pre></td></tr></table></figure>

<p>其中<code>/opt/coder-xiaoming.jar</code>为你上传至服务器jar的绝对路径，一定要写全哦。<br><code>/etc/init.d/coder-xiaoming</code>里面的<code>coder-xiaoming</code>可以修改为你自己中意的名字，执行相关命令时会用到。</p>
<p>接下来，就是见证奇迹的时刻，我们通过如下命令来操作应用（和操作汤姆猫一样）：</p>
<p>启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service coder-xiaoming start</span><br></pre></td></tr></table></figure>

<p>停止服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service coder-xiaoming stop</span><br></pre></td></tr></table></figure>

<p>查看服务状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service coder-xiaoming status</span><br></pre></td></tr></table></figure>

<p>有些小伙伴可能注意到了，这样快捷操作省去很多配置，固然很方便，那启动服务时如何自定义参数呢？接着往下看。</p>
<h4 id="自定义JVM参数"><a href="#自定义JVM参数" class="headerlink" title="自定义JVM参数"></a>自定义JVM参数</h4><p>我们只需在jar包所在的同级目录下添加与jar包同名的配置文件，比如添加一个叫coder-xiaoming.conf的配置文件(名字要和jar的名字相同哦)，然后在文件里面自定义JVM参数<strong>JAVA_OPTS</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_OPTS=&quot;-Xmx4096m -Xms4096m&quot;</span><br></pre></td></tr></table></figure>

<p>这样启动时，就会读取该文件中的配置，我们查看一下进程状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure>

<p>你一定可以看到，对应的Java进程启动参数上会多了“-Xmx4096m -Xms4096m”，如果要增加其他启动参数配置同理哈。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自从小明掌握以上两个骚操作之后，在日常开发中也可以目中无人地<strong>启动/停止</strong>SpringBoot应用，极大地提高了日常工作效率，这让身旁的胖虎也呆若木鸡。这样操作的意义很大，以当前眼光来看，小明可以多陪小花打几把王者荣耀；以长远来看，这对于之后的CICD或者Docker化应用都有很大的帮助。小明的小伙伴们，你们还不赶紧应用起来？保证今晚不加班～</p>
<blockquote>
<p>附</p>
<p>sheel脚本Github地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming/blob/master/deploy/app.sh" >https://github.com/WhenCoding/coder-xiaoming/blob/master/deploy/app.sh<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>解决SpringBoot jar包中的文件读取问题</title>
    <url>/p/38722.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringBoot微服务已成为业界主流，从开发到部署都非常省时省力，但是最近小明开发时遇到一个问题：在代码中读取资源文件(比如word文档、导出模版等)，本地开发时可以正常读取 ，但是，当我们打成jar包发布到服务器后，再次执行程序时就会抛出找不到文件的异常。</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这个问题是在一次使用freemarker模版引擎导出word报告时发现的。大概说一下docx导出java实现思路：导出word的文档格式为docx，事先准备好一个排好版的docx文档作为模版，读取解析该模版，将其中的静态资源替换再导出。</p>
<blockquote>
<p>docx文档本身其实是一个压缩的zip文件，将其解压过后就会发现它有自己的目录结构。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这个docx文档所在目录如下图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20200824111042.png"
                     
                ><br>在本地调试时，我使用如下方式读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ResourceUtils;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">docxTemplate</span> <span class="operator">=</span> ResourceUtils.getFile(<span class="string">&quot;classpath:templates/docxTemplate.docx&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以正常解析使用，但是打包发布到beta环境却不可用。抛出异常如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.FileNotFoundException: <span class="keyword">class</span> <span class="title class_">path</span> resource [templates/docxTemplate.docx] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/usr/local/subject-server.jar!/BOOT-INF/classes!/templates/docxTemplate.docx</span><br></pre></td></tr></table></figure>
<p>显而易见，这个异常告诉我们：<strong>没有找到文件</strong>，但是将jar包解压过后，发现这个文件是真真实实存在的。<br>那这到底是怎么回事呢？这压根难不倒我。我们要善于透过堆栈信息看本质。通过仔细观察堆栈信息，我发现此时的文件路径并不是一个合法的URL(文件资源定位符)。原来jar包中资源有其专门的URL形式： jar:<url>!/{entry} )。所以，此时如果仍然按照标准的文件资源定位形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;jar:file:……&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>定位文件，就会抛出<strong>java.io.FileNotFoundException</strong>。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>虽然我们不能用常规操作文件的方法来读取jar包中的资源文件<strong>docxTemplate.docx</strong>，但可以通过<strong>Class</strong>类的<strong>getResourceAsStream</strong>()方法，即通过流的方式来获取 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> WordUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;templates/docxTemplate.docx&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>拿到流之后，就可以将其转换为任意一个我们需要的对象，比如<strong>File</strong>、<strong>String</strong>等等，此处我要获取<strong>docxTemplate.docx</strong>下的目录结构，因此我需要一个<strong>File</strong>对象，代码举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> WordUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;templates/docxTemplate.docx&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">docxFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;docxTemplate.docx&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用common-io的工具类即可转换</span></span><br><span class="line">        FileUtils.copyToFile(inputStream,docxFile);</span><br><span class="line">        <span class="type">ZipFile</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipFile</span>(docxFile);</span><br><span class="line">        Enumeration&lt;? <span class="keyword">extends</span> <span class="title class_">ZipEntry</span>&gt; zipEntrys = zipFile.entries();</span><br><span class="line">        <span class="comment">// todo 记得关闭流</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>打包、发布至beta环境，亲测可用，问题完美解决。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖使用Openwrt作为旁路路由实现自由访问互联网</title>
    <url>/p/16320.html</url>
    <content><![CDATA[<p>☁️ 我们云端上见！</p>
<span id="more"></span>

<h2 id="物料准备"><a href="#物料准备" class="headerlink" title="物料准备"></a>物料准备</h2><ul>
<li>NAS（群晖DS920+）</li>
<li>OpenWrt (固件版本5.15.122)</li>
<li>路由器 (华为路由AX3 Pro)</li>
</ul>
<h2 id="硬路由和软路由的区别"><a href="#硬路由和软路由的区别" class="headerlink" title="硬路由和软路由的区别"></a>硬路由和软路由的区别</h2><p>硬路由：目前我们家里普遍使用的路由器，有厂家提供整体的解决方案，包括处理器、电源供应、嵌入式软件，提供设定的路由器功能。比如常用路由器品牌有TP-Link、华为、H3C等网件等。我们平常所接触的就属于“硬”路由。</p>
<p>软路由：软路由就是台式机或服务器配合软件形成路由解决方案，主要靠应用软件的设置，从而达成路由器的功能。它是由个人电脑（X86架构的CPU）+Linux系统+专用的路由程序（openwrt、爱快、ros、lede等）组成，说白了软路由就是PC的硬件加上路由系统来实现路由器的功能。</p>
<h3 id="软路由的用途"><a href="#软路由的用途" class="headerlink" title="软路由的用途"></a>软路由的用途</h3><p>1、单线多拨<br>2、DDNS+端口映射<br>3、<strong>自由访问互联网</strong>（本文的重点）<br>4、去广告等等   </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="群晖安装虚拟机"><a href="#群晖安装虚拟机" class="headerlink" title="群晖安装虚拟机"></a>群晖安装虚拟机</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/1694265411240.png"
                      alt="1694265411240"
                ><br>直接在群晖的套件中心即可下载</p>
<h3 id="安装OpenWrt"><a href="#安装OpenWrt" class="headerlink" title="安装OpenWrt"></a>安装OpenWrt</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>我这里使用的软路由系统是OpenWrt，但是因为它是免费开源的，所以原生的openWRT基本上都是源码，需要自己编译。对于不熟悉编译的小白来说，编译时间是一个未知数。建议大家直接使用已经编译好的openWRT系统，例如由eSir大佬编译的固件，该固件经过长时间使用稳定并且更新速度快。<br><a class="link"   href="https://drive.google.com/drive/folders/1uRXg_krKHPrQneI3F2GNcSVRoCgkqESr" >下载地址<i class="fas fa-external-link-alt"></i></a><br>我选择的是“eSir GDQ高大全”版本，这是一个集成插件最多的版本，适合不太会自己装插件的朋友，可以直接菜单中启用，比较方便。<br>下载下来的是一个“.gz”的压缩文件，我们直接解压，得到一个“.img”的镜像文件，这个镜像文件就是今天需要使用的OpenWrt固件。</p>
<h4 id="导入映像"><a href="#导入映像" class="headerlink" title="导入映像"></a>导入映像</h4><p>打开VMM，开始导入解压好的OpenWrt，选择“映像–硬盘映像–新增–从计算机”，可以修改映像名称“openwrt”，固件便会自动上传到我们的NAS虚拟机，当看到“状态”那里显示为良好，说明准备就绪。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909221438.png"
                      alt="20230909221438"
                ></p>
<h4 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h4><ul>
<li><p>选择“虚拟机–新增（下拉框）–导入”，选择“<strong>从磁盘映像导入</strong>”，然后下一步，如图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909222055.png"
                      alt="20230909222055"
                ></p>
</li>
<li><p>选择默认存储空间，然后，下一步，如图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909222623.png"
                      alt="20230909222623"
                ></p>
</li>
</ul>
<ul>
<li><p>设置配置规格，CPU和内存容量因为选择的是比较大的“高大全版本”的openWRT固件，两个都选择了“2”。如图：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909222908.png"
                      alt="20230909222908"
                ></p>
</li>
<li><p>虚拟盘这里选择刚才磁盘映像中的OpenWrt文件，然后继续下一步。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909223147.png"
                      alt="20230909223147"
                ></p>
</li>
<li><p>网络这里需要点击旁边的“设置”图标，然后在型号那里选择“e1000”（全双工），在点击“确定”。全双工的优势明显，默认的是半双工，所以我们这里需要更改一下即可。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909223423.png"
                      alt="20230909223423"
                ></p>
</li>
<li><p>这一步，选择自动启动<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909223651.png"
                      alt="20230909223651"
                ></p>
</li>
<li><p>下一步，选择自己的群晖NAS管理员账户</p>
</li>
<li><p>开机<br>稍等一会，看见状态那里显示“运行中”时候，就可以点击“连接”按钮就可以进入openWRT的后台了。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909223942.png"
                      alt="20230909223942"
                ></p>
</li>
<li><p>配置openwrt账号密码<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909224027.png"
                      alt="20230909224027"
                ><br>根据提示，按下回车键激活控制台，然后就开始输入命令了：<br>  1.输入“passwd”，回车<br>  2.输入密码，回车<br>  3.再次输入密码，回车<br>输入密码的时候是没有显示的，随意输入，确保两次输入的一样即可，这个就是我们稍后的openWRT软路由登录密码。</p>
</li>
<li><p>网络配置<br>这里我们需要修改openwrt的lan口ip地址，保证修改后的ip地址与路由器内网处于同一个网段，并且不能与其他设备的ip地址重复，这样才能正常访问openwrt管理后台的页面。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/config/network</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909224545.png"
                      alt="20230909224545"
                ></p>
<p>修改过后，输入<code>:wq</code>进行保存，如图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909225219.png"
                      alt="20230909225219"
                ></p>
<ul>
<li>重启openwrt<br>在黑窗口，输入命令行<code>reboot</code>，回车。重启后，在地址栏输入刚刚修改的ip地址，就可以打开openwrt的后台管理平台<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909225830.png"
                      alt="20230909225830"
                ></li>
</ul>
<p>输入设置的密码，进行登录，首页如图所示：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230909230306.png"
                      alt="20230909230306"
                ></p>
<h3 id="配置Openwrt"><a href="#配置Openwrt" class="headerlink" title="配置Openwrt"></a>配置Openwrt</h3><p>我们将OpenWrt作为华为路由器AX3 Pro（主路由）的旁路路由，这样做有个好处，不需要修改现有网络基础设施（不影响你女朋友刷剧），只需要在标准的局域网拓扑结构中，增加一个网关设备就行了。网关设备和一个普通的局域网设备在结构上是同等地位。</p>
]]></content>
      <tags>
        <tag>NAS</tag>
        <tag>软路由</tag>
        <tag>群晖</tag>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装Homebrew并配置Redis</title>
    <url>/p/707c.html</url>
    <content><![CDATA[<h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><p>如果已经安装Homebrew，可以忽略，没有安装的请查看小明之前写好的文章 <a href="#">Post not found: Mac安装Homebrew并更换国内镜像源 Mac安装Homebrew的那些事儿</a></p>
<h2 id="使用Homebrew安装Redis"><a href="#使用Homebrew安装Redis" class="headerlink" title="使用Homebrew安装Redis"></a>使用Homebrew安装Redis</h2><h5 id="1-安装命令"><a href="#1-安装命令" class="headerlink" title="(1) 安装命令"></a>(1) 安装命令</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>

<h5 id="2-查看软件安装及配置文件位置"><a href="#2-查看软件安装及配置文件位置" class="headerlink" title="(2) 查看软件安装及配置文件位置"></a>(2) 查看软件安装及配置文件位置</h5><p>Homebrew安装的软件会默认在<code>/usr/local/Cellar/</code>路径下；</p>
<p>redis的配置文件<code>redis.conf</code>存放在<code>/usr/local/etc</code>路径下。</p>
<h5 id="3-启动redis服务"><a href="#3-启动redis服务" class="headerlink" title="(3) 启动redis服务"></a>(3) 启动redis服务</h5><h6 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h6><p>brew除了可以帮助我们安装软件以外，还可以帮助我们启动软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew services start redis</span><br></pre></td></tr></table></figure>

<h6 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server /usr/local/etc/redis.conf</span><br></pre></td></tr></table></figure>

<h5 id="4-查看redis服务进程"><a href="#4-查看redis服务进程" class="headerlink" title="(4) 查看redis服务进程"></a>(4) 查看redis服务进程</h5><p>我们可以通过下面命令查看redis是否正在运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps axu | grep redis</span><br></pre></td></tr></table></figure>

<h5 id="5-redis-cli连接redis服务"><a href="#5-redis-cli连接redis服务" class="headerlink" title="(5) redis-cli连接redis服务"></a>(5) redis-cli连接redis服务</h5><p>redis默认端口号<strong>6379</strong>，默认<strong>auth</strong>为空，输入以下命令即可连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>

<h5 id="6-关闭redis服务"><a href="#6-关闭redis服务" class="headerlink" title="(6) 关闭redis服务"></a>(6) 关闭redis服务</h5><p>优雅的关闭<code>redis-cli shutdown</code>或者杀死<code>sudo pkill redis-server</code></p>
<h5 id="7-redis-conf配置文件说明"><a href="#7-redis-conf配置文件说明" class="headerlink" title="(7) redis.conf配置文件说明"></a>(7) redis.conf配置文件说明</h5><p>redis默认是前台启动，如果我们想以守护进程的方式运行（后台运行），可以在<strong>redis.conf</strong>中将<code>daemonize no</code>,修改成<code>yes</code>即可。</p>
]]></content>
  </entry>
  <entry>
    <title>Redis如何保证高性能的？</title>
    <url>/p/30403.html</url>
    <content><![CDATA[<p>参考链接：<a class="link"   href="https://blog.csdn.net/m0_63437643/article/details/129438077" >https://blog.csdn.net/m0_63437643/article/details/129438077<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>「日志」Redis开启事务</title>
    <url>/p/65482.html</url>
    <content><![CDATA[<blockquote>
<p>日常开发中往往会有一些业务场景，需要支持一个key多个序列化操作，比如维护一个大小为2的队列，当有新元素过来时，需要先获取队列中的第一个元素与新数据比较，当满足条件时，再操作队列，左边lpush，右边rpop，就这样循环往复，保证该队列是有序的，并且第一个元素永远是最新的。这个场景对应的一系列操作在高并发的场景下，就需要通过redis的事务保证顺序执行。</p>
</blockquote>
<h2 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h2><p>Redis 事务可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。<br>Redis 的事务在形式上看起来也差不多，分为三个阶段</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队（业务操作）</li>
<li>执行事务（exec）或取消事务（discard）<br>举例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; lpush xiaoming hello</span><br><span class="line">QUEUED</span><br><span class="line">&gt; lpush xiaoming world</span><br><span class="line">QUEUED</span><br><span class="line">&gt; exec</span><br><span class="line">1) &quot;OK&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;OK&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;OK&quot;</span><br></pre></td></tr></table></figure>

<p>上面的指令演示了一个完整的事务过程，所有的指令在 exec 之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。<br>Redis 事务可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。<br>可以保证一个队列中，一次性、顺序性、排他性的执行一系列命令（Redis 事务的主要作用其实就是串联多个命令防止别的命令插队）<br>官方文档是这么说的</p>
<blockquote>
<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MULTI</td>
<td>标记一个事务块的开始</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行所有事务块内的命令</td>
</tr>
<tr>
<td>DISCARD</td>
<td>取消事务，放弃执行事务块内的所有命令</td>
</tr>
<tr>
<td>WATCH</td>
<td>监视一个（或多个）key，如果在事务执行之前这个（或多个）key被其他命令所改动，那么事务将被打断</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消 WATCH 命令对所有 keys 的监视</td>
</tr>
</tbody></table>
<h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><p>我们用 Redis 事务的时候，可能会遇上以下两种错误：</p>
<ul>
<li><p>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</p>
</li>
<li><p>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</p>
</li>
</ul>
<p>Redis 针对如上两种错误采用了不同的处理策略：</p>
<ul>
<li><p>对于发生在 EXEC 执行之前的错误，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务（Redis 2.6.5 之前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败）</p>
</li>
<li><p>对于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p>
</li>
</ul>
<p>接下来我们实际操作一下：</p>
<h3 id="事务执行EXEC前发生错误"><a href="#事务执行EXEC前发生错误" class="headerlink" title="事务执行EXEC前发生错误"></a>事务执行EXEC前发生错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;multi</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">&gt;lpush xiaoming hello</span><br><span class="line">&quot;QUEUED&quot;</span><br><span class="line">&gt;lpush xiaoming</span><br><span class="line">&quot;ERR wrong number of arguments for &#x27;lpush&#x27; command&quot;</span><br><span class="line">0&gt;exec</span><br><span class="line">&quot;EXECABORT Transaction discarded because of previous errors.&quot;</span><br><span class="line">0&gt;</span><br></pre></td></tr></table></figure>
<p>某一条操作记录报错的话，exec 后所有操作都不会成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0&gt;multi</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">set xiaoming hello </span><br><span class="line">&quot;QUEUED&quot;</span><br><span class="line">0&gt;decr xiaoming</span><br><span class="line">&quot;QUEUED&quot;</span><br><span class="line">set coder hello</span><br><span class="line">&quot;QUEUED&quot;</span><br><span class="line">0&gt;exec</span><br><span class="line">1) &quot;OK&quot;</span><br><span class="line">2) &quot;OK&quot;</span><br><span class="line">3) &quot;OK&quot;</span><br><span class="line">4) &quot;ERR value is not an integer or out of range&quot;</span><br><span class="line">5) &quot;OK&quot;</span><br><span class="line">6) &quot;OK&quot;</span><br><span class="line">7) &quot;OK&quot;</span><br><span class="line">0&gt;mget xiaoming coder</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>示例中 <code>xiaoming</code> 被设置为 String 类型，<code>decr xiaoming</code> 可以放入操作队列中，因为只有在执行的时候才可以判断出语句错误，其他正确的会被正常执行。</p>
<h2 id="为什么-Redis-不支持回滚"><a href="#为什么-Redis-不支持回滚" class="headerlink" title="为什么 Redis 不支持回滚"></a>为什么 Redis 不支持回滚</h2><p>如果你有使用关系式数据库的经验，那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是官方的自夸：</p>
<blockquote>
<p>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。<br>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。<br>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。<br>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
</blockquote>
<h2 id="带-Watch-的事务"><a href="#带-Watch-的事务" class="headerlink" title="带 Watch 的事务"></a>带 Watch 的事务</h2><p>WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务将被打断，不再执行， 直接返回失败。</p>
<p>WATCH命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</p>
<p>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; WATCH key1 key2 key3 </span><br><span class="line">OK </span><br></pre></td></tr></table></figure>

<p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。另外，当客户端断开连接时，该客户端对键的监视也会被取消。</p>
<p>我们看个简单的例子，用 watch 监控我的账号余额（一周100零花钱），正常消费</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0&gt;set balance 100</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">0&gt;watch balance </span><br><span class="line">&quot;OK&quot;</span><br><span class="line">0&gt;multi</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">0&gt;decrby balance 20</span><br><span class="line">&quot;QUEUED&quot;</span><br><span class="line">0&gt;decrby balance 30</span><br><span class="line">&quot;QUEUED&quot;</span><br><span class="line">0&gt;exec</span><br><span class="line">1) &quot;OK&quot;</span><br><span class="line">2) &quot;80&quot;</span><br><span class="line">3) &quot;OK&quot;</span><br><span class="line">4) &quot;50&quot;</span><br><span class="line">5) &quot;OK&quot;</span><br></pre></td></tr></table></figure>

<p>上面的示例好像没有体现出来watch的作用，我们再举个生动的例子。<br>辛苦搬砖一天的小明，洗漱过后，躺在床上打开王者荣耀，犹豫再三是否要首充6块钱，迟迟没付款。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0&gt;set balance 100</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">0&gt;watch balance</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">0&gt;multi </span><br><span class="line">&quot;OK&quot;</span><br><span class="line">&gt;decrby balance 6</span><br><span class="line">&quot;QUEUED&quot;</span><br></pre></td></tr></table></figure>
<p>而此时此刻，我对象在一旁观看主播带货，喜欢上了两支口红，并且在李佳琪”上链接！“的口令下，果断立即下单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0&gt;decrby balance 100</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure>

<p>毫不知情的我，这个时候终于决定结账，却发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0&gt;exec</span><br><span class="line">(空)</span><br></pre></td></tr></table></figure>

<p>扣款失败，到底发生了什么呢？</p>
<p>原来watch指令，类似乐观锁，事务提交时，如果 key 的值已被别的客户端改变，比如某个 list 已被别的客户端修改过了，整个事务队列都不会被执行。（当然也可以用 Redis 实现分布式锁来保证安全性，属于悲观锁）</p>
<p>通过 watch 命令在事务执行之前监控了多个 keys，倘若在 watch 之后有任何 key 的值发生变化，exec 命令执行的事务都将被放弃，同时返回 Null 应答以通知调用者事务执行失败。</p>
<blockquote>
<p>悲观锁<br>悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p>
</blockquote>
<blockquote>
<p>乐观锁<br>乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。乐观锁策略：提交版本必须大于记录当前版本才能执行更新</p>
</blockquote>
<p>WATCH 命令的实现原理<br>在代表数据库的 server.h/redisDb 结构类型中， 都保存了一个 watched_keys 字典， 字典的键是这个数据库被监视的键， 而字典的值是一个链表， 链表中保存了所有监视这个键的客户端，如下图。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20210923002716.png"
                     
                ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line">    unsigned long expires_cursor; /* Cursor of the active expire cycle. */</span><br><span class="line">    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */</span><br><span class="line">&#125; redisDb;</span><br><span class="line"></span><br><span class="line">list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */</span><br></pre></td></tr></table></figure>

<p>WATCH 命令的作用， 就是将当前客户端和要监视的键在 watched_keys 中进行关联。</p>
<p>举个例子， 如果当前客户端为 client99 ， 那么当客户端执行 WATCH key2 key3 时， 前面展示的 watched_keys 将被修改成这个样子：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20210923002651.png"
                     
                ></p>
<p>通过 watched_keys 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p>
<p>在任何对数据库键空间（key space）进行修改的命令成功执行之后 （比如 FLUSHDB、SET 、DEL、LPUSH、 SADD，诸如此类）， multi.c/touchWatchedKey 函数都会被调用 —— 它会去 watched_keys 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个/这些被修改键的客户端的 REDIS_DIRTY_CAS 选项打开：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20210923002750.png"
                     
                ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void multiCommand(client *c) &#123;</span><br><span class="line">    // 不能在事务中嵌套事务</span><br><span class="line">    if (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,&quot;MULTI calls can not be nested&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 打开事务 FLAG</span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* &quot;Touch&quot; a key, so that if this key is being WATCHed by some client the</span><br><span class="line"> * next EXEC will fail. */</span><br><span class="line">void touchWatchedKey(redisDb *db, robj *key) &#123;</span><br><span class="line">    list *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    // 字典为空，没有任何键被监视</span><br><span class="line">    if (dictSize(db-&gt;watched_keys) == 0) return;</span><br><span class="line">    // 获取所有监视这个键的客户端</span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    if (!clients) return;</span><br><span class="line"></span><br><span class="line">    // 遍历所有客户端，打开他们的 CLIENT_DIRTY_CAS 标识</span><br><span class="line">    listRewind(clients,&amp;li);</span><br><span class="line">    while((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端发送 EXEC 命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p>
<p>如果客户端的 CLIENT_DIRTY_CAS 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。<br>如果 CLIENT_DIRTY_CAS 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</p>
<h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><h3 id="3-个阶段"><a href="#3-个阶段" class="headerlink" title="3 个阶段"></a>3 个阶段</h3><p>开启：以 MULTI 开始一个事务<br>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面<br>执行：由 EXEC 命令触发事务</p>
<h3 id="3-个特性"><a href="#3-个特性" class="headerlink" title="3 个特性"></a>3 个特性</h3><p>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</p>
<p>不保证原子性：Redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚<br>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的安全性。Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Redis 事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络 IO 时间也会线性增长。所以通常 Redis 的客户端在执行事务时都会结合 pipeline 一起使用，这样可以将多次 IO 操作压缩为单次 IO 操作。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的延迟双删</title>
    <url>/p/12006.html</url>
    <content><![CDATA[<p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问Mysql等数据库。这样可以大大缓解数据库的压力。具体业务流程如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20230621144019.png"
                     
                ></p>
<p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存和数据库间的数据一致性问题。不管是先写数据库，再删除缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举个例子：</p>
<p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p>
<p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p>
<p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。如何解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。</p>
<p>一、 延时双删策略</p>
<p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。具体步骤是：</p>
<p>1）先删除缓存<br>2）再写数据库<br>3）休眠500毫秒（根据具体的业务时间来定）<br>4）再次删除缓存。</p>
<p>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</p>
<p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>当然，这种策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。</p>
<p>二、设置缓存的过期时间</p>
<p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存</p>
<p>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p>
<p>三、如何写完数据库后，再次删除缓存成功？</p>
<p>上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时，可能就会出现数据不一致的情况。这里，我们需要提供一个保障重试的方案。</p>
<p>1、方案一具体流程</p>
<p>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败；<br>（3）将需要删除的key发送至消息队列；<br>（4）自己消费消息，获得需要删除的key；<br>（5）继续重试删除操作，直到成功。</p>
<p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<p>2、方案二具体流程</p>
<p>（1）更新数据库数据；<br>（2）数据库会将操作信息写入binlog日志当中；<br>（3）订阅程序提取出所需要的数据以及key；<br>（4）另起一段非业务代码，获得该信息；<br>（5）尝试删除缓存操作，发现删除失败；<br>（6）将这些信息发送至消息队列；<br>（7）重新从消息队列中获得该数据，重试操作。</p>
<p>以上方案都是在业务中经常会碰到的场景，可以依据业务场景的复杂和对数据一致性的要求来选择具体的方案</p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 2.x集成redis作为cache</title>
    <url>/p/3388.html</url>
    <content><![CDATA[<blockquote>
<p>参考自 <a class="link"   href="https://blog.csdn.net/sy793314598/article/details/80719224" >springbot2.x整合redis做缓存<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h1 id="redis的相关配置"><a href="#redis的相关配置" class="headerlink" title="redis的相关配置"></a>redis的相关配置</h1><h2 id="引入相关依赖"><a href="#引入相关依赖" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h2><p>首先使用maven引入spring-redis相关的依赖，2.0中使用spring-boot-starter-data-redis代替了原来的spring-boot-starter-redis</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置redis数据库"><a href="#配置redis数据库" class="headerlink" title="配置redis数据库"></a>配置redis数据库</h2><p>在SpringBoot的application.yml配置文件中配置redis数据库的相关信息，这里改动主要有两点，其一是时间相关的属性，如spring.redis.timeout，在1.0中，时间相关的配置参数类型为int，默认单位为毫秒，配置中只需指定具体的数字即可，而在2.0中，时间相关的配置的参数类型都改为了jdk1.8的Duration，因此在配置文件中配置redis的连接超时时间timeout时，需要加入时间单位，如60s；其二是，在2.0中配置redis的连接池信息时，不再使用spring.redis.pool的属性，而是直接使用redis的lettuce或jedis客户端来配置，具体配置信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    password: gitlab</span><br><span class="line">    port: 6379</span><br><span class="line">    database: 10</span><br><span class="line">    timeout: 3s  # 数据库连接超时时间，2.0 中该参数的类型为Duration，这里在配置的时候需要指明单位</span><br><span class="line">    # 连接池配置，2.0中直接使用*jedis*或者lettuce配置连接池</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        # 最大空闲连接数</span><br><span class="line">        max-idle: 500</span><br><span class="line">        # 最小空闲连接数</span><br><span class="line">        min-idle: 50</span><br><span class="line">        # 等待可用连接的最大时间，负数为不限制</span><br><span class="line">        max-wait:  -1s</span><br><span class="line">        # 最大活跃连接数，负数为不限制</span><br><span class="line">        max-active: -1</span><br></pre></td></tr></table></figure>
<h2 id="配置CacheManager"><a href="#配置CacheManager" class="headerlink" title="配置CacheManager"></a>配置CacheManager</h2><p>通过配置Spring的CacheManager为redis，即可指定使用redis做缓存，具体的配置方式跟1.0也有所不同，在1.0中使用RedisTemplate即可实例化一个RedisCacheManager：RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);，在2.0中删除了这个构造器，同时也不可以通过之前的setDefaultExpiration方法设置默认的缓存过期时间等，在新版本中可以通过以下的两种方式构造一个RedisCacheManager：</p>
<h3 id="通过RedisCacheManager的静态方法create"><a href="#通过RedisCacheManager的静态方法create" class="headerlink" title="通过RedisCacheManager的静态方法create"></a>通过RedisCacheManager的静态方法create</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public CacheManager cacheManager(RedisConnectionFactory factory) &#123;</span><br><span class="line">    RedisCacheManager cacheManager = RedisCacheManager.create(factory);</span><br><span class="line">    return cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样产生的cacheManager只是使用Spring提供的默认配置</p>
<h3 id="通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder-build-的方式生成cacheManager："><a href="#通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder-build-的方式生成cacheManager：" class="headerlink" title="通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder.build()的方式生成cacheManager："></a>通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder.build()的方式生成cacheManager：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassName RedisConfig class</span><br><span class="line"> * @Author xin</span><br><span class="line"> * @Date 2019-03-27</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(60))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        return RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .transactionAware()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置RedisTemplate，进行简单的key、value相关操作"><a href="#配置RedisTemplate，进行简单的key、value相关操作" class="headerlink" title="配置RedisTemplate，进行简单的key、value相关操作"></a>配置RedisTemplate，进行简单的key、value相关操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisTemplate redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">    StringRedisTemplate template = new StringRedisTemplate(factory);</span><br><span class="line"></span><br><span class="line">    RedisSerializer keySerializer = new StringRedisSerializer(); // 设置key序列化类，否则key前面会多了一些乱码</span><br><span class="line">    template.setKeySerializer(keySerializer);</span><br><span class="line">    setValueSerializer(template);//设置value序列化</span><br><span class="line">    template.afterPropertiesSet();</span><br><span class="line">    template.setEnableTransactionSupport(true);</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setValueSerializer(StringRedisTemplate template) &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">    ObjectMapper om = new ObjectMapper();</span><br><span class="line">    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">    template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Redis的缓存雪崩、击穿、穿透?</title>
    <url>/p/19331.html</url>
    <content><![CDATA[<p>🎄 Redis 作为缓存层注意事项</p>
<span id="more"></span>
<p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p>
<p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p>
<p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219104940.png"
                     
                ></p>
<p>引入了缓存层，就会有缓存异常的三个问题，分别是缓存雪崩、缓存击穿、缓存穿透。</p>
<p>这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219104959.png"
                     
                ></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219105159.png"
                     
                ></p>
<p>那么，当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219105228.png"
                     
                ></p>
<p>可以看到，发生缓存雪崩有两个原因：</p>
<ul>
<li>大量数据同时过期；</li>
<li>Redis 故障宕机；</li>
</ul>
<blockquote>
<p>不同的诱因，应对的策略也会不同。</p>
</blockquote>
<h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p>
<ul>
<li>均匀设置过期时间；</li>
<li>互斥锁；</li>
<li>双 key 策略；</li>
<li>后台更新缓存；</li>
</ul>
<p><em>1. 均匀设置过期时间</em></p>
<p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p>
<p><em>2. 互斥锁</em></p>
<p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
<p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p>
<p><em>3. 双 key 策略</em></p>
<p>我们对缓存数据可以使用两个 key，一个是<strong>主 key，会设置过期时间</strong>，一个是<strong>备 key，不会设置过期</strong>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p>
<p>当业务线程访问不到「主 key」的缓存数据时，就直接返回「备 key」的缓存数据，然后在更新缓存的时候，<strong>同时更新「主 key」和「备 key」的数据。</strong></p>
<p>双 key 策略的好处是，当主 key 过期了，有大量请求获取缓存数据的时候，直接返回备 key 的数据，这样可以快速响应请求。而不用因为 key 失效而导致大量请求被锁阻塞住（采用了互斥锁，仅一个请求来构建缓存），后续再通知后台线程，重新构建主 key 的数据。</p>
<p><em>4. 后台更新缓存</em></p>
<p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p>
<p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p>
<p>解决上面的问题的方式有两种。</p>
<p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p>
<p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p>
<p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p>
<p>在业务刚上线的时候，我们最好提前把数据缓存起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p>
<h3 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h3><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p>
<ul>
<li>服务熔断或请求限流机制；</li>
<li>构建 Redis 缓存高可靠集群；</li>
</ul>
<p><em>1. 服务熔断或请求限流机制</em></p>
<p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p>
<p>服务熔断机制是保护数据库的正常运行，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p>
<p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
<p><em>2. 构建 Redis 缓存高可靠集群</em></p>
<p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p>
<p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p>
<hr>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p>
<p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219105828.png"
                      alt="20231219105828"
                ></p>
<p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p>
<p>应对缓存击穿可以采取前面说到两种方案：</p>
<ul>
<li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ul>
<hr>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当发生缓存雪崩或击穿时，<strong>数据库中还是保存了应用要访问的数据</strong>，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p>
<p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219105845.png"
                      alt="20231219105845"
                ></p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li>第一种方案，非法请求的限制；</li>
<li>第二种方案，缓存空值或者默认值；</li>
<li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</li>
</ul>
<h3 id="非法请求的限制"><a href="#非法请求的限制" class="headerlink" title="非法请求的限制"></a>非法请求的限制</h3><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断出请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p>
<h3 id="缓存空值或者默认值"><a href="#缓存空值或者默认值" class="headerlink" title="缓存空值或者默认值"></a>缓存空值或者默认值</h3><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p>
<h3 id="使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。"><a href="#使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。" class="headerlink" title="使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。*"></a>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。*</h3><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p>
<p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p>
<p>那问题来了，布隆过滤器是如何工作的呢？接下来，我介绍下。</p>
<p>布隆过滤器由「初始值都为 0 的位图数组」和「N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p>
<p>布隆过滤器会通过 3 个操作完成标记：</p>
<ul>
<li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li>
<li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li>
</ul>
<p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219105856.png"
                      alt="20231219105856"
                ></p>
<p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p>
<p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p>
<p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p>
<p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p>
<p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p>
<p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20231219110533.png"
                      alt="20231219110533"
                ></p>
<h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      width="200" height="200"  align="center" 
                >]]></content>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Redis 实现滑动窗口的限流</title>
    <url>/p/5881.html</url>
    <content><![CDATA[<p>⏳ 限流场景：突发流量，恶意流量，业务本身需要</p>
<span id="more"></span>

<p>基于 Redis 实现滑动窗口的限流是一种常见且高效的做法。Redis 是一种内存数据库，具有高性能和支持原子操作的特点，非常适合用来实现限流功能。下面是一个使用 Redis 实现基于滑动窗口的限流算法的简单示例：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20240222171858.png"
                      alt="20240222171858"
                ></p>
<p>📐其实这个方法就是把上边的粒度进行切分，切分成更小力度的计数器，就像是上边的切分成一小块一小块，每块时间超出了指定的请求就阻挡在外，越小力度，则限流越好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SlidingWindowRateLimiter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, window_size, limit, redis_conn</span>):</span><br><span class="line">        self.window_size = window_size</span><br><span class="line">        self.limit = limit</span><br><span class="line">        self.redis_conn = redis_conn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allow_request</span>(<span class="params">self, key</span>):</span><br><span class="line">        current_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">        pipeline = self.redis_conn.pipeline()</span><br><span class="line">        pipeline.zadd(key, &#123;current_time: current_time&#125;)</span><br><span class="line">        pipeline.zremrangebyscore(key, <span class="string">&#x27;-inf&#x27;</span>, current_time - self.window_size)</span><br><span class="line">        pipeline.expire(key, self.window_size / <span class="number">1000</span> + <span class="number">1</span>)  <span class="comment"># 设置过期时间，略大于窗口大小</span></span><br><span class="line">        pipeline.execute()</span><br><span class="line"></span><br><span class="line">        count = self.redis_conn.zcard(key)</span><br><span class="line">        <span class="keyword">if</span> count &lt;= self.limit:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们利用 Redis 的有序集合（sorted set）来实现滑动窗口。每个请求到达时，都会向有序集合中添加当前时间戳，并通过 <code>zremrangebyscore</code> 方法移除超出时间窗口范围的时间戳。最后，通过 <code>zcard</code> 方法统计有序集合中的成员数量，从而判断是否允许新的请求。</p>
<p>需要注意的是，上述代码仅为示例，实际应用中可能需要考虑更多因素，比如分布式环境下的原子操作、并发访问的线程安全性、异常处理等。另外，在实际生产环境中，还可以结合 Lua 脚本和 Redis 的事务机制来实现更复杂的限流策略。</p>
<p>总之，基于 Redis 实现滑动窗口的限流是一种常见且高效的做法，可以有效地控制系统的并发访问量。</p>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用「爱屋及乌」推送电子书到Kindle</title>
    <url>/p/43315.html</url>
    <content><![CDATA[<p>送给深度读书用户的一个礼物。</p>
<span id="more"></span>
<p>当然仅限小明的朋友们，24h侵删。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>手机或者电脑访问书库：<a class="link"   href="http://book.mynamecoder.com:6868/" >爱屋及乌<i class="fas fa-external-link-alt"></i></a>，点击右上角“注册”按钮。输入你常用的邮箱即可开始注册，该邮箱主要用于接收账号的登录密码，所以一定要保证该邮箱能够正常使用哦^.^。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>注册成功后，我们就可以去自己邮箱中查看登录所用的初始密码（该密码登录后可以自行修改），用邮箱+密码即可进入系统。<br>映入眼帘的都是书友们最近要看的书，她长这个样子：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/Xnip2022-05-28_21-18-54.jpg"
                     
                ><br>当然，这只是书架的冰山一角的一角（树大招风，你懂撒），在书架背后，是千千万万个数据库，一定有一本书在等着你，「爱屋及乌」只是安排你们相见的桥梁！<br>并且，「爱屋及乌」特别愿意根据您的找书需求来扩充我们的储备，一般24时内就能帮您找到走丢的孩子（书籍）并放置于书架，服务是我们的核心竞争力💪🏻</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="默认语言的修改"><a href="#默认语言的修改" class="headerlink" title="默认语言的修改"></a>默认语言的修改</h4><p>进入系统后，你还会发现整个界面是英文的，如果不习惯（我说的是如果），可以点击右上角“小人”进行默认语言修改（习惯的话当我没说Orz）。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220528175036.png"
                     
                ></p>
<h4 id="设置接收书籍的邮箱地址"><a href="#设置接收书籍的邮箱地址" class="headerlink" title="设置接收书籍的邮箱地址"></a>设置接收书籍的邮箱地址</h4><p>每个Kindle（不管是设备或者应用）都有一个独一无二接收书籍的邮件地址，因此，我们需要查看一下当前Kindle设备接收书籍的邮箱地址，有两种方式：</p>
<h6 id="方式一：直接在-Kindle-设备中获取"><a href="#方式一：直接在-Kindle-设备中获取" class="headerlink" title="方式一：直接在 Kindle 设备中获取"></a>方式一：直接在 Kindle 设备中获取</h6><p>如果Kindle正在你身边，可以在 Kindle 中依次点击 菜单 -&gt; 设置 -&gt; 设备选项 -&gt; 个性化您的 Kindle”，就可以看到一个“〖发送至 Kindle〗电子邮件地址”，这就是当前设备接收推送的邮箱地址。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220528191630.png"
                     
                ></p>
<h6 id="方式二：浏览器获取"><a href="#方式二：浏览器获取" class="headerlink" title="方式二：浏览器获取"></a>方式二：浏览器获取</h6><p>浏览器登录<a class="link"   href="https://www.amazon.cn/gp/digital/fiona/manage" >亚马逊账户<i class="fas fa-external-link-alt"></i></a> -&gt; 鼠标悬浮“账户及列表” -&gt; 管理我的内容和设备 -&gt; 首选项 -&gt; 点击“个人文档设置”，在页面中就可以看到“〖发送至Kindle〗电子邮箱”这一项，列表中有“***@kindle.cn”字样的邮箱地址（@前的名字可点击编辑自定义），这就是接收推送文档的目标邮箱，如果你有多个设备就会有多个邮箱地址，你只要关注你即将要推送设备的邮箱地址即可。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220528190824.png"
                     
                ></p>
<p>获取接收书籍的Kindle邮箱地址之后，我们就可以将该邮件地址按下图所示填入书库：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220528182015.png"
                     
                ></p>
<h4 id="添加推送邮箱地址到已认可邮箱列表"><a href="#添加推送邮箱地址到已认可邮箱列表" class="headerlink" title="添加推送邮箱地址到已认可邮箱列表"></a>添加推送邮箱地址到已认可邮箱列表</h4><p>为防止恶意内容推送，亚马逊的个人文档推送机制只接收已认可的发件人电子邮箱列表中的邮箱，所以我们需要额外设置一下安全邮箱。<br>浏览器登录<a class="link"   href="https://www.amazon.cn/gp/digital/fiona/manage" >亚马逊账户<i class="fas fa-external-link-alt"></i></a> -&gt; 鼠标悬浮“账户及列表” -&gt; 管理我的内容和设备 -&gt; 首选项-&gt; 点击“个人文档设置” -&gt; 添加认可的电子邮箱，把<a class="link"   href="mailto:&#99;&#111;&#100;&#101;&#114;&#x78;&#x6d;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;" >&#99;&#111;&#100;&#101;&#114;&#x78;&#x6d;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;<i class="fas fa-external-link-alt"></i></a>邮箱地址（「爱屋及乌」官方认证的邮箱，请放心添加）添加进去，如下图所示。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/20220528191258.png"
                     
                ><br>都配置好以后，我们就可以随便选择一本书推送试一下，如果没有推送权限可以联系小明，添加微信：myzone95，备注：我爱小明，搞错了，重来，请备注：我爱读书！</p>
<p>以上就是如何使用<a class="link"   href="http://book.mynamecoder.com/" >「爱屋及乌」<i class="fas fa-external-link-alt"></i></a>推送电子书到Kindle的教程，咱们书友的目标是千万不要让自己的Kindle成为泡面盖，期待大家成为小明的会员，进入我们的书友群，一起分享好书！赶紧动起来吧~~</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"
                      alt="程序员小明"
                ><br>公众号：一个非著名程序员的日常</p>
]]></content>
      <tags>
        <tag>Kindle</tag>
      </tags>
  </entry>
</search>
