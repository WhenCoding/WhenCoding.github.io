<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员小明 | Java | Spring Boot | Spring Cloud | ElasticSearch |日常开发 |最新干货分享</title>
  
  <subtitle>一个不想加班的程序员</subtitle>
  <link href="https://mynamecoder.com/atom.xml" rel="self"/>
  
  <link href="https://mynamecoder.com/"/>
  <updated>2024-02-23T03:35:33.000Z</updated>
  <id>https://mynamecoder.com/</id>
  
  <author>
    <name>小明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql事务隔离级别是怎么实现的？</title>
    <link href="https://mynamecoder.com/p/41447.html"/>
    <id>https://mynamecoder.com/p/41447.html</id>
    <published>2024-02-23T11:01:15.000Z</published>
    <updated>2024-02-23T03:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>💿 看了这么多文章，这篇文章是真正的深入浅出</p><span id="more"></span><blockquote><p>摘自<a class="link"   href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html" >小林coding<i class="fas fa-external-link-alt"></i></a>，有所调整</p></blockquote><p>这是我的钱包，共有 100 万元。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223110151.png"                      alt="20240223110151"                ></p><p>今天我心情好，我决定给你的转账 100 万，最后的结果肯定是我的余额变为 0 元，你的余额多了 100 万元，是不是想到就很开心？</p><p>转账这一动作在程序里会涉及到一系列的操作，假设我向你转账 100 万的过程是有下面这几个步骤组成的：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223110235.png"                      alt="20240223110235"                ></p><p>可以看到这个转账的过程涉及到了两次修改数据库的操作。</p><p>假设在执行第三步骤之后，服务器忽然掉电了，就会发生一个蛋疼的事情，我的账户扣了 100 万，但是钱并没有到你的账户上，也就是说这 <strong>100 万消失了</strong></p><p>要解决这个问题，就要保证转账业务里的<strong>所有数据库的操作是不可分割的，要么全部执行成功 ，要么全部失败，不允许出现中间状态的数据</strong>。</p><p>数据库中的 <strong>「事务（Transaction）」</strong> 就能达到这样的效果。</p><p>我们在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。</p><p>没错，今天就来图解 MySQL 事务啦，开车！</p><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，<strong>所以大多数 MySQL 的引擎都是用 InnoDB</strong>。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p><ul><li><p>原子性（Atomicity）<br>一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</p></li><li><p>隔离性（Isolation）<br>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时，由于交叉执行而导致数据的不一致。因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</p></li><li><p>持久性（Durability）<br>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li><li><p>一致性（Consistency）<br>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。<br>比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</p></li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>持久性是通过 redo log （重做日志）来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><p>这次将重点介绍事务的<strong>隔离性</strong>，这也是面试时最常问的知识的点。</p><p>为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。</p><h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p><p>那么在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。</p><p>接下来，通过举例子给大家说明，这些问题是如何发生的。</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223111032.png"                      alt="20240223111032"                ></p><p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223111116.png"                      alt="20240223111116"                ></p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223111157.png"                      alt="20240223111157"                ></p><p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p><p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</p><h2 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h2><p>前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p><p>脏读：读到其他事务未提交的数据；<br>不可重复读：前后读取的数据不一致；<br>幻读：前后读取的记录数量不一致。<br>这三个现象的严重性排序如下：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223111417.png"                      alt="20240223111417"                ></p><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p><ul><li>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；</li><li>可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>按隔离水平高低排序如下：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223111425.png"                      alt="20240223111425"                ></p><p>针对不同的隔离级别，并发事务时<strong>可能</strong>发生的现象也会不同。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223111514.png"                      alt="20240223111514"                ></p><p>也就是说：</p><ul><li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li><li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li><li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li><li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li><li>所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。</li></ul><p>不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别，我们讨论的 MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入。</p><p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（<strong>注意是很大程度避免，并不是彻底避免</strong>），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。解决的方案有两种：</p><ul><li><p>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</p></li><li><p>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</p></li></ul><p>接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223111709.png"                      alt="20240223111709"                ></p><p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p><ul><li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li><li>在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li><li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li><li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li></ul><p>这四种隔离级别具体是如何实现的呢？</p><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View</strong> 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li></ul><p><strong>注意</strong>，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，这两种开启事务的命令，事务的启动时机是不同的：</p><ul><li><p>第一种：begin/start transaction 命令；<br>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；</p></li><li><p>第二种：start transaction with consistent snapshot 命令；<br>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</p></li></ul><p>接下来详细说下，Read View 在 MVCC 里如何工作的？</p><h2 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h2><p>我们需要了解两个知识：</p><ul><li>Read View 中四个字段作用；</li><li>聚簇索引记录中两个跟事务有关的隐藏列；</li></ul><p>那 Read View 到底是个什么东西？</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223112159.png"                      alt="20240223112159"                ></p><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是创建该 Read View 的事务的事务 id。</li><li>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</li></ul><p>假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223112212.png"                      alt="20240223112212"                ></p><p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，以链表的形式指向每一个旧版本记录，于是就可以通过它找到修改前的记录。</li></ul><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。</li><li>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。</li><li>如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。</li></ul></li></ul><p>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</p><h3 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h3><p>接下来，我们一起了解下实际是如何工作的，可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223112552.png"                      alt="20240223112552"                ></p><p>事务 A 和 事务 B 的 Read View 具体内容如下：</p><ul><li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li><li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，活跃的事务 id 中最小的事务 id 是事务 A，下一个事务 id 应该是 53。</li></ul><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p>接下来，跟大家具体分析下。</p><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223112711.png"                      alt="20240223112711"                ></p><p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。</p><p>然后事务 B 第二次去读取该记录，发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id <strong>「小于」</strong>事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录。</p><p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p><h3 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h3><p>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。</p><p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：</p><ul><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li></ul><p>那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223112959.png"                      alt="20240223112959"                ></p><p>我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？</p><p>事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？<br>与隔离级别为可重复读不同的是，读已提交会在事务 A 提交后，事务 B 在每次读数据的时候，会重新创建 Read View，此时事务 B 第三次读取数据时创建的 Read View 如下：<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240223113136.png"                      alt="20240223113136"                ></p><p>事务 B 在找到小林这条记录时，会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的。</p><p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>以上就是Mysql事务隔离级别的理解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;💿 看了这么多文章，这篇文章是真正的深入浅出&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://mynamecoder.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务管理及失效总结</title>
    <link href="https://mynamecoder.com/p/5122.html"/>
    <id>https://mynamecoder.com/p/5122.html</id>
    <published>2024-02-22T17:21:42.000Z</published>
    <updated>2024-02-23T09:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-事务管理及失效总结"><a href="#Spring-事务管理及失效总结" class="headerlink" title="Spring 事务管理及失效总结"></a>Spring 事务管理及失效总结</h2><p>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。  </p><p>Spring 并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给 Hibernate 或者 JTA 等持久化机制所提供的相关平台框架的事务来实现。  </p><p> Spring 事务管理器接口： <code>org.springframework.transaction.PlatformTransactionManager</code> ，通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager) 等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><h3 id="Spring-事务的分类"><a href="#Spring-事务的分类" class="headerlink" title="Spring 事务的分类"></a>Spring 事务的分类</h3><p>Spring 提供了两种事务管理方式：<strong>声明式事务管理</strong>和<strong>编程式事务管理</strong>。对不同的持久层访问技术，编程式事务提供一致的事务编程风格，通过模板化的操作一致性地管理事务；而声明式事务基于 Spring AOP 实现，却并不需要程序开发者成为 AOP 专家，亦可轻易使用 Spring 的声明式事务管理。</p><p><strong>声明式事务</strong></p><p>Spring 的声明式事务管理是建立在 Spring AOP 机制之上的，其本质是对目标方法前后进行拦截，并在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><p>简单地说，声明式事务是<strong>编程式事务 + AOP 技术</strong>包装，使用注解进行扫包，指定范围进行事务管理。声明式事务管理要优于编程式事务管理，这正是 Spring 倡导的非侵入式的开发方式。  </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> transactionDemo &#123;</span><br><span class="line">  <span class="comment">// TODO 业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编程式事务</strong></p><p>在 Spring 出现以前，编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中显式调用 beginTransaction()、commit()、rollback() 等事务管理相关的方法，这就是编程式事务管理。  </p><p>简单地说，编程式事务就是在代码中显式调用开启事务、提交事务、回滚事务的相关方法，因此代码侵入性较大。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">transactionStatus</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TODO 业务代码</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 提交事务</span></span><br><span class="line">          <span class="built_in">this</span>.transactionManager.commit(transactionStatus);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// 回滚事务</span></span><br><span class="line">          <span class="built_in">this</span>.transactionManager.rollback(transactionStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-事务的原理"><a href="#Spring-事务的原理" class="headerlink" title="Spring 事务的原理"></a>Spring 事务的原理</h3><p>使用 AOP <strong>环绕通知</strong> 和 <strong>异常通知</strong>。  </p><p>注意： 在使用 Spring 事务时不能使用 <code>try-catch</code> 进行异常捕获，要将异常抛给外层，使其进行异常拦截，触发事务机制。</p><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><p>所谓事务的传播行为是指如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>在 Spring 中有七种事务传播行为， 下面我们就来看看吧。</p><p><strong>REQUIRED</strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。@Transactional 注解默认使用就是这个事务传播行为。<br>也就是说：</p><ul><li>如果外部方法没有开启事务的话，REQUIRED 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务并且被 REQUIRED 的话，所有 REQUIRED 修饰的内部方法和外部方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        classB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 REQUIRED 传播行为修饰的 methodA() 和 methodB() 的话，两者使用的就是同一个事务，只要其中一个方法发生回滚，整个事务都回滚。</p><p><strong>REQUIRES_NEW</strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说，不管外部方法是否开启事务，REQUIRES_NEW 修饰的内部方法会开启一个新的事务。如果外部方法开启事务，则两个事务互不干扰，相互独立，并且外部事务会挂起，等待内部事务执行完后，才继续执行。</p><p>示列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        classB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 REQUIRED 事务传播行为修饰 methodA()，使用 REQUIRES_NEW 修饰 methodB()。那么，methodA() 发生异常回滚，methodB() 是不会跟着回滚，因为 methodB() 开启了独立的事务。但是，如果 methodB() 发生异常回滚了，并且抛出的异常被 methodA() 的事务管理机制检测到了，methodA() 也会回滚。</p><p><strong>SUPPORTS</strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。不常用。</p><p><strong>NOT_SUPPORTED</strong></p><p>以非事务方式运行，如果当前存在事务，则把当前事务挂起。它可以帮助将事务极可能的缩小，因为一个事务越大，它存在的风险也就越多，所以在处理事务的过程中，要保证尽可能的缩小范围。</p><p>示列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        classB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 执行 1000 次非核心业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如 methodB() 执行循环 1000 次的非核心业务逻辑操作，并且它处在 methodA() 的事务中，这样会造成事务太大，导致出现一些难以考虑周全的异常情况。所以，使用 NOT_SUPPORTED 修饰 methodB()，当执行到 methodB() 时，将 methodA() 的事务挂起，等 methodB() 以非事务的状态运行完成后，再继续 methodA() 的事务。</p><p><strong>NEVER</strong></p><p>以非事务方式运行，如果当前存在事务，则抛出抛出Runtime 异常，强制停止执行。 </p><p>如果 methodA() 是使用 REQUIRED 修饰的， 而methodB() 的是使用 NEVER 修饰的。当执行到 methodB() 时，就要抛出异常了。</p><p><strong>MANDATORY</strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。也就是说，MANDATORY 要求上下文中必须要存在事务，否则就会抛出异常。</p><p>配置 MANDATORY 级别的事务是有效控制上下文调用代码而遗漏添加事务管理的保证手段。比如，一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用 MANDATORY 级别的事务。</p><p><strong>NESTED</strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 <strong>REQUIRED</strong>。</p><p>也就是说，如果外部方法开启事务的话，NESTED 修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。因为 NESTED 事务它有一个 savepoint，在内部方法执行失败后进行回滚，外部方法也会回滚到 savepoint 点上。此时，如果外部方法将内部方法抛出的异常进行了捕获则会继续往下执行直到完成自己的事务。如果外部方法没有捕获异常，则会根据事务规则进行回滚。</p><p>如果外部方法未开启事务，NESTED 和 REQUIRED 作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p>示列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methoA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// savepoint</span></span><br><span class="line">classB.methodB();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO 执行其他业务</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> star</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 methodB() 执行失败后进行回滚，methodA() 也会回滚到 savepoint 点上，而 methodA() 捕获了 methodB() 抛出的异常，继续执行自己的业务代码。</p><h3 id="基于注解-Transactional-声明事务失效分析"><a href="#基于注解-Transactional-声明事务失效分析" class="headerlink" title="基于注解 @Transactional 声明事务失效分析"></a>基于注解 @Transactional 声明事务失效分析</h3><p>在开发过程中，可能会遇到使用 @Transactional 进行事务管理时出现失效的情况。这里我们的讨论是基于事务的默认传播行为是 <code>REQUIRED</code>。</p><p><strong>常见失效场景</strong>  </p><ul><li><p>如果使用 MySQL 且引擎是 MyISAM，则事务会不起作用，原因是 MyISAM 不支持事务，改成 InnoDB 引擎则支持事务。</p></li><li><p>注解 @Trasactional 只能加在 <code>public</code> 修饰的方法上事务才起效。如果加在 <code>protect</code>、<code>private</code> 等非 <code>public</code> 修饰的方法上，事务将失效。</p></li><li><p>如果在开启了事务的方法内，使用了 <code>try-catch</code> 语句块对异常进行了捕获，而没有将异常抛到外层，事务将不起效。</p></li><li><p>在不同类之间的方法调用中，如果 A 方法开启了事务，B 方法没有开启事务，B 方法调用了 A 方法。</p><ul><li>如果 B 方法中发生异常，但不是调用的 A 方法产生的，则异常不会使 A 方法的事务回滚，此时事务无效。</li><li>如果 B 方法中发生异常，异常是调用的 A 方法产生的，则 A 方法的事务回滚，此时事务有效。</li><li>在 B 方法上加上注解 @Trasactional，这样 A 和 B 方法就在同一个事务里了，不管异常产生在哪里，事务都是有效的。   </li><li>简单地说，不同类之间方法调用时，异常发生在无事务的方法中，但不是被调用的方法产生的，被调用的方法的事务无效。只有异常发生在开启事务的方法内，事务才有效。</li></ul></li><li><p>在同一个类的方法之间调用中，如果 A 方法调用了 B 方法，不管 A 方法有没有开启事务，由于 Spring 的代理机制 B 方法的事务是无效的。但是，如果 A 方法开启 REQUIRED 事务，由于事务传播机制，B 方法会自动加入到 A 的事务中。</p></li><li><p>如果使用了 Spring + MVC，则 <code>context:component-scan</code> 重复扫描问题可能会引起事务失效。</p></li></ul><p><strong>原因分析</strong></p><p>在应用系统调用声明 @Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，再由这个代理对象来统一管理。  </p><p>Spring 事务是使用 AOP 环绕通知和异常通知，就是对方法进行拦截，在方法执行前开启事务，在捕获到异常时进行事务回滚，在方法执行完成后提交事务。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Spring 团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。    </p><p>Spring 文档中写到：Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理，如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个CGLIB代理。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a class="link"   href="https://juejin.im/post/5b00c52ef265da0b95276091#heading-9" >https://juejin.im/post/5b00c52ef265da0b95276091#heading-9<i class="fas fa-external-link-alt"></i></a> </p><p><a class="link"   href="https://blog.csdn.net/rylan11/article/details/76609643" >https://blog.csdn.net/rylan11/article/details/76609643<i class="fas fa-external-link-alt"></i></a>  </p><p><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/73733278" >https://blog.csdn.net/justloveyou_/article/details/73733278<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring-事务管理及失效总结&quot;&gt;&lt;a href=&quot;#Spring-事务管理及失效总结&quot; class=&quot;headerlink&quot; title=&quot;Spring 事务管理及失效总结&quot;&gt;&lt;/a&gt;Spring 事务管理及失效总结&lt;/h2&gt;&lt;p&gt;所谓事务管理，其实就是“按照</summary>
      
    
    
    
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Spring" scheme="https://mynamecoder.com/tags/Spring/"/>
    
    <category term="事务" scheme="https://mynamecoder.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于 Redis 实现滑动窗口的限流</title>
    <link href="https://mynamecoder.com/p/5881.html"/>
    <id>https://mynamecoder.com/p/5881.html</id>
    <published>2024-02-22T16:47:36.000Z</published>
    <updated>2024-02-23T03:35:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>⏳ 限流场景：突发流量，恶意流量，业务本身需要</p><span id="more"></span><p>基于 Redis 实现滑动窗口的限流是一种常见且高效的做法。Redis 是一种内存数据库，具有高性能和支持原子操作的特点，非常适合用来实现限流功能。下面是一个使用 Redis 实现基于滑动窗口的限流算法的简单示例：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240222171858.png"                      alt="20240222171858"                ></p><p>📐其实这个方法就是把上边的粒度进行切分，切分成更小力度的计数器，就像是上边的切分成一小块一小块，每块时间超出了指定的请求就阻挡在外，越小力度，则限流越好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SlidingWindowRateLimiter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, window_size, limit, redis_conn</span>):</span><br><span class="line">        self.window_size = window_size</span><br><span class="line">        self.limit = limit</span><br><span class="line">        self.redis_conn = redis_conn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allow_request</span>(<span class="params">self, key</span>):</span><br><span class="line">        current_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">        pipeline = self.redis_conn.pipeline()</span><br><span class="line">        pipeline.zadd(key, &#123;current_time: current_time&#125;)</span><br><span class="line">        pipeline.zremrangebyscore(key, <span class="string">&#x27;-inf&#x27;</span>, current_time - self.window_size)</span><br><span class="line">        pipeline.expire(key, self.window_size / <span class="number">1000</span> + <span class="number">1</span>)  <span class="comment"># 设置过期时间，略大于窗口大小</span></span><br><span class="line">        pipeline.execute()</span><br><span class="line"></span><br><span class="line">        count = self.redis_conn.zcard(key)</span><br><span class="line">        <span class="keyword">if</span> count &lt;= self.limit:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们利用 Redis 的有序集合（sorted set）来实现滑动窗口。每个请求到达时，都会向有序集合中添加当前时间戳，并通过 <code>zremrangebyscore</code> 方法移除超出时间窗口范围的时间戳。最后，通过 <code>zcard</code> 方法统计有序集合中的成员数量，从而判断是否允许新的请求。</p><p>需要注意的是，上述代码仅为示例，实际应用中可能需要考虑更多因素，比如分布式环境下的原子操作、并发访问的线程安全性、异常处理等。另外，在实际生产环境中，还可以结合 Lua 脚本和 Redis 的事务机制来实现更复杂的限流策略。</p><p>总之，基于 Redis 实现滑动窗口的限流是一种常见且高效的做法，可以有效地控制系统的并发访问量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;⏳ 限流场景：突发流量，恶意流量，业务本身需要&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://mynamecoder.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql使用索引的优缺点</title>
    <link href="https://mynamecoder.com/p/23407.html"/>
    <id>https://mynamecoder.com/p/23407.html</id>
    <published>2024-02-01T16:56:22.000Z</published>
    <updated>2024-02-01T09:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>📖 Mysql索引总结一览</p><span id="more"></span><p><strong>创建索引的优点：</strong></p><ol><li>提高系统性能。</li><li>保证数据唯一性。</li><li>加快数据检索速度。</li><li>加速表间连接，有助于数据参考完整性。</li><li>减少排序和分组操作时间。</li></ol><p><strong>索引的缺点：</strong></p><ol><li>创建和维护索引耗费时间，随数据量增加而增加。</li><li>占用额外物理空间。</li><li>数据增删改时需动态维护索引，降低维护速度。</li></ol><p><strong>创建索引的准则：</strong></p><ul><li><p>应创建索引的列：</p><ol><li>经常需要搜索的列。</li><li>作为主键的列。</li><li>经常用于连接的列（如外键）。</li><li>需要根据范围搜索的列。</li><li>经常需要排序的列。</li><li>经常用于WHERE子句的列。</li></ol></li><li><p>不应创建索引的列：</p><ol><li>很少使用的列。</li><li>取值很少的列。</li><li>定义为text, image和bit数据类型的列。</li><li>修改性能远大于检索性能的情况。</li></ol></li></ul><p><strong>创建索引的方法：</strong></p><ol><li>直接创建，如使用CREATE INDEX语句或索引向导。</li><li>间接创建，通过定义主键约束或唯一性键约束时自动创建。</li></ol><p><strong>索引的特征：</strong></p><ul><li>唯一性索引：保证索引列数据唯一。</li><li>复合索引：在两个或多个列上创建的索引。</li></ul><p><strong>索引的类型：</strong></p><ul><li>聚簇索引：数据表物理顺序与索引顺序相同。</li><li>非聚簇索引：数据表物理顺序与索引顺序不相同。</li></ul><p><strong>聚簇索引体系结构：</strong></p><ul><li>类似树状结构，顶部为叶级，其余为非叶级。数据页是叶级，索引页是非叶级。</li></ul><p><strong>系统如何访问表中的数据：</strong></p><ul><li>表扫描：逐页扫描直至找到符合条件的记录。</li><li>索引查找：沿索引树状结构查找符合条件的记录。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;📖 Mysql索引总结一览&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://mynamecoder.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java中深拷贝和浅拷贝的区别</title>
    <link href="https://mynamecoder.com/p/13516.html"/>
    <id>https://mynamecoder.com/p/13516.html</id>
    <published>2024-01-24T18:34:24.000Z</published>
    <updated>2024-02-23T03:36:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>👯‍♀️ 老虎老鼠傻傻分不清楚</p><span id="more"></span><p>在Java中，对象的拷贝可以分为深拷贝和浅拷贝。</p><ul><li>浅拷贝</li></ul><p>是指创建一个新对象，然后将原对象的非静态字段值复制到新对象中。如果字段是基本数据类型，那么对应的值会被复制；如果字段是引用类型，那么只会复制引用而不是创建新的对象。这意味着原对象和拷贝对象将共享同一个引用对象。如果修改其中一个对象的引用类型字段，另一个对象也会受到影响。</p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>是指创建一个新对象，并将原对象的所有字段（无论是基本数据类型还是引用类型）都复制到新对象中。这样，原对象和拷贝对象将完全独立，互不影响。</p><h2 id="实现深拷贝有多种方式："><a href="#实现深拷贝有多种方式：" class="headerlink" title="实现深拷贝有多种方式："></a>实现深拷贝有多种方式：</h2><ol><li>实现Cloneable接口，并重写clone()方法。在clone()方法中，对于引用类型的字段，需要创建新的对象并复制其内容。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> intValue;</span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line">    <span class="keyword">private</span> MyObject objectValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.objectValue = (MyObject) objectValue.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用序列化和反序列化实现深拷贝。将对象写入字节流，然后从字节流中读取数据创建一个新的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Serializable</span>&gt; T <span class="title function_">deepCopy</span><span class="params">(T object)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时可以调用<code>DeepCopyUtil.deepCopy()</code>方法来进行深拷贝。</p><p>需要注意的是，要实现深拷贝，对象及其所有引用类型字段都必须实现Cloneable接口或者可序列化（Serializable）。否则，在进行深拷贝时会抛出异常。</p><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;👯‍♀️ 老虎老鼠傻傻分不清楚&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 中反射的作用及应用场景是什么？</title>
    <link href="https://mynamecoder.com/p/20050.html"/>
    <id>https://mynamecoder.com/p/20050.html</id>
    <published>2024-01-24T14:19:48.000Z</published>
    <updated>2024-02-01T09:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>🐤 你小子喜欢走后门？</p><span id="more"></span><p>Java 反射机制的作用是在运行时获取类的信息，并可以动态地操作对象或者调用方法。通过反射机制，可以在运行时获取类的属性和方法，并且可以在运行时调用这些方法或者实例化对象，从而实现一些动态性的操作。</p><p>Java 反射机制的应用场景非常广泛，例如：</p><ul><li>在 Spring 框架中，使用反射机制实现依赖注入和自动装配；</li><li>在 Hibernate 框架中，使用反射机制实现对象的持久化和查询；</li><li>在 JUnit 单元测试框架中，使用反射机制动态地创建测试对象并调用测试方法；</li><li>在 Android 应用开发中，使用反射机制实现动态生成界面和修改界面元素属性等。<br>以下是一个简单的示例代码，演示了如何使用反射机制创建对象、设置属性和调用方法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflectionExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取类的 Class 对象</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(&quot;com.example.Person&quot;);</span><br><span class="line"></span><br><span class="line">            // 创建对象</span><br><span class="line">            Object person = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            // 设置属性</span><br><span class="line">            Field nameField = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">            nameField.setAccessible(true);</span><br><span class="line">            nameField.set(person, &quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">            Field ageField = clazz.getDeclaredField(&quot;age&quot;);</span><br><span class="line">            ageField.setAccessible(true);</span><br><span class="line">            ageField.set(person, 18);</span><br><span class="line"></span><br><span class="line">            // 调用方法</span><br><span class="line">            Method sayHelloMethod = clazz.getDeclaredMethod(&quot;sayHello&quot;);</span><br><span class="line">            sayHelloMethod.setAccessible(true);</span><br><span class="line">            sayHelloMethod.invoke(person);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, my name is &quot; + name + &quot;, I&#x27;m &quot; + age + &quot; years old.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们通过 <code>Class.forName()</code> 方法获取了 <code>Person</code> 类的 <code>Class</code> 对象，并通过 <code>newInstance()</code> 方法创建了 <code>Person</code> 类的实例。接着，我们使用反射机制设置了 <code>Person</code> 类的 <code>name</code> 和 <code>age</code> 属性的值，然后调用了 <code>Person</code> 类的 <code>sayHello()</code> 方法，并打印了方法的输出结果。</p><p>需要注意的是，在使用反射时<strong>需要处理异常</strong>，否则程序可能会崩溃。同时，反射的使用也<strong>会带来一定的性能损失</strong>，因此在实际开发中需要谨慎使用。</p><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;🐤 你小子喜欢走后门？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾回收算法及详细过程（二）</title>
    <link href="https://mynamecoder.com/p/58033.html"/>
    <id>https://mynamecoder.com/p/58033.html</id>
    <published>2024-01-22T16:50:34.000Z</published>
    <updated>2024-01-24T06:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>😆 分代垃圾算法有点像垃圾分类的感觉</p><span id="more"></span><h2 id="堆内存回收过程详解"><a href="#堆内存回收过程详解" class="headerlink" title="堆内存回收过程详解"></a>堆内存回收过程详解</h2><p>我们分析了如何判断对象是否可回收，还有 3 种基础的垃圾回收算法，以及年轻代、老年代的内存区域划分与原因。接下来我们就一步一步来分析堆内存的回收流程。</p><h3 id="内存初始状态"><a href="#内存初始状态" class="headerlink" title="内存初始状态"></a>内存初始状态</h3><p>假设在第一垃圾回收之前，内存中的状态如图所示，Eden 区有 2 个存活对象，4 个垃圾对象，内存的可用区域已经所剩无几，Survivor 区因为还没有进行任何 MinorGC 所以是空的，有 1 个大对象直接分配到了老年代。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122164943.png"                      alt="20240122164943"                ></p><h3 id="第-1-次执行-MinorGC-后状态"><a href="#第-1-次执行-MinorGC-后状态" class="headerlink" title="第 1 次执行 MinorGC 后状态"></a>第 1 次执行 MinorGC 后状态</h3><p>当新的对象分配到 Eden 区，发现内存空间不够，于是触发第一次 MinorGC，垃圾回收器首先将 Edne 区中的两个存活对象复制到 S0 区，然后在清空 Eden 区的空间，如下图：<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122170929.png"                      alt="20240122170929"                ></p><h3 id="程序运行一段时间后状态"><a href="#程序运行一段时间后状态" class="headerlink" title="程序运行一段时间后状态"></a>程序运行一段时间后状态</h3><p>经过第 1 次 MinorGC 程序再运行一段时间后，堆内存状态如下：Eden 区又产生了大量的对象，并且大部分对象都可回收状态，这也符合对象“朝生夕灭”的特征，S0 区中也有 1 个对象可以回收，S1 与老年代没有变化，在这种状态下，如果新对象分配再次触发 MinorGC 会发生什么呢？<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122171022.png"                      alt="20240122171022"                ></p><h3 id="执行第-2-次-MinorGC-后状态"><a href="#执行第-2-次-MinorGC-后状态" class="headerlink" title="执行第 2 次 MinorGC 后状态"></a>执行第 2 次 MinorGC 后状态</h3><p>新对象分配 Eden 区空间不足，又触发了第二次 MinorGC，第二次 MinorGC 与第一次 GC 时在 Eden 区的操作是一样的：将 Eden 区存活的对象复制到 S1 区，然后在清空整个 Eden 区，同时也将 S0 区存活的对象复制到 S1 区并将对象的年龄加 1，再清空 S0 区，GC 后的状态如下图所示：<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122171104.png"                      alt="20240122171104"                ></p><h3 id="执行第-2-次-MinorGC-后，程序运行一段时间后状态"><a href="#执行第-2-次-MinorGC-后，程序运行一段时间后状态" class="headerlink" title="执行第 2 次 MinorGC 后，程序运行一段时间后状态"></a>执行第 2 次 MinorGC 后，程序运行一段时间后状态</h3><p>经过第二 MinorGC 后程序又运行了一段时间，Eden 区中有生成了很多对象，S1 区也有一个对象可回收。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122172309.png"                      alt="20240122172309"                ></p><h3 id="第-15-次-MinorGC-后内存状态"><a href="#第-15-次-MinorGC-后内存状态" class="headerlink" title="第 15 次 MinorGC 后内存状态"></a>第 15 次 MinorGC 后内存状态</h3><p>在接下来的每次 MinorGC 时，都是第二次一样，从 Eden 区和 survivor 非空白区移动存活对象到 survivor 区中空白区域，并清空这两个区域内存空间，存活对象每此从 survivor 两个区域移动一次，对象年龄加 1，下图表示经过了 15 次 MinorGC 后的堆内存状态。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122172330.png"                      alt="20240122172330"                ></p><p>对于年轻代区域的内存收集，使用的是标记-复制算法，只是为了减少复制算法空白区域的内存浪费，并不是将内存一份为二，而是巧妙的将内存分为三个区域，预留的空白区域只占整个年轻代区域的 1/10。</p><h2 id="对象如何进入老年代"><a href="#对象如何进入老年代" class="headerlink" title="对象如何进入老年代"></a>对象如何进入老年代</h2><p>以上是年轻代的分配与回收问题，那对象如何进入老年代呢？个人认为对象进入老年代，可以分为 2 种类型 6 种情况。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122173016.png"                      alt="20240122173016"                ></p><h3 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a>直接分配</h3><p>对象创建时直接分配到老年代具体分为 3 种情况：</p><ul><li>超过虚拟机 PretenureSizeThreshold 参数设置大小的对象，该参数的默认值是 0，也就是说任何大小的对象都会先分配到 Eden 区。</li><li>超过 Eden 大小的对象</li><li>如果新生代分配失败，一个大数组或者大字符串</li></ul><h3 id="从年轻代晋升"><a href="#从年轻代晋升" class="headerlink" title="从年轻代晋升"></a>从年轻代晋升</h3><p>从年轻代空间晋升到老年代也可分为 3 种情况：</p><ul><li>新生代分配担保，在执行 MinorGC 时要将 Eden 区存活的对象复制到 Survivor 区，但是 Survivor 区默认空间是只有新生代的 2/10，实际使用的只有 1/10，当 Survivor 区内存不够所有存活对象分配时，就需要将 Survivor 无法容纳的对象分配到老年代去，这种机制就叫<strong>分配担保</strong>。</li><li>对象年龄超过虚拟机 MaxTenuringThreshold 的设置值，最大为 15，</li><li>Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半（TargetSurvivorRatio），年龄大于或等于该年龄的对象直接进入老年代。</li></ul><h3 id="老年代回收算法-FullGC"><a href="#老年代回收算法-FullGC" class="headerlink" title="老年代回收算法-FullGC"></a>老年代回收算法-FullGC</h3><p>当有对象要进入老年代，而老年代空间又不足时就会触发 FullGC，当然，反过来说触发 FullGC 的条件不仅仅只是老年代空间不足，FullGC 使用的算法是上面说的标记-整理算法。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122173120.png"                      alt="20240122173120"                ></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>判断对象<strong>是否可以回收</strong>是垃圾回收的基础与前提，通过可达性分析从 GCRoots 开始进行”顺藤摸瓜”找到不可达对象（可回收）</li><li>对象生命周期的特征”朝生夕灭”与”越战越强”是垃圾回收算法的理论基础</li><li>基础的垃圾回收算法有 3 种分别是 标记-清除算法、标记-复制算法、标记整理算法，都有各自的适应场合与优缺点</li><li><strong>分代垃圾算法</strong>根据对象生命周期的特征，将其划分到不同的区域，从而使用最适合的垃圾算法来进行优化</li><li>在 JDK8 默认的配置下使用 新生代，老年代的垃圾回收策略，<strong>新生代区域使用标记-复制算法，老年代区域使用标记-整理算法</strong></li></ul><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;😆 分代垃圾算法有点像垃圾分类的感觉&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾回收算法及详细过程（一）</title>
    <link href="https://mynamecoder.com/p/3205.html"/>
    <id>https://mynamecoder.com/p/3205.html</id>
    <published>2024-01-18T17:35:07.000Z</published>
    <updated>2024-01-24T06:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>😬 图文并茂才能更快掌握</p><span id="more"></span><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>理解 Java 虚拟机垃圾回收机制的底层原理，是系统调优与线上问题排查的基础，也是一个高级 Java 程序员的基本功，本文就针对 Java 垃圾回收这一主题做一些整理与记录。Java 垃圾回收器的种类繁多，它们的设计要在吞吐量（内存空间）与实时性（用户线程中断）方面进行权衡，各个垃圾回收器的适应场景也不尽相同（如：桌面应用，web 应用），因此，这里我们只讨论 JDK8 下的默认垃圾回收器，毕竟目前 JDK8 版本是业界的主流（占 80%），并且我们只讨论堆内存空间的垃圾回收。</p><p>JDK8 下的默认垃圾回收器：UseParallelGC ： Parallel （新生代）+ （老年代）堆内存回收机制</p><h2 id="如何判断对象是否可回收？"><a href="#如何判断对象是否可回收？" class="headerlink" title="如何判断对象是否可回收？"></a>如何判断对象是否可回收？</h2><p>首先思考一个问题，内存堆中那么多对象，回收器要回收哪些对象？怎么判断出这些要回收的对象呢？因此对于垃圾回收，判断并标识对象是否可回收是第一步。从理论层面来说，判断对象是否可回收一般两种方法。</p><ul><li><p>引用计数器算法<br>每当对象被引用一次计数器加 1，对象失去引用计数器减 1，计数器为 0 是就可以判断对象死亡了。这种算法简单高效，但是对于循环引用或其他复杂情况，需要更多额外的开销，因此 Java 几乎不使用该算法。</p></li><li><p>根搜索算法-可达性分析算法<br>所谓可达性分析是指，顺着 GCRoots 根一直向下搜索（用一个成语概括就是“顺藤摸瓜”），整个搜索的过程就构成了一条“引用链”，只要在引用链上的对象叫做可达，在引用链之外的（说明跟 GCRoots 没有任何关系）叫不可达，不可达的对象就可以判断为可回收的对象。 哪些对象可作为 GCRoots 对象呢？ 包括如下：</p><ul><li>虚拟机栈帧上本地变量表中的引用对象（方法参数、局部变量、临时变量）</li><li>方法区中的静态属性引用类型对象、常量引用对象</li><li>本地方法栈中的引用对象（Native 方法的引用对象）</li><li>Java 虚拟机内部的引用对象，如异常对象、系统类加载器等</li><li>所以被同步锁（synchronize）持有的对象</li><li>Java 虚拟机内部情况的注册回调、本地缓存等</li></ul></li></ul><blockquote><p>如果对虚拟机的内存布局与运行流程有所了解的话，这些作为 GCRoots 都很好理解，它们是程序运行时的源头，程序的正常运行必须依赖它们，而与这些源头没有任何关系的对象，即可视为可回收对象。就好比“瓜从藤上掉下来了， 那这瓜肯定也没有用了”        </p></blockquote><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240118173551.png"                      alt="20240118173551"                ></p><blockquote><p>可达性分析从理论上很好理解，但在垃圾收集器具体运行时，要考虑的问题不知道要复杂多少倍，因为在可达性分析的同时，程序也是在并行运行着，整个内存堆的状态随着程序的运行是实时变化的，要实现分析结果与内存状态的一致性，就必须要暂停用户线程，在一个快照去进行分析。</p></blockquote><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>可达性分析解决了判断对象是否可回收的问题，那么在垃圾回收时内存空间会发生哪些变化呢？这就是垃圾回收算法要讨论的问题，我们根据算法对内存采取的不同操作，可将垃圾回收算法分为 3 种：</p><ul><li><strong>标记-清除算法</strong></li><li><strong>标记-复制算法</strong></li><li><strong>标记-整理算法</strong></li></ul><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>根据名称就可以理解改算法分为两个阶段：首先标记出所有需要被回收的对象，然后对标记的对象进行统一清除，清空对象所占用的内存区域，下图展示了回收前与回收后内存区域的对比，红色的表示可回收对象，橙色表示不可回收对象，白色表示内存空白区域。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122162509.png"                      alt="20240122162509"                ></p><p>标记-清除算法的<strong>两个缺点</strong>：</p><ul><li>执行效率不可控，试想一下如果堆中大部分的对象都可回收的，收集器要执行大量的标记、收集操作。</li><li>产生了许多内存碎片，通过回收后的内存状态图可以知道，被回收后的区域内存并不是连续的，当有大对象要分配而找不到满足大小的空间时，要触发下一次垃圾收集。</li></ul><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>针对标记-清除算法执行效率与内存碎片的缺点，计算机科学家又提出了一种“半复制区域”的算法。</p><p>标记-复制算法将内存分为大小相同的两个区域：<strong>运行区域</strong>、<strong>预留区域</strong>，所有创建的新对象都分配到运行区域，当运行区域内存不够时，将运作区域中存活对象全部复制到预留区域，然后再清空整个运行区域内存，这时两块区域的角色也发生了变化，每次存活的对象就像皮球一下在运行区域与预留区域踢来踢出，而垃圾对象会随着整个区域内存的清空而释放掉，内存前后的状态参考下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122162725.png"                      alt="20240122162725"                ></p><p>标记-复制算法在大量垃圾对象的情况下，只需复制少量的存活对象，并且不会产生内存碎片问题，新内存的分配只需要移动堆顶指针顺序分配即可，很好的兼顾了效率与内存碎片的问题。</p><p>标注-复制算法也存在<strong>缺点</strong>：</p><p>预留一半的内存区域未免有些浪费了，并且如果内存中大量的是存活状态，只有少量的垃圾对象，收集器要执行更多次的复制操作才能释放少量的内存空间，得不偿失。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记-复制算法要浪费一半内存空间，且在大多数状态为存活状态时使用效率会很低，针对这一情况计算机科学家又提出了一种新的算法“标记-整理算法”，标记整理算法的标记阶段与其他算法一样，但是在整理阶段，算法将存活的对象向内存空间的一端移动，然后将存活对象边界以外的空间全部清空，如下图所示：<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122163056.png"                      alt="20240122163056"                ></p><p>标记整理算法解决了内存碎片问题，也不存在空间的浪费问题，看上去挺美好的。但是，当内存中存活对象多，并且都是一些微小对象，而垃圾对象少时，要移动大量的存活对象才能换取少量的内存空间。可见：不同的垃圾回收算法都有各自的优缺点，适应于不同的垃圾回收场景</p><h2 id="新生代、老年代堆内存结构"><a href="#新生代、老年代堆内存结构" class="headerlink" title="新生代、老年代堆内存结构"></a>新生代、老年代堆内存结构</h2><p> Java 堆内存空间新生代、老年代是如何划分的？对象创建后是如何分配到不同的区域的？结合下图可以知道，整个堆内存被分为了 2 个大的区域，新生代，老年代，默认情况下新生代占 1/3 的空间，老年代占 2/3 的空间，新生代又分为两个区 Eden 区 Survial 区，Survial 又分为 S0、S1 区 默认各占 8/10 与 1/10，1/10 的空间。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240122164605.png"                      alt="20240122164605"                ></p><p>为什么要这么设计呢？为什么要分那么多不同的内存区域干嘛？这是由对象的生命周期特征、与各类垃圾回收算法的优缺点所决定的，这正是垃圾回收器设计的理论基础。经过统计分析，大多数应用程序对象生命周期符合两个特征：</p><ul><li>绝大多数的对象都是“朝生夕灭”的，即创建不久就消亡</li><li>熬过越多垃圾回收过程的对象就越难以消亡</li></ul><p>因此，可以根据对象生命周期特征，将其划分到不同的区域，再对特定区域使用特定的垃圾回收算法，只有这样才能将垃圾算法的优点发挥到极致，这种组合的垃圾回收算法叫：分代垃圾算法。比如：</p><ul><li>在新生代使用标记-复制算法</li><li>在老年代使用标记-整理算法</li></ul><blockquote><p>参考​原文链接:<a class="link"   href="https://xie.infoq.cn/article/9d4830f6c0c1e2df0753f9858" >https://xie.infoq.cn/article/9d4830f6c0c1e2df0753f9858<i class="fas fa-external-link-alt"></i></a></p></blockquote><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;😬 图文并茂才能更快掌握&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>每次用IDEA打开项目都要你输入SVN账号密码?</title>
    <link href="https://mynamecoder.com/p/42197.html"/>
    <id>https://mynamecoder.com/p/42197.html</id>
    <published>2024-01-18T16:40:19.000Z</published>
    <updated>2024-01-22T08:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>😌 开发就要舒舒服服的</p><span id="more"></span><p>有一次把brew卸载重新安装了，导致svn也要重新安装，重新安装完以后发现IDEA中每次打开使用svn就要输入一次密码。这样太麻烦了。<br>虽然点了记住密码，但是每次打开项目都要输入密码。这样很浪费时间！根本不能忍！<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240118164646.png"                      alt="20240118164646"                ></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p>打开钥匙串访问<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240118164700.png"                      alt="20240118164700"                ></p></li><li><p>搜索svn并鼠标双击条目<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240118164714.png"                      alt="20240118164714"                ></p></li><li><p>访问控制：允许所有应用程序访问此项目<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240118164731.png"                      alt="20240118164731"                ></p></li></ul><p>我这里偷懒了，简单粗暴，允许所有应用程序访问此项目。你也可以设置成你想允许访问的程序名单。如下这样：<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20240118164743.png"                      alt="20240118164743"                ></p><p>这里的这个svn命令比较难选到，可以做个软链接方便选择，每个人的安装路径可能也会不同。这里就不介绍了。<br>做完这几步我的IDEA已经不需要我在输入密码了。教程结束！</p><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;😌 开发就要舒舒服服的&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常开发" scheme="https://mynamecoder.com/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ES性能分析</title>
    <link href="https://mynamecoder.com/p/39368.html"/>
    <id>https://mynamecoder.com/p/39368.html</id>
    <published>2023-12-22T17:55:52.000Z</published>
    <updated>2024-01-09T07:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>📚 esrally使用记录</p><span id="more"></span><p>要使用 Elasticsearch Rally (esrally) 比较两个 Elasticsearch 集群的性能，需要按照以下步骤操作：</p><h3 id="步骤-1-安装和配置-esrally"><a href="#步骤-1-安装和配置-esrally" class="headerlink" title="步骤 1: 安装和配置 esrally"></a>步骤 1: 安装和配置 esrally</h3><p>如果你还没有安装 esrally，可以通过 pip 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install esrally</span><br></pre></td></tr></table></figure><p>在首次运行 esrally 时，需要进行一些基本配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esrally configure</span><br></pre></td></tr></table></figure><p>这个命令会引导你完成一系列配置步骤，包括设置 Elasticsearch 集群的地址、选择是否上传测试结果等。</p><h3 id="步骤-2-选择或创建测试场景（Track）"><a href="#步骤-2-选择或创建测试场景（Track）" class="headerlink" title="步骤 2: 选择或创建测试场景（Track）"></a>步骤 2: 选择或创建测试场景（Track）</h3><p>esrally 提供了多种预定义的测试场景（称为 tracks），你可以选择一个适合你需求的场景。例如，<code>geonames</code> 是一个常用的场景，适用于通用的性能测试。</p><p>如果预定义的场景不符合你的需求，你可以创建自定义的场景。这涉及到定义数据集和测试操作。</p><h3 id="步骤-3-对第一个集群进行测试"><a href="#步骤-3-对第一个集群进行测试" class="headerlink" title="步骤 3: 对第一个集群进行测试"></a>步骤 3: 对第一个集群进行测试</h3><p>使用以下命令对第一个 Elasticsearch 集群进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esrally --track=geonames --target-hosts=es_cluster1_host:9200 --pipeline=benchmark-only</span><br></pre></td></tr></table></figure><p>这里，<code>--track=geonames</code> 指定了使用的测试场景，<code>--target-hosts</code> 指定了第一个 Elasticsearch 集群的地址。</p><h3 id="步骤-4-对第二个集群进行测试"><a href="#步骤-4-对第二个集群进行测试" class="headerlink" title="步骤 4: 对第二个集群进行测试"></a>步骤 4: 对第二个集群进行测试</h3><p>同样的，对第二个 Elasticsearch 集群进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esrally --track=geonames --target-hosts=es_cluster2_host:9200 --pipeline=benchmark-only</span><br></pre></td></tr></table></figure><p>确保测试条件（如 track、数据量等）与第一个集群的测试相同，以便进行公平比较。</p><h3 id="步骤-5-比较结果"><a href="#步骤-5-比较结果" class="headerlink" title="步骤 5: 比较结果"></a>步骤 5: 比较结果</h3><p>测试完成后，esrally 会生成详细的报告，包括吞吐量、延迟等关键性能指标。你需要比较两个集群的测试结果：</p><ul><li><strong>吞吐量</strong>：通常以每秒处理的请求数量来衡量。</li><li><strong>延迟</strong>：观察平均延迟和延迟分布。</li><li><strong>资源使用情况</strong>：比如 CPU、内存和磁盘 I/O。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保在相似的条件下测试两个集群，包括硬件配置、网络环境、Elasticsearch 配置等。</li><li>测试可能会对集群性能产生短暂影响，因此建议在低峰时段进行。</li><li>分析结果时，考虑到可能的外部因素，如网络延迟、硬件差异等。</li></ul><p>通过这种方法，你可以获得两个 Elasticsearch 集群在相似条件下的性能数据，从而进行有效的比较和分析。</p><p>使用 Elasticsearch Rally (esrally) 进行性能测试时指定特定的索引。这通常涉及到创建自定义的测试场景（称为 “track”），其中你可以定义要测试的具体索引以及相关的查询和操作。</p><h3 id="创建自定义-Track"><a href="#创建自定义-Track" class="headerlink" title="创建自定义 Track"></a>创建自定义 Track</h3><p>为了针对特定索引进行测试，你需要创建一个自定义的 track。以下是创建自定义 track 的基本步骤：</p><h4 id="1-定义-Track-结构"><a href="#1-定义-Track-结构" class="headerlink" title="1. 定义 Track 结构"></a>1. 定义 Track 结构</h4><p>创建一个新的文件夹来存放你的自定义 track。在这个文件夹中，你需要创建一个名为 <code>track.json</code> 的文件，这是定义 track 的主要文件。</p><h4 id="2-编写-track-json"><a href="#2-编写-track-json" class="headerlink" title="2. 编写 track.json"></a>2. 编写 track.json</h4><p>在 <code>track.json</code> 文件中，你可以定义要测试的索引、数据集、操作（比如查询）等。以下是一个简单的示例，展示了如何定义一个针对特定索引的 track：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Custom Track&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;indices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_index&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index-settings.json&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;corpora&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_corpora&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;documents&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;source-file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;documents.json.bz2&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;document-count&quot;</span><span class="punctuation">:</span> <span class="number">1000000</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;compressed-bytes&quot;</span><span class="punctuation">:</span> <span class="number">100000000</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;uncompressed-bytes&quot;</span><span class="punctuation">:</span> <span class="number">500000000</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;challenges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;schedule&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;operation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index-append&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;search&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;operation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;operation-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;search&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_index&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>indices</code> 部分定义了要测试的索引（在这个例子中是 <code>my_index</code>），而 <code>challenges</code> 部分定义了要执行的操作，例如索引数据和执行查询。</p><h4 id="3-准备数据文件"><a href="#3-准备数据文件" class="headerlink" title="3. 准备数据文件"></a>3. 准备数据文件</h4><p>如果你的 track 需要索引数据，你需要准备数据文件。这些文件应该放在与 <code>track.json</code> 相同的文件夹中。在上面的示例中，<code>documents.json.bz2</code> 是一个压缩的数据文件，包含了要索引的文档。</p><h4 id="4-运行自定义-Track"><a href="#4-运行自定义-Track" class="headerlink" title="4. 运行自定义 Track"></a>4. 运行自定义 Track</h4><p>一旦你的 track 和相关文件准备好了，你可以使用以下命令运行 esrally：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esrally --track-path=/path/to/your/track --target-hosts=es_host:9200 --pipeline=benchmark-only</span><br></pre></td></tr></table></figure><p>这里 <code>--track-path</code> 指向你的自定义 track 文件夹。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保你的自定义 track 中的索引名称、数据文件等与你的实际需求相符。</li><li>如果你的 Elasticsearch 集群有安全设置（如基本认证），需要在 esrally 的配置中指定这些信息。</li><li>创建 track 时，确保定义的操作（如查询）适用于你的数据和索引结构。</li></ul><p>通过这种方式，你可以对特定的索引进行细致的性能测试，从而更准确地评估和优化 Elasticsearch 集群的性能。</p><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;📚 esrally使用记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="开发" scheme="https://mynamecoder.com/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="ElasticSearch" scheme="https://mynamecoder.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>什么是Redis的缓存雪崩、击穿、穿透?</title>
    <link href="https://mynamecoder.com/p/19331.html"/>
    <id>https://mynamecoder.com/p/19331.html</id>
    <published>2023-12-19T10:48:54.000Z</published>
    <updated>2024-01-22T08:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>🎄 Redis 作为缓存层注意事项</p><span id="more"></span><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p><p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219104940.png"                                     ></p><p>引入了缓存层，就会有缓存异常的三个问题，分别是缓存雪崩、缓存击穿、缓存穿透。</p><p>这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219104959.png"                                     ></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219105159.png"                                     ></p><p>那么，当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219105228.png"                                     ></p><p>可以看到，发生缓存雪崩有两个原因：</p><ul><li>大量数据同时过期；</li><li>Redis 故障宕机；</li></ul><blockquote><p>不同的诱因，应对的策略也会不同。</p></blockquote><h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>均匀设置过期时间；</li><li>互斥锁；</li><li>双 key 策略；</li><li>后台更新缓存；</li></ul><p><em>1. 均匀设置过期时间</em></p><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p><p><em>2. 互斥锁</em></p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p><p><em>3. 双 key 策略</em></p><p>我们对缓存数据可以使用两个 key，一个是<strong>主 key，会设置过期时间</strong>，一个是<strong>备 key，不会设置过期</strong>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p><p>当业务线程访问不到「主 key」的缓存数据时，就直接返回「备 key」的缓存数据，然后在更新缓存的时候，<strong>同时更新「主 key」和「备 key」的数据。</strong></p><p>双 key 策略的好处是，当主 key 过期了，有大量请求获取缓存数据的时候，直接返回备 key 的数据，这样可以快速响应请求。而不用因为 key 失效而导致大量请求被锁阻塞住（采用了互斥锁，仅一个请求来构建缓存），后续再通知后台线程，重新构建主 key 的数据。</p><p><em>4. 后台更新缓存</em></p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，我们最好提前把数据缓存起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p><h3 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h3><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>服务熔断或请求限流机制；</li><li>构建 Redis 缓存高可靠集群；</li></ul><p><em>1. 服务熔断或请求限流机制</em></p><p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常运行，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><p><em>2. 构建 Redis 缓存高可靠集群</em></p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p><hr><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219105828.png"                      alt="20231219105828"                ></p><p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><hr><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当发生缓存雪崩或击穿时，<strong>数据库中还是保存了应用要访问的数据</strong>，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219105845.png"                      alt="20231219105845"                ></p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li>第一种方案，非法请求的限制；</li><li>第二种方案，缓存空值或者默认值；</li><li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</li></ul><h3 id="非法请求的限制"><a href="#非法请求的限制" class="headerlink" title="非法请求的限制"></a>非法请求的限制</h3><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断出请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p><h3 id="缓存空值或者默认值"><a href="#缓存空值或者默认值" class="headerlink" title="缓存空值或者默认值"></a>缓存空值或者默认值</h3><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p><h3 id="使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。"><a href="#使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。" class="headerlink" title="使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。*"></a>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。*</h3><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p><p>那问题来了，布隆过滤器是如何工作的呢？接下来，我介绍下。</p><p>布隆过滤器由「初始值都为 0 的位图数组」和「N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219105856.png"                      alt="20231219105856"                ></p><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p><p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p><p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p><p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231219110533.png"                      alt="20231219110533"                ></p><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;🎄 Redis 作为缓存层注意事项&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://mynamecoder.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql主从复制原理及流程图</title>
    <link href="https://mynamecoder.com/p/27605.html"/>
    <id>https://mynamecoder.com/p/27605.html</id>
    <published>2023-12-13T16:04:07.000Z</published>
    <updated>2024-01-09T07:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>🐕 一张图明白整体流程</p><span id="more"></span><blockquote><p>两个log文件，3个线程</p></blockquote><p>(1) Master的更新事件(update、insert、delete)会按照顺序写入<code>bin-log</code>中。<br>当Slave连接到Master的后，Master机器会为Slave开启<code>binlog dump</code>线程,该线程会去读取<code>bin-log</code>日志<br>(2) Slave连接到Master后,Slave库有一个<code>I/O</code>线程 通过请求<code>binlog dump</code> 线程读取bin-log日志，然后写入从库的<code>relay log</code>日志中。<br>(3) Slave还有一个 <code>SQL</code>线程,实时监控<code>relay-log</code>日志内容是否有更新，解析文件中的SQL语句，在Slave数据库中去执行。</p><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231213160912.png"                                     ></p><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;🐕 一张图明白整体流程&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mysql" scheme="https://mynamecoder.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>安利一个Mac下好用的抓包工具-Charles</title>
    <link href="https://mynamecoder.com/p/46863.html"/>
    <id>https://mynamecoder.com/p/46863.html</id>
    <published>2023-12-12T12:30:41.000Z</published>
    <updated>2024-01-18T08:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- ![](https://img.mynamecoder.com/20220814130111.png) --><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814130200.png"                                     ><br>Charles：让天底下没有难抓的包。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天给大家推荐一个我所使用过的抓包工具中最好用的抓包工具-Charles（音译：查尔斯），它可以抓各端发起的网络请求，我主要用来抓移动设备上的请求，上次小明就通过这种方式找到了一款付费App课程的漏洞，咳咳，不展开说了，毕竟web端的浏览器网络请求，打开开发者工具就能看到（滑稽）。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ul><li>方式一：官网下载</li></ul><p>链接：<a class="link"   href="https://www.charlesproxy.com/download/" >https://www.charlesproxy.com/download/<i class="fas fa-external-link-alt"></i></a></p><p>期限：试用30天</p><ul><li>方式二：百度网盘（推荐）</li></ul><p>链接: <a class="link"   href="https://pan.baidu.com/s/1p7GJKKfFL4NHgy47Hm_5ng" >https://pan.baidu.com/s/1p7GJKKfFL4NHgy47Hm_5ng<i class="fas fa-external-link-alt"></i></a></p><p>期限: 没有使用限制，附带安装说明文档（你懂的），推荐使用正版软件。</p><p>密码: 关注微信公众号“程序员小明”，回复“查尔斯”即可获取。</p><h2 id="配置及使用"><a href="#配置及使用" class="headerlink" title="配置及使用"></a>配置及使用</h2><p>第一次启动的时候会提示自动配置，点击同意即可，当然也可以自定义配置。主要配置全部在Proxy这里，端口号默认8888，也可以自己调整。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814123924.png"                                     ><br>接下来，给大家分别介绍一下使用Charles抓取浏览器和移动端网络请求的方法。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>拿Mac举例（如题），需要将当前你连接的网络配置网页代理（http）、网页安全代理（https），默认Charles会自动配置好，如下所示<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814170205.png"                                     ><br>当然，如果你看到的不是这样，也可以手动配置，其中127.0.0.1表示本地地址，端口号根据自己的配置指定。确认好以上配置以后，这时我们打开百度，却提示：您的连接不是私密连接！<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814162657.png"                                     ></p><p>此时一定要沉着冷静，这是表示当前https代理证书不被信任，解决方法如下：</p><ul><li><p>打开Charles，选择Help -&gt; SSL Proxy -&gt; Install Charles Root Certificate<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814163000.png"                                     ></p></li><li><p>在弹出的证书窗口中，可以看到该证书已成功添加，但是此时该证书图标有<strong>叉号</strong>，表示仍然不被信任<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814163123.png"                                     ></p></li><li><p>双击此证书，在弹出的Charles Proxy CA窗口中，点击“信任“按钮 -&gt; 使用此证书 -&gt; 选择”始终信任“后关闭窗口，使用账号和密码授权后，即可看到此证书<strong>叉号</strong>消失，表示已经被信任。</p></li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814163830.png"                                     ></p><ul><li>再次打开百度，我们就可以正常访问<br>如果此时Charles弹出弹窗提示是否allow，选择allow即可。当然，我们也可以设置全部https网络请求都允许抓取<br>选择Proxy -&gt; SSL Proxying Settings，增加一个Location</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host: *</span><br><span class="line">Port: 443</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814170559.png"                                     ></p><h2 id="移动端（本文重点）"><a href="#移动端（本文重点）" class="headerlink" title="移动端（本文重点）"></a>移动端（本文重点）</h2><h3 id="抓取http请求"><a href="#抓取http请求" class="headerlink" title="抓取http请求"></a>抓取http请求</h3><ul><li>同样在电脑上打开Charles</li><li>现在需要在手机上配置代理<br>wifi设置-网络代理，输入电脑的ip、端口号（默认8888），可通过<code>ifconfig</code>查看本机电脑ip</li><li>保存后，Charles会弹出弹窗提示是否allow，选择allow即可。<br>如果你使用的手机系统是Android，此时，Charles就可以抓取http和https的网络请求，而如果你使用的是iPhone的ios系统，则目前只能抓取http网络请求，接下来我们看一下ios系统的手机如何抓取https的网络请求。</li></ul><h3 id="抓取-ios-https请求"><a href="#抓取-ios-https请求" class="headerlink" title="抓取 ios https请求"></a>抓取 ios https请求</h3><p>众所周知，ios是一个很讲究的系统，首先我们需要安装证书<br>选择Charles－&gt; Help －&gt; SSL Proxying－&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser，我们可以看到如下提示：<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814172702.png"                                     ><br>小明翻译一下：</p><ul><li>为你的手机配置http代理<br>打开手机设置的无线局域网（确保手机和电脑在同一WiFi下：），点击右边的<strong>i</strong>，拉到最下面，选择“配置代理”，代理地址就是弹窗的地址。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814173040.png"                                     ></li><li>打开手机浏览器，一定要用<strong>Safari</strong>，其他浏览器不识别这个证书，输入chls.pro/ssl，下载并安装证书<br>ios的证书下载后需要到 设置 -&gt; 通用 -&gt; 描述文件 下去安装证书</li><li>注意！还没有结束！（多少英雄好汉跌倒在这里）<br>安装成功后，实际上我们并未<strong>授信证书</strong>, 选择 设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置 对证书开启完全信任！<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/IMG_EE1785880387-1.jpeg"                                     ></li></ul><h2 id="可以设置不代理计算机的请求（可选择）"><a href="#可以设置不代理计算机的请求（可选择）" class="headerlink" title="可以设置不代理计算机的请求（可选择）"></a>可以设置不代理计算机的请求（可选择）</h2><p>选择Proxy -&gt; macOS 取消勾选则表示不抓取计算机的请求<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20220814124458.png"                                     ></p><p>同理，选择Proxy -&gt; Mozilla Firefox 不勾选则不抓取计算机上 Mozilla Firefox浏览器的请求<br>这个应用场景主要是只针对移动端数据抓取时，则这两项就可以不勾选。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="https协议，使用Charles抓包时，request和respond都出现乱码"><a href="#https协议，使用Charles抓包时，request和respond都出现乱码" class="headerlink" title="https协议，使用Charles抓包时，request和respond都出现乱码"></a>https协议，使用Charles抓包时，request和respond都出现乱码</h3><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231212100809.png"                      alt="请求乱码"                ><br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231212100901.png"                      alt="响应乱码"                ></p><p>1、全局设置：</p><p>Proxy&gt;SSL Proxying Settings&gt;SSL Proxying，添加Host：*，Port：443，问题解决。<br><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20231212100912.png"                      alt="解决"                ></p><p>2、针对目标网站设置：</p><p>Structure tab页，选中某个网址，右键，点击选中“Enable SSL Proxying”，同样可以是request和response中的乱码问题得以解决。</p><p>Charles的操作使用今天就介绍到这里，恭喜你！已经掌握了它的80%功能，已经足够日常开发使用，是不是感觉自己又变厉害啦！当然，它还有高端的玩法，比如打断点，修改请求、返回的参数，本次暂不介绍，以后有机会小明再来补充。</p><h2 id="欢迎关注获取更多资源"><a href="#欢迎关注获取更多资源" class="headerlink" title="欢迎关注获取更多资源"></a>欢迎关注获取更多资源</h2><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      alt="程序员小明"                ></p>]]></content>
    
    
    <summary type="html">&lt;!-- ![](https://img.mynamecoder.com/20220814130111.png) --&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     alt=&quot;image&quot;
                     data-src=&quot;https://img.mynamecoder.com/20220814130200.png&quot;
                     
                &gt;&lt;br&gt;Charles：让天底下没有难抓的包。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://mynamecoder.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Mac" scheme="https://mynamecoder.com/tags/Mac/"/>
    
    <category term="Charles" scheme="https://mynamecoder.com/tags/Charles/"/>
    
  </entry>
  
  <entry>
    <title>开发随记</title>
    <link href="https://mynamecoder.com/p/7e8c.html"/>
    <id>https://mynamecoder.com/p/7e8c.html</id>
    <published>2023-10-23T23:00:00.000Z</published>
    <updated>2024-01-22T08:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>📒 记录每日开发过程中的一些碎片，持续更新</p><span id="more"></span><h2 id="pip-查看包信息"><a href="#pip-查看包信息" class="headerlink" title="pip 查看包信息"></a>pip 查看包信息</h2><p>命令显示已安装包的信息（包名与版本号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip list  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再用命令显示该安装的包的相关信息，其中包括它的安装路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show package_name</span><br></pre></td></tr></table></figure><p>实际上包通常被安装在python安装目录下的lib\site-packages目录下</p><h2 id="Mac微信聊天记录所在目录"><a href="#Mac微信聊天记录所在目录" class="headerlink" title="Mac微信聊天记录所在目录"></a>Mac微信聊天记录所在目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat</span><br></pre></td></tr></table></figure><h2 id="Mac日历与iPhone日历不无法同步问题"><a href="#Mac日历与iPhone日历不无法同步问题" class="headerlink" title="Mac日历与iPhone日历不无法同步问题"></a>Mac日历与iPhone日历不无法同步问题</h2><ul><li>升级一下系统为最新</li></ul><ul><li>~/Library/Preferences 目录下，删除 com.apple.iCal.plist ；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Library/Preferences </span><br><span class="line">rm -rf com.apple.iCal.plist </span><br></pre></td></tr></table></figure><ul><li><p>打开日历 App，账户-退出icloud账户，关闭日历程序</p></li><li><p>重新登录，提示同步本地日历到云端</p></li></ul><h2 id="MacOS-字体-font-文件的-存放路径"><a href="#MacOS-字体-font-文件的-存放路径" class="headerlink" title="MacOS: 字体(font)文件的 存放路径"></a>MacOS: 字体(font)文件的 存放路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/System/Library/Fonts</span><br></pre></td></tr></table></figure><h2 id="mybatis输出最终sql"><a href="#mybatis输出最终sql" class="headerlink" title="mybatis输出最终sql"></a>mybatis输出最终sql</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleExecutor</span><br></pre></td></tr></table></figure><p>可以通过debug形式获取变量的值</p><h2 id="修改Linux环境变量"><a href="#修改Linux环境变量" class="headerlink" title="修改Linux环境变量"></a>修改Linux环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 最后面追加</span><br><span class="line">vi /etc/profile</span><br><span class="line"># 立即生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、重启Jenkies</span><br><span class="line">http://localhost:8080/restart</span><br><span class="line"></span><br><span class="line">2、重新加载配置信息</span><br><span class="line"> http://localhost:8080/reload</span><br></pre></td></tr></table></figure><h2 id="openresty工作流程"><a href="#openresty工作流程" class="headerlink" title="openresty工作流程"></a>openresty工作流程</h2><p><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/20230223233907.png"                                     ></p><h2 id="NullPointerException异常在Java中没有堆栈"><a href="#NullPointerException异常在Java中没有堆栈" class="headerlink" title="NullPointerException异常在Java中没有堆栈"></a>NullPointerException异常在Java中没有堆栈</h2><p>使用的HotSpot JVM，为了达到更好的性能，执行了很多优化，默认空指针异常堆栈跟踪不打印。因此，要获得堆栈追溯，需要通过选项<code>-XX:-OmitStackTraceInFastThrow</code>设置启动参数。</p><h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><p>lua脚本变量命名千万不要带“-”，尤其是在openresty引用该脚本的场景下注意日志错误，忘不掉那个午休被惊醒的场景。</p><h2 id="数据库连接工具"><a href="#数据库连接工具" class="headerlink" title="数据库连接工具"></a>数据库连接工具</h2><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><strong>Mac</strong></h4><p>Sequel Pro、Navicat（好用且破费）、DBeaver</p><h4 id="win"><a href="#win" class="headerlink" title="win"></a><strong>win</strong></h4><p> HeidiSQL</p><h2 id="hosts文件所在目录"><a href="#hosts文件所在目录" class="headerlink" title="hosts文件所在目录"></a>hosts文件所在目录</h2><h4 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a><strong>Mac</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/hosts</span><br></pre></td></tr></table></figure><h4 id="win-1"><a href="#win-1" class="headerlink" title="win"></a>win</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\Windows\System32\divers\etc\hosts</span><br></pre></td></tr></table></figure><h2 id="Tomcat存放目录"><a href="#Tomcat存放目录" class="headerlink" title="Tomcat存放目录"></a>Tomcat存放目录</h2><h4 id="Mac-2"><a href="#Mac-2" class="headerlink" title="Mac"></a>Mac</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>自定义</p><h2 id="redis查看工具Redis-client"><a href="#redis查看工具Redis-client" class="headerlink" title="redis查看工具Redis client"></a>redis查看工具Redis client</h2><h4 id="Mac-3"><a href="#Mac-3" class="headerlink" title="Mac"></a>Mac</h4><p>Redis Desktop Manager</p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE 忽略导致错误的行，如果有则不插入也不报错，并将其余行插入到表中。</span><br></pre></td></tr></table></figure><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 域名/ip</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>获取列表长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLen key</span><br></pre></td></tr></table></figure><p>获取前10个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key 0 10</span><br></pre></td></tr></table></figure><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="Spring-Boot-启动加载数据-CommandLineRunner"><a href="#Spring-Boot-启动加载数据-CommandLineRunner" class="headerlink" title="Spring Boot 启动加载数据 CommandLineRunner"></a>Spring Boot 启动加载数据 CommandLineRunner</h3><p><a class="link"   href="https://blog.csdn.net/catoop/article/details/50501710" >https://blog.csdn.net/catoop/article/details/50501710<i class="fas fa-external-link-alt"></i></a></p><h3 id="springboot中-scheduled开关机制"><a href="#springboot中-scheduled开关机制" class="headerlink" title="springboot中@scheduled开关机制"></a>springboot中@scheduled开关机制</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;scheduling&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">public class SchedulingConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduling.enabled=true</span><br></pre></td></tr></table></figure><h2 id="idea-打开cpu监控如何关闭"><a href="#idea-打开cpu监控如何关闭" class="headerlink" title="idea 打开cpu监控如何关闭"></a>idea 打开cpu监控如何关闭</h2><p>view-&gt;tool windows-&gt;coverage-&gt;关闭application</p><h2 id="mac查看图片如何来回切换"><a href="#mac查看图片如何来回切换" class="headerlink" title="mac查看图片如何来回切换"></a>mac查看图片如何来回切换</h2><p>按住空格，通过方向键切换</p><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f ./catalina.out | grep &#x27;舆情秘书&#x27; -A 10</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① grep -E &quot;word1|word2|word3&quot; file.txt</span><br><span class="line">满足任意条件（word1、word2和word3之一）将匹配。</span><br><span class="line">② grep word1 file.txt | grep word2 |grep word3</span><br><span class="line">必须同时满足三个条件（word1、word2和word3）才匹配。</span><br></pre></td></tr></table></figure><h2 id="idea自动导入包"><a href="#idea自动导入包" class="headerlink" title="idea自动导入包"></a>idea自动导入包</h2><p>Preference（快捷键：command+,）-&gt;maven-&gt;import maven projects automaticallly</p><h2 id="idea忽略-iml"><a href="#idea忽略-iml" class="headerlink" title="idea忽略*.iml"></a>idea忽略*.iml</h2><ol><li><code>Editor-&gt;File Types=&gt;Ignore files and folders增加*.iml;</code></li><li><code>在lgnore files and folesrs中输入.idea;注意要&quot;;&quot;结尾。你就可以隐藏.idea文件夹了</code></li></ol><h2 id="idea查看properties中文变成unicode码如何解决"><a href="#idea查看properties中文变成unicode码如何解决" class="headerlink" title="idea查看properties中文变成unicode码如何解决"></a>idea查看properties中文变成unicode码如何解决</h2><p>Preference（快捷键：command+,）-&gt;搜索File Encoding-&gt;Transparent native-to-ascii conversion勾选框，勾选之后点击确认。</p><h2 id="idea-好用的插件"><a href="#idea-好用的插件" class="headerlink" title="idea 好用的插件"></a>idea 好用的插件</h2><h3 id="Free-Mybatis-plugin"><a href="#Free-Mybatis-plugin" class="headerlink" title="Free Mybatis plugin"></a>Free Mybatis plugin</h3><p>A idea plugin for mybatis free-idea-mybatis is an enchange plugin for idea to supoort mybatis</p><h3 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h3><p>生成一个方法逻辑的时序图，深度可以自定义，能够很方便地分析代码逻辑，很实用，尤其是当你刚开始接手别人的代码时……</p><h2 id="清除ios输入法预测的记录"><a href="#清除ios输入法预测的记录" class="headerlink" title="清除ios输入法预测的记录"></a>清除ios输入法预测的记录</h2><p>设置》通用》还原》还原键盘词典。</p><h2 id="redis-查看当前发布订阅命令"><a href="#redis-查看当前发布订阅命令" class="headerlink" title="redis 查看当前发布订阅命令"></a>redis 查看当前发布订阅命令</h2><p>pubsub channels</p><h2 id="imovie"><a href="#imovie" class="headerlink" title="imovie"></a>imovie</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>文件-&gt;分享-&gt;文件-&gt;选择视频或者音频</p><h2 id="Mac-4"><a href="#Mac-4" class="headerlink" title="Mac"></a>Mac</h2><h3 id="移动（剪切）"><a href="#移动（剪切）" class="headerlink" title="移动（剪切）"></a>移动（剪切）</h3><ul><li>command+c</li><li>command+option+v</li></ul><h3 id="Visual-Studio-Code-Dock没有图标"><a href="#Visual-Studio-Code-Dock没有图标" class="headerlink" title="Visual Studio Code Dock没有图标"></a>Visual Studio Code Dock没有图标</h3><p>最近发现使用Visual Studio Code在Dock上居然找不到图标（bug）。<br>打开<code>terminal</code>命令行工具，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure><p>回车，这样Dock就可以自动重启，vs code的图标在Dock中也恢复正常显示。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>统计log中关键词出现的次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#x27;192.168.185.112&#x27; | wc | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;userid=69129&amp;KK_TYPE=01&quot; http://192.168.185.63:8080/SubjectTree/getTree.do</span><br></pre></td></tr></table></figure><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#x27;192.168.185.112&#x27; | wc -l</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#x27;192.168.185.112&#x27; | wc | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 0</span><br></pre></td></tr></table></figure><h3 id="用户组控制目录权限"><a href="#用户组控制目录权限" class="headerlink" title="用户组控制目录权限"></a>用户组控制目录权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown tomcat:tomcat yqms_error.log</span><br></pre></td></tr></table></figure><h3 id="SSH下用vim打开文件，文件显示不全"><a href="#SSH下用vim打开文件，文件显示不全" class="headerlink" title="SSH下用vim打开文件，文件显示不全"></a>SSH下用vim打开文件，文件显示不全</h3><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty rows 200 columns 250</span><br></pre></td></tr></table></figure><h3 id="vim显示行号"><a href="#vim显示行号" class="headerlink" title="vim显示行号"></a>vim显示行号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set number</span><br></pre></td></tr></table></figure><h3 id="配置ssh免登录"><a href="#配置ssh免登录" class="headerlink" title="配置ssh免登录"></a>配置ssh免登录</h3><p>首先确认当前用户本地是否存在公钥私钥对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>如果存在跳过这一步，如果不存在使用<code>ssh-keygen</code>即可生成公钥私钥对（一直回车，我们不需要使用密码保护私钥对）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>我们发现当前用户目录下生成以下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">authorized_keys</span><br><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br><span class="line">known_hosts</span><br></pre></td></tr></table></figure><p>至此，我们使用<code>ssh-copy-id</code>将公钥复制到远程机器中，即可通过ssh免密访问服务器、scp免密上传文件，类似的应用场景还有github代码管理也有用到，确实非常方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -p 端口号 -i ~/.ssh/id_rsa.pub 用户名@ip地址</span><br></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h4 id="根据关键词筛选日志"><a href="#根据关键词筛选日志" class="headerlink" title="根据关键词筛选日志"></a>根据关键词筛选日志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f -n 100 log | grep 关键词</span><br></pre></td></tr></table></figure><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看端口号占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure><p>查看端口被哪个进程使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp|grep 8080</span><br></pre></td></tr></table></figure><p>在一次启动jar包的服务中，通过以上方法如果找不到端口号占用情况，通过删除nohup文件解决</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><h4 id="根据“java”执行命令的查看进程"><a href="#根据“java”执行命令的查看进程" class="headerlink" title="根据“java”执行命令的查看进程"></a>根据“java”执行命令的查看进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ax | grep java</span><br></pre></td></tr></table></figure><h4 id="杀死同名全部进程方法"><a href="#杀死同名全部进程方法" class="headerlink" title="杀死同名全部进程方法"></a>杀死同名全部进程方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep phantomjs |grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9</span><br></pre></td></tr></table></figure><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>统计当前目录文档数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | wc -l</span><br></pre></td></tr></table></figure><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>统计磁盘使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><h2 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h2><ul><li><p>jenkins SSH插件如果不指定目录位置，默认目录是<code>/root</code>下，需要注意，目前推荐使用默认，方便统一管理。</p></li><li><p>当配置SSH插件脚本时，需要注意在目标服务器上执行脚本（ssh exec command）时，使用以下命令才能正常使用脚本，启动应用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;📒 记录每日开发过程中的一些碎片，持续更新&lt;/p&gt;</summary>
    
    
    
    <category term="日常开发" scheme="https://mynamecoder.com/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="日常开发" scheme="https://mynamecoder.com/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动流程</title>
    <link href="https://mynamecoder.com/p/39079.html"/>
    <id>https://mynamecoder.com/p/39079.html</id>
    <published>2023-10-13T09:02:29.000Z</published>
    <updated>2024-01-09T07:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>👉 不如直接看源码来的直接</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">        // 启动计时器，用于记录整个启动过程的耗时</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        // 定义应用程序上下文和异常报告器列表</span><br><span class="line">        ConfigurableApplicationContext context = null;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 配置 Headless 属性</span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">        // 获取 Spring Boot 启动监听器</span><br><span class="line">        SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">        </span><br><span class="line">        // 执行启动监听器的 starting 方法，通知这些监听器启动过程已经开始</span><br><span class="line">        listeners.starting();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 解析命令行参数</span><br><span class="line">            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">            // 创建应用程序的环境变量</span><br><span class="line">            ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">             // 打印 Banner，可以支持自定义哦</span><br><span class="line">            Banner printedBanner = printBanner(environment);</span><br><span class="line">            // 根据应用程序类型创建应用程序创建上下文对象</span><br><span class="line">            context = createApplicationContext();</span><br><span class="line">            // 初始化异常分析器</span><br><span class="line">            analyzers = new FailureAnalyzers(context);</span><br><span class="line">            // 准备应用程序上下文，扫描 classpath 中的各种配置文件，例如 application.properties、application.yml、META-INF/spring.factories 等，调用 load() 方法加载应用程序的配置。</span><br><span class="line">            prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            // 刷新应用程序上下文</span><br><span class="line">            refreshContext(context);</span><br><span class="line">            // 刷新后操作</span><br><span class="line">            afterRefresh(context, applicationArguments);</span><br><span class="line">            // </span><br><span class="line">            listeners.finished(context, null);</span><br><span class="line">            // 停止计时器</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            // 记录启动日志</span><br><span class="line">            if (this.logStartupInfo) &#123;</span><br><span class="line">                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            // 返回应用程序上下文</span><br><span class="line">            return context;</span><br><span class="line">        &#125;catch (Throwable ex) &#123;</span><br><span class="line">          handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">          throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
    <summary type="html">&lt;p&gt;👉 不如直接看源码来的直接&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://mynamecoder.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>CurrentHashMap底层实现原理</title>
    <link href="https://mynamecoder.com/p/undefined.html"/>
    <id>https://mynamecoder.com/p/undefined.html</id>
    <published>2023-09-19T15:03:48.000Z</published>
    <updated>2024-01-18T08:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>🌴 不得不知道</p><span id="more"></span><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>哈希表就是一种以 键-值(key-indexed) 存储数据的结构，又称散列函数，我们只要输入待查找的值即key，即可查找到其对应的值。<br>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><h4 id="链式哈希表"><a href="#链式哈希表" class="headerlink" title="链式哈希表"></a>链式哈希表</h4><p>链式哈希表从根本上说是由一组链表构成。每个链表都可以看做是一个“桶”，我们将所有的元素通过散列的方式放到具体的不同的桶中。插入元素时，首先将其键传入一个哈希函数（该过程称为哈希键），函数通过散列的方式告知元素属于哪个“桶”，然后在相应的链表头插入元素。查找或删除元素时，用同样的方式先找到元素的“桶”，然后遍历相应的链表，直到发现我们想要的元素。因为每个“桶”都是一个链表，所以链式哈希表并不限制包含元素的个数。然而，如果表变得太大，它的性能将会降低。</p><p>参考链接：<a class="link"   href="https://baijiahao.baidu.com/s?id=1617089947709260129&amp;wfr=spider&amp;for=pc" >https://baijiahao.baidu.com/s?id=1617089947709260129&amp;wfr=spider&amp;for=pc<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;🌴 不得不知道&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java中的final关键字</title>
    <link href="https://mynamecoder.com/p/5404.html"/>
    <id>https://mynamecoder.com/p/5404.html</id>
    <published>2023-09-18T11:00:00.000Z</published>
    <updated>2024-01-09T07:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>🍂 唯一不变的是final</p><span id="more"></span><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>final 是 Java 中的一个关键字，可以用于修饰类、方法和变量。<br>当一个类被声明为 final 时，它意味着该类不能被继承。<br>当一个方法被声明为 final 时，它意味着该方法不能被重写。<br>当一个变量被声明为 final 时，它意味着该变量的值不能被修改。</p><h3 id="final饰修类"><a href="#final饰修类" class="headerlink" title="final饰修类"></a>final饰修类</h3><blockquote><p>举例<code>String</code>类就是final修饰的，所以不能被继承，进而重写其方法</p></blockquote><p>如果声明一个类为final类,  那么这个类就是最终类,不能被继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class ParentClass &#123;</span><br><span class="line">    public void happy() &#123;</span><br><span class="line">        System.out.println(&quot;高兴&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当写一个类去继承它的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ChildClass extends ParentClass&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会报错错误；</p><blockquote><p>注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。</p></blockquote><p>final类中的成员变量可以根据需要设为final，但是final类中的所有成员方法都会被隐式地指定为final方法。 在使用final修饰类的时候，一定要谨慎选择，除非这个类以后不会用来继承或者出于安全考虑，尽量不要将类设计为final类。</p><h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><p>当final用来修饰一个方法的时候，这个方法就是最终方法，那么很明显就是说不能被覆盖重写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ParentClass &#123;</span><br><span class="line"> </span><br><span class="line">    public void happy() &#123;</span><br><span class="line">        System.out.println(&quot;高兴&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //用final关键字修饰的方法</span><br><span class="line">    protected final void play()&#123;</span><br><span class="line">        System.out.println(&quot;开心的玩耍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在继承类中去看下 play()方法是不可以被override的，也就是是报错，说明 final修饰的方法，是一个最终方法，不能被子类去覆盖重写。</p><h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><p>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</p><ul><li>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>当final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为<strong>引用的值是一个地址</strong>，final要求值，即地址的值不发生变化。<br>final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private final int count = 0;</span><br><span class="line">    public Animal() &#123;</span><br><span class="line">        count = 1; //报错</span><br><span class="line">        final Object object = new Object();</span><br><span class="line">        object = new Object(); //报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;🍂 唯一不变的是final&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql隔离级别都使用什么锁</title>
    <link href="https://mynamecoder.com/p/61915.html"/>
    <id>https://mynamecoder.com/p/61915.html</id>
    <published>2023-09-05T15:33:03.000Z</published>
    <updated>2024-01-09T07:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a class="link"   href="https://zhuanlan.zhihu.com/p/562435658" >https://zhuanlan.zhihu.com/p/562435658<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/sunlong88/p/17523827.html" >https://www.cnblogs.com/sunlong88/p/17523827.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="说透-MySQL-锁机制"><a href="#说透-MySQL-锁机制" class="headerlink" title="说透 MySQL 锁机制"></a>说透 MySQL 锁机制</h2><p>在深入探讨不同隔离级别的锁内容之前，我们需要先回顾一下关于 MySQL 锁的本质以及一些基础内容，这样有利于我们后续的理解。<br>对于 MySQL 来说，如果只支持串行访问的话，那么其效率会非常低。因此，为了提高数据库的运行效率，MySQL 需要支持并发访问。而在并发访问的情况下，会发生各种各样的问题，例如：脏读、不可重复读、幻读等问题。为了解决这些问题，就出现了事务隔离级别。<br>本质上，事务隔离级别就是为了解决并发访问下的数据一致性问题的。不同的事务隔离级别，解决了不同程度的数据一致性。而我们所说的全局锁、表锁、行级锁等等，其实都是事务隔离级别的具体实现。而 MVCC、意向锁，则是一些局部的性能优化。</p><p>上面这段话，基本上就是对 MySQL 锁机制很透彻的理解。当我们懂了这些概念之间的关系之后，我们才能更加清晰地理解知识点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结<br>看到这里，我想我们可以对文章开头提出的问题做个解答了：MySQL 不同隔离级别，都使用了什么样的锁？<br>对于任何隔离级别，表级别的表锁、元数据锁、意向锁都是会使用的，但对于行级别的锁则会有些许差别。</p><ul><li>在「读未提交」和「读已提交」隔离级别下，都只会使用<strong>记录锁</strong>，不会用间隙锁，当然也不会有 Next-Key 锁了。</li><li>而对于「可重复读」隔离级别来说，会使用记录锁、间隙锁和 Next-Key 锁。</li></ul><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链接：&lt;a class=&quot;link&quot;   href=&quot;https://zhuanlan.zhihu.com/p/562435658&quot; &gt;https://zhuanlan.zhihu.com/p/562435658&lt;i class=&quot;fas fa-external-link-</summary>
      
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://mynamecoder.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>将博客搬至CSDN</title>
    <link href="https://mynamecoder.com/p/14580.html"/>
    <id>https://mynamecoder.com/p/14580.html</id>
    <published>2023-09-02T16:34:24.000Z</published>
    <updated>2024-01-18T08:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好分享，同意将本站内容将博客搬至CSDN。<br>CSDN地址：<a class="link"   href="https://blog.csdn.net/x851288986" >https://blog.csdn.net/x851288986<i class="fas fa-external-link-alt"></i></a></p><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了更好分享，同意将本站内容将博客搬至CSDN。&lt;br&gt;CSDN地址：&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/x851288986&quot; &gt;https://blog.csdn.net/x851288986&lt;i class=&quot;f</summary>
      
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是幂等性?又如何保证?</title>
    <link href="https://mynamecoder.com/p/20864.html"/>
    <id>https://mynamecoder.com/p/20864.html</id>
    <published>2023-09-01T16:34:24.000Z</published>
    <updated>2024-01-18T08:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是幂等性？"><a href="#什么是幂等性？" class="headerlink" title="什么是幂等性？"></a>什么是幂等性？</h2><p>幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。<br>在增删改查4个操作中，尤为注意就是增加或者修改，因为查询只是读的操作，所以对于结果是不会有改变的；<br>删除只会进行一次，大部分情况下根据主键删除时，用户多次点击产生的结果也是一样的；<br>而修改和增加在重复提交的场景下会非常容易出现幂等性的问题。</p><h2 id="如何保证幂等性"><a href="#如何保证幂等性" class="headerlink" title="如何保证幂等性"></a>如何保证幂等性</h2><ul><li>唯一索引，防止新增脏数据。如新增用户数据，一般用户名是唯一的，所以，我们可以设置用户名字段唯一索引</li><li>token机制，防止页面重复提交。<ul><li>分为两个阶段，获取token和使用token。<br>1、每次接口请求前先获取一个token，返回给前端；<br>2、然后再下次请求的时候在请求的header中加上这个token后端进行验证，如果验证通过就删除token，这时，如果其他请求过来，则验证会不通过，就达到了防止重复提交的问题。</li></ul></li><li>悲观锁（并发高的话慎用） Synchronized(单机环境适用)/数据库悲观锁</li><li>乐观锁 （可能循环时间长开销大） Lock(单机环境适用)/数据库乐观锁</li><li>分布式锁（适用分布式系统）<ul><li>推荐使用第三方组件Redission实现</li></ul></li></ul><h3 id="关注获取更多资源"><a href="#关注获取更多资源" class="headerlink" title="关注获取更多资源"></a>关注获取更多资源</h3><img                       lazyload                     alt="image"                     data-src="https://img.mynamecoder.com/coderxm_qrcode.jpeg"                      width="200" height="200"  align="center"                 >]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是幂等性？&quot;&gt;&lt;a href=&quot;#什么是幂等性？&quot; class=&quot;headerlink&quot; title=&quot;什么是幂等性？&quot;&gt;&lt;/a&gt;什么是幂等性？&lt;/h2&gt;&lt;p&gt;幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</summary>
      
    
    
    
    
    <category term="Java" scheme="https://mynamecoder.com/tags/Java/"/>
    
    <category term="面试" scheme="https://mynamecoder.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
